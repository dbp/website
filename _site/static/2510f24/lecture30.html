<!DOCTYPE html>
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script type="text/x-mathjax-config">
   MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="codemirror.js"></script>
  <script src="python.js"></script>
  <script src="runmode.js"></script>
  <script src="setup-page.js"></script>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="extra-styles.css" title="default">
  <link rel="stylesheet" type="text/css" href="codemirror.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">‚ñ∫</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Fundamentals II
<br>
Introduction to Class-<wbr>based Program Design</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="General.html" class="tocviewlink" data-pltdoc="x">General</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Lab_Materials.html" class="tocviewlink" data-pltdoc="x">Lab Materials</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Pair_Programming_Overview.html" class="tocviewlink" data-pltdoc="x">Pair Programming Overview</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="code-style.html" class="tocviewlink" data-pltdoc="x">Code style</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">‚ñº</a>
        </td>
        <td></td>
        <td>
         <a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture1.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Data Definitions in Java</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture2.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 2:</span> Data Definitions:<span class="mywbr"> &nbsp;</span> Unions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture3.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 3:</span> Methods for simple classes</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture4.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Methods for unions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture5.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 5:</span> Methods for self-<wbr>referential lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture6.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Accumulator methods</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture7.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Accumulator methods, continued</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture8.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Practice Design</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture9.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 9:</span> Abstract classes and inheritance</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture10.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 10:</span> Customizing constructors for correctness and convenience</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture11.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 11:</span> Defining sameness for complex data, part 1</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture12.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Defining sameness for complex data, part 2</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture13.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 13:</span> Abstracting over behavior</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture14.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Abstractions over more than one argument</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture15.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 15:</span> Abstracting over types</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture16.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Visitors</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture17.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 17:</span> Mutation</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture18.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 18:</span> Mutation inside structures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture19.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 19:</span> Mutation, aliasing and testing</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture20.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 20:</span> Mutable data structures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture21.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 21:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture22.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 22:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture23.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 23:</span> For-<wbr>each loops and Counted-<wbr>for loops</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture24.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 24:</span> While loops</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture25.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 25:</span> Iterator and Iterable</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture26.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 26:</span> Hashing and Equality</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture27.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture28.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 28:</span> Quicksort and Mergesort</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture29.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 29:</span> Priority Queues and Heapsort</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 30:</span> Breadth-<wbr>first search and Depth-<wbr>first search on graphs</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture31.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 31:</span> Dijkstra‚Äôs Algorithm for single-<wbr>source shortest paths</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture32.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture33.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 33:</span> Implementing Objects</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">‚ñ∫</a>
        </td>
        <td></td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 30:</span> Breadth-<wbr>first search and Depth-<wbr>first search on graphs</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          30.1&nbsp;
         </td>
         <td>
          <a href="#%28part._.Primer__graphs%29" class="tocviewlink" data-pltdoc="x">Primer:<span class="mywbr"> &nbsp;</span> graphs</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          30.2&nbsp;
         </td>
         <td>
          <a href="#%28part._.Diving_deep__.Finding_any_path_between_two_vertices_via_depth-first_search%29" class="tocviewlink" data-pltdoc="x">Diving deep:<span class="mywbr"> &nbsp;</span> Finding <span class="emph">any</span> path between two vertices via depth-<wbr>first search</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          30.3&nbsp;
         </td>
         <td>
          <a href="#%28part._.Broadening_horizons__.Finding_any_path_between_two_vertices_via_breadth-first_search%29" class="tocviewlink" data-pltdoc="x">Broadening horizons:<span class="mywbr"> &nbsp;</span> Finding <span class="emph">any</span> path between two vertices via breadth-<wbr>first search</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          30.4&nbsp;
         </td>
         <td>
          <a href="#%28part._.Removing_repetition%29" class="tocviewlink" data-pltdoc="x">Removing repetition</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          30.5&nbsp;
         </td>
         <td>
          <a href="#%28part._.Computing_the_actual_path%29" class="tocviewlink" data-pltdoc="x">Computing the actual path</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">30.1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.Primer__graphs%29" class="tocsubseclink" data-pltdoc="x">Primer:<span class="mywbr"> &nbsp;</span> graphs</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">30.1.1
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.Representing_graphs%29" class="tocsubseclink" data-pltdoc="x">Representing graphs</a>
     </td>
    </tr>
    <tr>
     <td>
      <span class="tocsublinknumber">30.1.2
      <tt>
       &nbsp;
      </tt>
     </span>
     <a href="#%28part._.Aside__.Describing_the_performance_of_graph_algorithms%29" class="tocsubseclink" data-pltdoc="x">Aside:<span class="mywbr"> &nbsp;</span> Describing the performance of graph algorithms</a>
    </td>
   </tr>
   <tr>
    <td>
     <span class="tocsublinknumber">30.2
     <tt>
      &nbsp;
     </tt>
    </span>
    <a href="#%28part._.Diving_deep__.Finding_any_path_between_two_vertices_via_depth-first_search%29" class="tocsubseclink" data-pltdoc="x">Diving deep:<span class="mywbr"> &nbsp;</span> Finding <span class="emph">any</span> path between two vertices via depth-<wbr>first search</a>
   </td>
  </tr>
  <tr>
   <td>
    <span class="tocsublinknumber">30.3
    <tt>
     &nbsp;
    </tt>
   </span>
   <a href="#%28part._.Broadening_horizons__.Finding_any_path_between_two_vertices_via_breadth-first_search%29" class="tocsubseclink" data-pltdoc="x">Broadening horizons:<span class="mywbr"> &nbsp;</span> Finding <span class="emph">any</span> path between two vertices via breadth-<wbr>first search</a>
  </td>
 </tr>
 <tr>
  <td>
   <span class="tocsublinknumber">30.4
   <tt>
    &nbsp;
   </tt>
  </span>
  <a href="#%28part._.Removing_repetition%29" class="tocsubseclink" data-pltdoc="x">Removing repetition</a>
 </td>
</tr>
<tr>
 <td>
  <span class="tocsublinknumber">30.4.1
  <tt>
   &nbsp;
  </tt>
 </span>
 <a href="#%28part._.Stacks__.Last-in__.First-out%29" class="tocsubseclink" data-pltdoc="x">Stacks:<span class="mywbr"> &nbsp;</span> Last-<wbr>in, First-<wbr>out</a>
</td>
</tr>
<tr>
<td>
 <span class="tocsublinknumber">30.4.2
 <tt>
  &nbsp;
 </tt>
</span>
<a href="#%28part._.Queues__.First-in__.First-out%29" class="tocsubseclink" data-pltdoc="x">Queues:<span class="mywbr"> &nbsp;</span> First-<wbr>in, First-<wbr>out</a>
</td>
</tr>
<tr>
<td>
<span class="tocsublinknumber">30.4.3
<tt>
 &nbsp;
</tt>
</span>
<a href="#%28part._.Rewriting_.B.F.S_and_.D.F.S%29" class="tocsubseclink" data-pltdoc="x">Rewriting BFS and DFS</a>
</td>
</tr>
<tr>
<td>
<span class="tocsublinknumber">30.5
<tt>
&nbsp;
</tt>
</span>
<a href="#%28part._.Computing_the_actual_path%29" class="tocsubseclink" data-pltdoc="x">Computing the actual path</a>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="maincolumn">
<div class="main">
<div class="versionbox">
<span class="version">8.14</span>
</div>
<div class="navsettop">
<span class="navleft">
<div class="nosearchform"></div>
&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="lecture29.html" title="backward to &quot;Lecture 29: Priority Queues and Heapsort&quot;" data-pltdoc="x" rel="prev">‚Üê prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture31.html" title="forward to &quot;Lecture 31: Dijkstra's Algorithm for single-source shortest paths&quot;" data-pltdoc="x" rel="next">next ‚Üí</a></span>&nbsp;
</div>
<h4 class="heading">
<a name="(part._)"></a><span class="LectureNum">Lecture 30:</span> Breadth-first search and Depth-first search on graphs<span class="button-group"><a href="#(part._)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h4>
<p class="boxed">
Finding paths from one node to another
</p>
<p>
Finding a route from one location to another is a fundamental question in everyday life, and it shows up in
many forms, from explicit questions (‚ÄúCan you give me directions to get to the library from here?‚Äù, or ‚ÄúWhat prerequisites must I take
in order to qualify for this class?‚Äù), to more abstract problems (e.g., tracing the spread of a meme going viral).  Often
the goal is not merely to find <span class="emph">a</span> route, but to find the <span class="emph">shortest</span> route from one place to another.
</p>
<h5 class="heading">
30.1
<tt>
&nbsp;
</tt>
<a name="(part._.Primer__graphs)"></a>Primer: graphs<span class="button-group"><a href="#(part._.Primer__graphs)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
We can model all of these problems as asking questions about <span class="emph">graphs</span>, which are simply abstract representations of
connections between things.  We say a graph is a collection of <span class="emph">vertices</span> (or <span class="emph">nodes</span>) and <span class="emph">edges</span> between vertices:
</div>
<div class="SIntrapara">
<ul>
<li>
<p>
A social graph tracks relationships (the edges) between people (the vertices)
</p>
</li>
<li>
<p>
A road network tracks roads (the edges) between places (the vertices)
</p>
</li>
<li>
<p>
A airline network tracks flights (the edges) between cities (the vertices)
</p>
</li>
<li>
<p>
A curriculum dependency graph tracks prerequsites (the edges) between courses (the vertices)
</p>
</li>
</ul>
</div>
<div class="SIntrapara">
Graphs can be <span class="emph">directed</span> or <span class="emph">undirected</span>: in directed graphs the edges point <span class="emph">from</span> one node <span class="emph">to</span> another,
whereas in undirected graphs the edges connect in both directions.  All the examples above are <span class="emph">directed</span> graphs:
</div>
<div class="SIntrapara">
<ul>
<li>
<p>
While friendships are usually mutual, one person might have a crush on another that isn‚Äôt reciprocated.
</p>
</li>
<li>
<p>
One-way roads allow travel in one direction only, by definition!
</p>
</li>
<li>
<p>
A direct flight from one city to another does not necessarily imply there is also a direct return flight.
</p>
</li>
<li>
<p></p>
<div class="SIntrapara">
<blockquote class="refpara">
<blockquote class="refcolumn">
<blockquote class="refcontent">
<p>
 Actually, when a graph <span class="emph">claims</span> to be a dependency graph, but contains a cycle (or mutual dependency), problems typically arise.
The algorithms we discuss today will work fine in the presence of cycles, but other algorithms might not.
</p>
</blockquote>
</blockquote>
</blockquote>
</div>
<div class="SIntrapara">
Dependency graphs imply a ‚Äúcomes-before‚Äù relationship: you must take Fundies 2 before taking Algorithms, for example.
It would be very problematic to claim that Algorithms depends on Fundies 2...and Fundies 2 likewise depends on Algorithms!
</div>
<p></p>
</li>
</ul>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Which is more general: directed graphs or undirected graphs?
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
We can always represent an undirected graph as a directed graph, by replacing each edge in the undirected graph with a pair of directed edges pointing in opposite directions.
</div>
<p></p>
<p></p>
<div class="SIntrapara">
Graphs may also be <span class="emph">weighted</span>, meaning that each edge has a cost or value associated with it:
</div>
<div class="SIntrapara">
<ul>
<li>
<p>
Social graphs are unweighted: either a friendship exists or it does not.
</p>
</li>
<li>
<p>
Road networks are weighted: recording the <span class="emph">distance</span> between places.
</p>
</li>
<li>
<p>
Airline networks are weighted: they might record the <span class="emph">price</span> of a ticket, or the distance of the flight, or some other cost.
</p>
</li>
<li>
<p>
A curriculum dependency graph is unweighted: each course is either a prerequisite or it is not.
</p>
</li>
</ul>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Which is more general: weighted graphs or unweighted graphs?
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
We can always represent an unweighted graph as a weighted graph, by making all the edge weights the same (e.g., 1).
</div>
<p></p>
<h5 class="heading">
30.1.1
<tt>
&nbsp;
</tt>
<a name="(part._.Representing_graphs)"></a>Representing graphs<span class="button-group"><a href="#(part._.Representing_graphs)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p>
How might we choose to represent graphs?  One possibility is to record a graph as an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjIdentifier">weight</span><span class="ProfjKeyword">&gt;&gt;</span><span class="RktMeta"></span></span></span>, where <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">weight</span><span class="RktMeta"></span></span></span> is
whatever kind of weights we need (for our purposes, usually <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Integer</span><span class="RktMeta"></span></span></span>s), and the entry <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">graph</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">i</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">j</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> gives the weight of
connecting vertex \(i\) to vertex \(j\).  Of course, not all vertices are connected to all other vertices, so we would need
an ‚Äúinvalid‚Äù value to mark those cases: we might choose to use <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">null</span><span class="RktMeta"></span></span></span> for this.  This representation is called the <span class="emph">adjacency matrix</span>
representation, and it‚Äôs pretty convenient when almost every node is connected to almost every other node.  It does have the drawback that
we have to manually check for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">null</span><span class="RktMeta"></span></span></span> all the time, and it also has the drawback that we can‚Äôt store any additional information about vertices,
since we‚Äôre representing vertices merely as an index in the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>s.
</p>
<p></p>
<div class="SIntrapara">
An alternate representation might be to have explicit <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span> and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Edge</span><span class="RktMeta"></span></span></span> classes, as follows:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">any</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">data</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">about</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">vertices</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">such</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">as</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">people</span><span class="ProfjError">'s </span><span class="ProfjIdentifier">names</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">or</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">place</span><span class="ProfjError">'s </span><span class="ProfjConstant">GPS</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">coordinates</span><span class="ProfjWhiteSpace"> </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">IList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">outEdges</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// edges from this node
</span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">weight</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Graph</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">IList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">allVertices</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
This representation is known as the <span class="emph">adjacency list</span> representation, and it avoids some of the problems of the adjacency matrix representation, while introducing some of its own.
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Design a method for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Graph</span><span class="RktMeta"></span></span></span> to collect all the edges in the graph.
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
In the adjacency-matrix representation, we could find all the vertices <span class="emph">reachable from</span> a given vertex by looking in a row of the matrix,
and we could find all the vertices <span class="emph">that reach</span> a given vertex by looking in a column of the matrix.  (Why?)  In the adjacency-list
representation, we can easily find all the vertices reachable from a given vertex: it‚Äôs simply the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">outEdges</span><span class="RktMeta"></span></span></span> field.
Design a method <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">inEdges</span><span class="RktMeta"></span></span></span> on <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Graph</span><span class="RktMeta"></span></span></span> that computes the list of vertices that reach the given vertex.
</div>
<p></p>
</blockquote>
</div>
<p></p>
<h5 class="heading">
30.1.2
<tt>
&nbsp;
</tt>
<a name="(part._.Aside__.Describing_the_performance_of_graph_algorithms)"></a>Aside: Describing the performance of graph algorithms<span class="button-group"><a href="#(part._.Aside__.Describing_the_performance_of_graph_algorithms)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
When we talk about graph algorithms, often their performance depends on the number of vertices and the number of edges in the graph.
As a result, we often define their performance as functions of \(V\), the number of vertices, and \(E\), the number of edges.
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Using big-\(O\) notation, how many edges can there be in a graph, as a function of the number of vertices?  Using big-\(\Omega\),
how few edges could there be in a graph?  How few edges might there be if every vertex is connected?
</div>
<p></p>
</blockquote>
</div>
<p></p>
<p>
We can also use these parameters to compare the two representations above, in terms of memory usage.
For example, the memory requirements for the adjacency-matrix representation are \(O(V^2)\), because there is an entry in the matrix
for every pair of vertices, regardless of how many edges there are.  In contrast, the adjacency-list representation uses \(O(V + E)\)
memory, because we allocate one <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Edge</span><span class="RktMeta"></span></span></span> object for each edge, one <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ConsList</span><span class="RktMeta"></span></span></span> object for each edge, and one <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span> object for each vertex.
When \(E &lt; V^2\), this representation is more memory-efficient.
</p>
<h5 class="heading">
30.2
<tt>
&nbsp;
</tt>
<a name="(part._.Diving_deep__.Finding_any_path_between_two_vertices_via_depth-first_search)"></a>Diving deep: Finding <span class="emph">any</span> path between two vertices via depth-first search<span class="button-group"><a href="#(part._.Diving_deep__.Finding_any_path_between_two_vertices_via_depth-first_search)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
Finding a path from one vertex to another requires, at a bare minimum, the ability to recognize the destination vertex and report success.
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
How can we tell when two vertices of the graph are ‚Äúthe same‚Äù?  Which notion of equality is most appropriate here?
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
The first thing to notice about our adjacency-list representation above is that we do not include a notion of <span class="emph">names</span> for vertices.
(In the adjacency-matrix, by contrast, every node had a unique index.)  So the only reliable mechanism we have to distinguish
two <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span> objects is via <span class="emph">intensional</span> equality.  In particular, we are careful <span class="emph">not</span> to override <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">equals</span><span class="RktMeta"></span></span></span>
with a customized equality check, so that we are guaranteed the default intensional equality.  This works, and is convenient, but means we need to be careful
never to allocate new <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span> objects if we don‚Äôt mean to!
</div>
<p></p>
<p></p>
<div class="SIntrapara">
But how are we to actually find a path from one <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span> to another?  Let‚Äôs try a simpler question, of merely determining
whether there is such a path or not.
When we considered ancestry trees, we considered a simple problem <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasAncestorNamed</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">String</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">name</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>,
which checked the parents, grandparents and further for any <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Person</span><span class="RktMeta"></span></span></span> with the given name.  Perhaps we could implement
something similar here?  Let‚Äôs assume that we‚Äôve implemented iterators for our <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">IList</span><span class="RktMeta"></span></span></span>s, as we did in <a href="lecture25.html" data-pltdoc="x"><span class="LectureNum">Lecture 25:</span> Iterator and Iterable</a>,
so that we can conveniently write a for-each loop to iterate over edges:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// In Vertex
</span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasPathTo</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dest</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">e</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">outEdges</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjWhiteSpace">   </span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dest</span><span class="ProfjWhiteSpace">            </span><span class="ProfjComment">// can get there in just one step
</span><span class="ProfjWhiteSpace">        </span><span class="ProfjKeyword">||</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">hasPathTo</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">dest</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// can get there on a path through e.to
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">true</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">false</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Why can we not just simplify the if statement to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dest</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">||</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">hasPathTo</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">dest</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>?
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Will this code always work?  Give an explanation of why, or an example graph that breaks it.
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
The nice thing about ancestry trees is that, well, they were <span class="emph">trees</span>: it was impossible for any <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Person</span><span class="RktMeta"></span></span></span> to
be their own ancestor.  Actually, <span class="emph">tree</span> is a bit of a misnomer, since in some families (such as various historical European aristocracies)
we find that distant relatives that share a common ancestor eventually have a child together.  In these situations, the familiy tree
is not tree-shaped, but is rather a slightly more general notion: a <span class="emph">directed acyclic graph</span>.
</div>
<p></p>
<p>
But we‚Äôre no longer dealing with ancestry trees ‚Äî<wbr> we have arbitrary graphs to deal with, and these graphs may include cycles.
In the following directed graph, vertex A cannot reach vertex E, but if we run the code above starting at A, we‚Äôll endlessly loop around the cycle A-&gt;B-&gt;C:
</p>
<p>
<img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_34.png" alt="image" width="146.0" height="90.1328125">
</p>
<p></p>
<div class="SIntrapara">
When we encountered this problem in Fundies 1, we introduced an <span class="emph">accumulator parameter</span> that stored all the nodes we‚Äôd already
seen, so that we could abort the recursion before it looped indefinitely.
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Implement this strategy for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span>.
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
This approach will work, but let‚Äôs consider a slightly different way of organizing the problem.  Let‚Äôs try to design a method
on <span class="emph"><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Graph</span><span class="RktMeta"></span></span></span></span> instead, using loops instead of recursion, and let‚Äôs consider a different way of representing the accumulator.
We‚Äôll start with the following signature:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// In Graph
</span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasPathBetween</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
We‚Äôll need to keep track of a list of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> vertices.  And we‚Äôll also need to keep track of a <span class="emph">worklist</span>:
all the nodes that we have not yet finished processing.  We‚Äôre going to need to add and remove items from these lists,
in various places in the list.  Fortunately, we have implemented a datatype that allows us to do this: a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span>!
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// In Graph
</span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasPathBetween</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
Look again at how the original code above tried to work: it iterated over all the outgoing edges from a given vertex and recursively called
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">hasPathTo</span><span class="RktMeta"></span></span></span> to see if they could reach the destination.  By virtue of the nature of function calls, when we <span class="emph">return</span> from a
recursive call, we still have all the remaining outgoing edges to process.  Effectively, they make up an <span class="emph">implicit</span> worklist.  Now that we
are managing the worklist ourselves, we‚Äôll have to make that become explicit.
</div>
<p></p>
<p></p>
<div class="SIntrapara">
To start the algorithm, we know we must process <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">from</span><span class="RktMeta"></span></span></span>, so we should add that vertex to our worklist.  Then our algorithm is very simple:
as long as we haven‚Äôt found our destination yet, and as long as there are more places to try, process the next place.  This maps very neatly
to the following code skeleton:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// In Graph
</span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasPathBetween</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Initialize the worklist with the from vertex
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">into</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// As long as the worklist isn't empty...
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">while</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">!</span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">and</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">off</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">equals</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">true</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// Success!
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contains</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// do nothing: we've already seen this one
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">is</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">a</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">we</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">haven</span><span class="ProfjError">'t </span><span class="ProfjIdentifier">seen</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">yet</span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">process</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">it</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// We haven't found the to vertex, and there are no more to try
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">false</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
There are some gaps to fill in this skeleton.  The primary decision we have to make is where to add and remove items in the worklist.
Think about the order that nodes were visited in the recursive approach above.  As we visit each vertex adjacent to the vertex,
we process that vertex <span class="emph">completely</span> before backing up and trying again with the next neighbor of this vertex.  Let‚Äôs say we decide to
always remove and process the first node of the worklist.  To match the recursive approach‚Äôs behavior, we should therefore make certain to add new nodes for processing
at the front of the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span>, so that we‚Äôll process them completely (and remove them) before moving on to their neighbors.  This leads to the following complete code:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// In Graph
</span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">hasPathBetween</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Initialize the worklist with the from vertex
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">from</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// As long as the worklist isn't empty...
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">while</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">!</span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">removeFromHead</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">equals</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">true</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// Success!
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contains</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// do nothing: we've already seen this one
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// add all the neighbors of next to the worklist for further processing
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">e</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">outEdges</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">        </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// add next to alreadySeen, since we're done with it
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// We haven't found the to vertex, and there are no more to try
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">false</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
Let‚Äôs trace the behavior of this algorithm, trying to find a path between B and E.
</div>
<div class="SIntrapara">
<ol>
<li>
<p>
The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span> starts off as <span class="stt">[]</span>, and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> is also <span class="stt">[]</span>.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>
</p>
</li>
<li>
<p>
We add B to the worklist.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>
</p>
</li>
<li>
<p>
We start the while loop.  Since the worklist isn‚Äôt empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: B
</p>
</li>
<li>
<p>
Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn‚Äôt node E, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not contain it, we get to the else case, and add each of B‚Äôs neighbors (namely C and D)
to the front of the worklist.
</p>
<p></p>
<div class="SIntrapara">
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[D, C]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[B]</span>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Why are C and D ‚Äúbackwards‚Äù in the worklist?
</div>
<p></p>
</blockquote>
</div>
<p></p>
</li>
<li>
<p>
We return to the start of the while loop.  Since the worklist isn‚Äôt empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[C]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: D
</p>
</li>
<li>
<p>
Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn‚Äôt node E, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not contain it, we get to the else case, and add each of D‚Äôs neighbors (of which there are none)
to the front of the worklist.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[C]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[D, B]</span>
</p>
</li>
<li>
<p>
We return to the start of the while loop.  Since the worklist isn‚Äôt empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[D, B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: C
</p>
</li>
<li>
<p>
Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn‚Äôt node E, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not contain it, we get to the else case, and add each of C‚Äôs neighbors (namely A)
to the front of the worklist.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[A]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[C, D, B]</span>
</p>
</li>
<li>
<p>
We return to the start of the while loop.  Since the worklist isn‚Äôt empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[C, D, B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: A
</p>
</li>
<li>
<p>
Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn‚Äôt node E, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not contain it, we get to the else case, and add each of A‚Äôs neighbors (namely B)
to the front of the worklist.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, C, D, B]</span>
</p>
</li>
<li>
<p>
We return to the start of the while loop.  Since the worklist isn‚Äôt empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, C, D, B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: B
</p>
</li>
<li>
<p>
Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn‚Äôt node E, but since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> now <span class="emph">does</span> contain it, we do nothing, and silently discard node B again.
</p>
<p>
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, C, D, B]</span>
</p>
</li>
<li>
<p>
We return to the start of the while loop.  Now the worklist is empty, so we exit the loop, and return <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">false</span><span class="RktMeta"></span></span></span>.
</p>
</li>
</ol>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Trace through the evaluation of this method, trying to find a path between A and C.  Which nodes, if any, are left over in the worklist?
</div>
<p></p>
</blockquote>
</div>
<p></p>
<p>
This algorithm descends deeply into the graph, going as far as it can following edges out from a single node before it reaches a cycle.  Accordingly,
it is known as <span class="emph">depth-first search</span> (or DFS).
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
What is its runtime?
</div>
<p></p>
</blockquote>
<p>
The best-case scenario is that the starting and ending nodes are one and the
same, and the algorithm finishes instantly, in \(\Omega(1)\) time and space.
This case isn‚Äôt very interesting; it‚Äôs exceedingly unlikely that this occurs.
So what is the worst-case behavior?  Following the idiom that ‚Äúit‚Äôs always the
last place you look‚Äù, the worst-case behavior means that we have to examine
every single edge and node before finding the one we want.  Accordingly, the
algorithm seems to take \(O(V + E)\) time to run.  But our analysis was too
glib: we didn‚Äôt quite count the cost of the loop body correctly.  In
particular, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contains</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> could itself take \(O(V)\)
time to run, since it‚Äôs a simple <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span> whose cost of searching is linear
in its length.  So the actual runtime here is \(O(V^2 + E)\), which is
simply \(O(V^2)\).
</p>
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
This observation makes for a very simple improvement to this
algorithm: instead of using a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span>, what other data structure could we
use to improve this bottleneck?  And how might we need to change our
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Vertex</span><span class="RktMeta"></span></span></span> class to enable more efficient look-ups?
</div>
<p></p>
</blockquote>
<p></p>
<div class="SIntrapara">
How much storage does the algorithm need? (Note that this is separate from how much storage the graph itself needs; we discussed that earlier and it depends on the
graph representation.)  The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> accumulator can contain at most every node in the graph, exactly once, so it uses \(O(V)\) space.
The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span> is a little trickier to analyze.  In the worst case, it could actually contain \(O(V^2)\) nodes, because some nodes appear multiple times.
</div>
<div class="SIntrapara">
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
Work out a graph for which this might happen.  Hint: it has <span class="emph">lots</span> of edges.
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
Accordingly, our algorithm needs a total of \(O(V^2)\) space to work, in the worst case.
</div>
<p></p>
<h5 class="heading">
30.3
<tt>
&nbsp;
</tt>
<a name="(part._.Broadening_horizons__.Finding_any_path_between_two_vertices_via_breadth-first_search)"></a>Broadening horizons: Finding <span class="emph">any</span> path between two vertices via breadth-first search<span class="button-group"><a href="#(part._.Broadening_horizons__.Finding_any_path_between_two_vertices_via_breadth-first_search)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p>
In the algorithm above, we chose to process a vertex <span class="emph">completely</span> before backtracking and moving to one of its neighbors, and we implemented that
by always adding new items to the worklist at the front, which is where we also removed items.  What if we changed that choice, and added items to the back?
Practically speaking, this changes exactly two lines of code (both calls to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">addAtHead</span><span class="RktMeta"></span></span></span> become calls to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">addAtTail</span><span class="RktMeta"></span></span></span>).  But what effect does this
change have on the algorithm?
</p>
<p>
By adding new nodes to the <span class="emph">back</span> of the worklist, we effectively make them ‚Äúwait their turn‚Äù, so that previously-added nodes get processed first.
This means that we will process the starting node first, then all of its neighbors, then all of their neighbors (that haven‚Äôt already been processed),
then all nodes 3 edges away from the start (that haven‚Äôt already been processed), then all nodes 4 edges away, etc.  Our search
<span class="emph">broadens outward</span> from the start, rather than diving deeply into a single path.  Accordingly, this is known as a <span class="emph">breadth-first search</span> (or BFS).
</p>
<p>
Because our <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span> allows us to add items to the front or the back of the list in constant time, this change does not affect the runtime or memory usage
of our algorithm at all.
</p>
<h5 class="heading">
30.4
<tt>
&nbsp;
</tt>
<a name="(part._.Removing_repetition)"></a>Removing repetition<span class="button-group"><a href="#(part._.Removing_repetition)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
The implementations of BFS and DFS are practically identical: they differ only in the strategy used to add new items to the worklist.  How can we eliminate this duplication?
What operations do these two algorithms need from worklists?  Merely the ability to add an item, remove the first item, and check if the worklist is empty.
We can define an interface that does just this and nothing more:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// Represents a mutable collection of items
</span><span class="ProfjKeyword">interface</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ICollection</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Is this collection empty?
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// EFFECT: adds the item to the collection
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Returns the first item of the collection
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// EFFECT: removes that first item
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
Now, we can define two implementations of this interface, that <span class="emph">wrap</span> a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> and implement these two strategies by delegating to that <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span>.
</div>
<p></p>
<h5 class="heading">
30.4.1
<tt>
&nbsp;
</tt>
<a name="(part._.Stacks__.Last-in__.First-out)"></a>Stacks: Last-in, First-out<span class="button-group"><a href="#(part._.Stacks__.Last-in__.First-out)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
One possible implementation is the one needed by depth-first search:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Stack</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">implements</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ICollection</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Stack</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">removeFromHead</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
This behavior is known as a <span class="emph">stack</span>: adding new items keeps piling them on top of existing ones, and the first item to be processed is the one most recently added.
(This is occasionally described as ‚Äúlast-in, first-out‚Äù or LIFO behavior.)
</div>
<p></p>
<h5 class="heading">
30.4.2
<tt>
&nbsp;
</tt>
<a name="(part._.Queues__.First-in__.First-out)"></a>Queues: First-in, First-out<span class="button-group"><a href="#(part._.Queues__.First-in__.First-out)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
The alternative implementation, needed by breadth-first search, adds items to the back:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Queue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">implements</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ICollection</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Queue</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">removeFromHead</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contents</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtTail</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">item</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// NOTE: Different from Stack!
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
This behavior is known as a <span class="emph">queue</span>: adding new items get in line behind existing ones, and the first item to enter the queue is the first item to be processed.
(This is occasionally described as ‚Äúfirst-in, first-out‚Äù or FIFO behavior.)
</div>
<p></p>
<h5 class="heading">
30.4.3
<tt>
&nbsp;
</tt>
<a name="(part._.Rewriting_.B.F.S_and_.D.F.S)"></a>Rewriting BFS and DFS<span class="button-group"><a href="#(part._.Rewriting_.B.F.S_and_.D.F.S)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
We can now factor out the commonalities of breadth- and depth-first search, by <span class="emph">supplying</span> them with a worklist object, ready to use:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjComment">// In Graph
</span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bfs</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">searchHelp</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Queue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">dfs</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">searchHelp</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Stack</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">searchHelp</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ICollection</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Initialize the worklist with the from vertex
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">from</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// As long as the worklist isn't empty...
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">while</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">!</span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">equals</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">true</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// Success!
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contains</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// do nothing: we've already seen this one
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// add all the neighbors of next to the worklist for further processing
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">e</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">outEdges</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">        </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// add next to alreadySeen, since we're done with it
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// We haven't found the to vertex, and there are no more to try
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">false</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
</td>
</tr>
<tr>
<td>
<span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
</td>
</tr>
</tbody>
</table>
</blockquote>
</div>
</div>
<div class="SIntrapara">
This refactoring makes it clear how much the two algorithms have in common, and also makes it far more likely to implement them both correctly:
the searching code is far subtler than the code for stacks and queues, so it makes sense to only write it once!
</div>
<p></p>
<h5 class="heading">
30.5
<tt>
&nbsp;
</tt>
<a name="(part._.Computing_the_actual_path)"></a>Computing the actual path<span class="button-group"><a href="#(part._.Computing_the_actual_path)" class="heading-anchor" title="Link to here">üîó</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
Extend the code above so that instead of merely returning true, it returns a list of the vertices along the path from the source
to the destination.
</div>
<p></p>
</blockquote>
</div>
<div class="SIntrapara">
Breadth-first search has one advantage over depth-first search, in that it will find the shortest path between the two vertices,
in terms of the number of edges needed.  This is the optimal path, when graphs are <span class="emph">unweighted</span>.
In the next lecture, we‚Äôll see a third version of this code, that allows us to compute the shortest path <span class="emph">by weight</span>.
</div>
<p></p>
<div class="navsetbottom">
<span class="navleft">
<div class="nosearchform"></div>
&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="lecture29.html" title="backward to &quot;Lecture 29: Priority Queues and Heapsort&quot;" data-pltdoc="x" rel="prev">‚Üê prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture31.html" title="forward to &quot;Lecture 31: Dijkstra's Algorithm for single-source shortest paths&quot;" data-pltdoc="x" rel="next">next ‚Üí</a></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
