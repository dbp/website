<!DOCTYPE html>
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script type="text/x-mathjax-config">
   MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="codemirror.js"></script>
  <script src="python.js"></script>
  <script src="runmode.js"></script>
  <script src="setup-page.js"></script>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="extra-styles.css" title="default">
  <link rel="stylesheet" type="text/css" href="codemirror.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Fundamentals II
<br>
Introduction to Class-<wbr>based Program Design</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="General.html" class="tocviewlink" data-pltdoc="x">General</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Lab_Materials.html" class="tocviewlink" data-pltdoc="x">Lab Materials</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Pair_Programming_Overview.html" class="tocviewlink" data-pltdoc="x">Pair Programming Overview</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="code-style.html" class="tocviewlink" data-pltdoc="x">Code style</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a>
        </td>
        <td></td>
        <td>
         <a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture1.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Data Definitions in Java</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture2.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 2:</span> Data Definitions:<span class="mywbr"> &nbsp;</span> Unions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture3.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 3:</span> Methods for simple classes</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture4.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Methods for unions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture5.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 5:</span> Methods for self-<wbr>referential lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture6.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Accumulator methods</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture7.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Accumulator methods, continued</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture8.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Practice Design</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture9.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 9:</span> Abstract classes and inheritance</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture10.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 10:</span> Customizing constructors for correctness and convenience</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture11.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 11:</span> Defining sameness for complex data, part 1</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture12.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Defining sameness for complex data, part 2</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture13.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 13:</span> Abstracting over behavior</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture14.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Abstractions over more than one argument</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture15.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 15:</span> Abstracting over types</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture16.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Visitors</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture17.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 17:</span> Mutation</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture18.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 18:</span> Mutation inside structures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture19.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 19:</span> Mutation, aliasing and testing</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture20.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 20:</span> Mutable data structures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture21.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 21:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture22.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 22:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture23.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 23:</span> For-<wbr>each loops and Counted-<wbr>for loops</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture24.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 24:</span> While loops</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture25.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 25:</span> Iterator and Iterable</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture26.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 26:</span> Hashing and Equality</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture27.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture28.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 28:</span> Quicksort and Mergesort</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture29.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 29:</span> Priority Queues and Heapsort</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture30.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 30:</span> Breadth-<wbr>first search and Depth-<wbr>first search on graphs</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture31.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 31:</span> Dijkstra’s Algorithm for single-<wbr>source shortest paths</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lecture33.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 33:</span> Implementing Objects</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a>
        </td>
        <td></td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          32.1&nbsp;
         </td>
         <td>
          <a href="#%28part._.Running_example%29" class="tocviewlink" data-pltdoc="x">Running example</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          32.2&nbsp;
         </td>
         <td>
          <a href="#%28part._.Prim_s_algorithm%29" class="tocviewlink" data-pltdoc="x">Prim’s algorithm</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          32.3&nbsp;
         </td>
         <td>
          <a href="#%28part._.Kruskal_s_algorithm%29" class="tocviewlink" data-pltdoc="x">Kruskal’s algorithm</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">32.1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.Running_example%29" class="tocsubseclink" data-pltdoc="x">Running example</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">32.2
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.Prim_s_algorithm%29" class="tocsubseclink" data-pltdoc="x">Prim’s algorithm</a>
     </td>
    </tr>
    <tr>
     <td>
      <span class="tocsublinknumber">32.3
      <tt>
       &nbsp;
      </tt>
     </span>
     <a href="#%28part._.Kruskal_s_algorithm%29" class="tocsubseclink" data-pltdoc="x">Kruskal’s algorithm</a>
    </td>
   </tr>
   <tr>
    <td>
     <span class="tocsublinknumber">32.3.1
     <tt>
      &nbsp;
     </tt>
    </span>
    <a href="#%28part._.The_.Union_.Find_data_structure%29" class="tocsubseclink" data-pltdoc="x">The Union/<span class="mywbr"> &nbsp;</span>Find data structure</a>
   </td>
  </tr>
  <tr>
   <td>
    <span class="tocsublinknumber">32.3.1.1
    <tt>
     &nbsp;
    </tt>
   </span>
   <a href="#%28part._.Example%29" class="tocsubseclink" data-pltdoc="x">Example</a>
  </td>
 </tr>
 <tr>
  <td>
   <span class="tocsublinknumber">32.3.2
   <tt>
    &nbsp;
   </tt>
  </span>
  <a href="#%28part._.Putting_the_union_find_data_structure_to_work%29" class="tocsubseclink" data-pltdoc="x">Putting the union/<span class="mywbr"> &nbsp;</span>find data structure to work</a>
 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="maincolumn">
<div class="main">
<div class="versionbox">
<span class="version">8.14</span>
</div>
<div class="navsettop">
<span class="navleft">
<div class="nosearchform"></div>
&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="lecture31.html" title="backward to &quot;Lecture 31: Dijkstra's Algorithm for single-source shortest paths&quot;" data-pltdoc="x" rel="prev">← prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture33.html" title="forward to &quot;Lecture 33: Implementing Objects&quot;" data-pltdoc="x" rel="next">next →</a></span>&nbsp;
</div>
<h4 class="heading">
<a name="(part._)"></a><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees<span class="button-group"><a href="#(part._)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h4>
<p class="boxed">
Minimum spanning trees: Borůvka’s, Prim’s and Kruskal’s algorithms
</p>
<p>
Early in the 20th century, the challenge of electrifying towns and cities was
one of the pressing issues facing civil engineers.  In 1926, a Moravian
academic named Otakar Borůvka considered the problem and came up with
<a href="https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm">a
solution</a>.  A workable solution needed to:
</p>
<ul>
<li>
<p>
Connect all the towns to the power stations, either directly or
indirectly, so that everyone who was supposed to receive electricity actually
did.
</p>
</li>
<li>
<p>
At least for an initial deployment, simply ensuring that everyone gets
connected is more important than making sure that there are backup connections
for each place.
</p>
</li>
<li>
<p>
Building an initial deployment is expensive, so minimizing costs is
important.
</p>
</li>
</ul>
<p>
More impressively, Borůvka expressed the solution not solely in terms of wires
and electricity, but in terms of an abstract <span class="emph">weighted graph</span>.  The lack
of backup connections implies that a solution must be a <span class="emph">tree</span> (as opposed
to a graph that might have multiple paths or cycles); the connectedness
requirement means it should be a <span class="emph">spanning</span> tree (as opposed to a
disconnected forest of multiple trees); and the cost focus means it should be a
<span class="emph">minimum</span> spanning tree (as opposed to a more expensive tree).
</p>
<p>
(Unfortunately, Borůvka wrote up his solution in Czech, in a relatively obscure
Czech journal, and few European or American computer scientists heard about the
result.  It was rediscovered several times, and finally became better known
when Sollin rediscovered it in 1965 and published it...in French.  Coming up with
a useful result only matters when people find out about it!)
</p>
<p>
A fellow Czech researcher, Vojtěch Jarník, built upon Borůvka’s result and
simplified it, and published a related algorithm in 1930.  That algorithm, too,
was not widely known until 1957, when Robert Prim rediscovered it.  Today, the
fastest known algorithms for solving the minimum spanning tree problem are a
hybrid of Borůvka’s and Prim’s results.
</p>
<p>
Prim’s algorithm, as we’ll see below, is closely related to a third
minimum-spanning-tree algorithm, discovered by Joseph Kruskal in 1956: they
differ only in the ordering that they choose edges to add to the tree.
However, the detailed bookkeeping of the two algorithms is very different, and
it’s worth studying both.
</p>
<h5 class="heading">
32.1
<tt>
&nbsp;
</tt>
<a name="(part._.Running_example)"></a>Running example<span class="button-group"><a href="#(part._.Running_example)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
We’ll use the following classes in our examples below:
</div>
<div class="SIntrapara">
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
 <tbody>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">outEdges</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">weight</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Graph</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">vertices</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
   </td>
  </tr>
  <tr>
   <td>
    <span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span>
   </td>
  </tr>
 </tbody>
</table>
</blockquote>
</div>
</div>
<p></p>
<p>
Consider the following graph:
</p>
<p>
<img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_36.png" alt="image" width="266.0" height="130.1328125">
</p>
<p>
The edges are drawn without directional arrows, and the numbers on each edge
represents their weight.
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
List the edges (e.g., AB,BF,EC etc) of three <span class="emph">different</span>
spanning trees for this graph.  Find a <span class="emph">minimum</span> spanning tree for this
graph.  How can you be confident that it’s actually minimal?  What strategy did
you use to pick the edges?
</div>
<p></p>
</blockquote>
<p>
One possible minimum spanning tree for this graph are the edges
AB,BE,BF,EC,CD.  Let’s see how to compute that.
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Suppose we want to construct a spanning tree; what edge should we
start with?  Why?
</div>
<p></p>
</blockquote>
<p>
It seems intuitively obvious that we should start with the edge EC, since it’s
the cheapest edge in the entire graph.  How can we be certain that that edge
<span class="emph">must</span> be in the final minimum spanning tree?  Let’s think about it by
contradiction: suppose it <span class="emph">wasn’t</span> part of the minimum spanning tree.
Then we must have some other spanning tree, that is supposedly minimal, that
managed to find some other path connecting E and C.  We’re going to improve
this spanning tree, and lower its overall weight.  That other path connecting E
to C has some weight <span style="font-style: italic">W</span>.  Let’s deliberately introduce a cycle, by adding
the edge EC to this path.  This cycle now has weight <span style="font-style: italic">W+</span>1<span style="font-style: italic"></span>5<span style="font-style: italic"></span>.  We can break
the cycle by removing any of its edges, <span class="emph">and all the nodes will remain
connected</span>.  So we are free to choose whichever edge we like, and any of the
other edges will be more expensive than edge EC (why?).  Which in turn means
that deleting some other edge will result in a spanning tree that has weight
<span style="font-style: italic">W + </span>1<span style="font-style: italic"></span>5<span style="font-style: italic"> - </span>(<span style="font-style: italic">something greater than </span>1<span style="font-style: italic"></span>5<span style="font-style: italic"></span>)<span style="font-style: italic"></span>, which is a
<span class="emph">lower total weight</span> than the tree that we started with, contradicting our
assumption that we had a minimum spanning tree.
</p>
<p>
Let’s make this argument concrete: suppose that path were EA,AB,BC. Then the
path weight is <span style="font-style: italic"></span>5<span style="font-style: italic"></span>0<span style="font-style: italic">+</span>3<span style="font-style: italic"></span>0<span style="font-style: italic">+</span>4<span style="font-style: italic"></span>0<span style="font-style: italic"> = </span>1<span style="font-style: italic"></span>2<span style="font-style: italic"></span>0<span style="font-style: italic"></span>.  We add the edge CE to make a cycle of
weight <span style="font-style: italic"></span>1<span style="font-style: italic"></span>2<span style="font-style: italic"></span>0<span style="font-style: italic">+</span>1<span style="font-style: italic"></span>5<span style="font-style: italic"> = </span>1<span style="font-style: italic"></span>3<span style="font-style: italic"></span>5<span style="font-style: italic"></span>.  Now we can choose to remove any of the four edges
in that cycle, and the overall tree is still connected.  If we delete AE, the
total weight drops to <span style="font-style: italic"></span>1<span style="font-style: italic"></span>3<span style="font-style: italic"></span>5<span style="font-style: italic"> - </span>5<span style="font-style: italic"></span>0<span style="font-style: italic"> = </span>8<span style="font-style: italic"></span>5<span style="font-style: italic"></span>, which is lower than the 120 that we
started with.  If we drop AB, it drops to 105, and if we drop BC, it drops to
95.  All of those are better than the 120 that we started with, so evidently we
should have chosen edge EC to begin with.
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Which edge should we select next?
</div>
<p></p>
</blockquote>
<p>
Surely, we should select the next cheapest edge, CD, since any other path that
connects C to D will cost more than 25.
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Which edge comes next?  Why?
</div>
<p></p>
</blockquote>
<p>
There are actually two plausible answers here.  We could choose edge BE,
because it’s the cheapest edge <span class="emph">connected to our current tree</span> that
doesn’t create a cycle.  Or we could choose edge AB, because it’s the cheapest
edge <span class="emph">anywhere</span> that doesn’t create a cycle.  These two choices lead,
respectively, to Prim’s and Kruskal’s algorithms.
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
How many edges must there be in a spanning tree, in terms of the
total number <span style="font-style: italic">V</span> of vertices and <span style="font-style: italic">E</span> of edges in the overall graph?
Why?  Prove it.
</div>
<p></p>
</blockquote>
<p></p>
<div class="SIntrapara">
There is an interesting duality between the two algorithms.  To produce a
minimum spanning tree, there are three criteria we need to establish:
minimality, spanning-ness and tree-ness.  Both Prim’s algorithm and Kruskal’s
algorithm below run until their result is spanning.  But they choose different
importances for the other two considerations:
</div>
<div class="SIntrapara">
<ul>
<li>
<p>
 Prim’s algorithm essentially decides to build a single tree at all times,
and then works to be sure that it is minimal.  Every step makes some obvious
progress to the end goal, but the proof of correctness is a bit subtle.
</p>
</li>
<li>
<p>
 Kruskal’s algorithm guarantees minimality at all times, but builds many
trees that eventually link up into a single final answer.  This is somewhat
reminiscent of how heapsort had two invariants to preserve, and chose to
preserve one at all times and then fix up the other one.  Here we break the
"one tree" invariant, and restore it over time.
</p>
</li>
</ul>
</div>
<p></p>
<h5 class="heading">
32.2
<tt>
&nbsp;
</tt>
<a name="(part._.Prim_s_algorithm)"></a>Prim’s algorithm<span class="button-group"><a href="#(part._.Prim_s_algorithm)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h5>
<p>
Prim’s approach gows a single tree, starting from the globally cheapest edge,
until it produces a spanning tree.  At each stage, it chooses the cheapest edge
that makes the tree bigger without creating a cycle.  We obviously need to keep
track of the edges chosen for our tree.  But beyond that, Prim’s approach
implies that we need to keep track of
</p>
<ul>
<li>
<p>
The set of vertices we haven’t connected yet: since all the connected
vertices are part of a single tree, then we should only take edges that connect
to a new, not-yet-connected vertex.
</p>
</li>
<li>
<p>
The set of candidate edges available, sometimes called the
<span class="emph">frontier</span> (because it is the boundary between the known part of the graph
and the unknown)
</p>
</li>
<li>
<p>
An efficient way to choose the cheapest candidate edge
</p>
</li>
</ul>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
What data structure do we have that’s really efficient at adding
items and keeping track of the minimum (or maximum) item among them?
</div>
<p></p>
</blockquote>
<p>
Let’s keep track of the set of unconnected vertices by a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Boolean</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span>, that initially maps each vertex to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">false</span><span class="RktMeta"></span></span></span>, and as we connect
the vertex, we update the map to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">true</span><span class="RktMeta"></span></span></span> to indicate it’s now connected.
</p>
<p>
To keep track of our candidate edges, we’ll use a <span class="emph">priority queue</span>, this
time using a min-heap (as we used in the previous lecture).  As we connect each
vertex, we add its out edges to this priority queue, and then we’ll process
edges in order of removal from that min-heap, ensuring that we always choose
the cheapest edge available to us at any given point.
</p>
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
From the description above, try implementing Prim’s algorithm
yourself.
</div>
<p></p>
</blockquote>
<p>
As it turns out, we can generalize the argument made above: we don’t need to
start with the globally cheapest edge.  We can start from <span class="emph">any</span> vertex in
the graph, and follow the algorithm sketch above.
</p>
<p>
The following pseudocode is one possible implementation of Prim’s algorithm:
</p>
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjComment">// The final resulting tree
</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjComment">// The set of connected vertices
</span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Boolean</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connected</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Boolean</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjComment">// The priority queue of candidate edges
</span><span class="ProfjType">PriorityQueue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">frontier</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">PriorityQueue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">If</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">graph</span><span class="ProfjError">'s </span><span class="ProfjIdentifier">vertices</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">are</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">empty</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">just</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">empty</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">Initialize</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connected</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">map</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">map</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">each</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">false</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">Pick</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">some</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">initial</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">vertex</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">v</span><span class="ProfjDefault">.</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Set</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">its</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connectedness</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">true</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">and</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">add</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">all</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">its</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edges</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">frontier</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">While</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">frontier</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">is</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">not</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">empty</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Pick</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cheapest</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">frontier</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">suppose</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">it</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connects</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">If</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">is</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">already</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connected</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="ProfjKeyword">:</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Discard</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// it would create a cycle
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Else</span><span class="ProfjKeyword">:</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Add</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjConstant">XY</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Mark</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">as</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connected</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Add</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">all</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">out</span><span class="ProfjKeyword">-</span><span class="ProfjIdentifier">edges</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">of</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">frontier</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">Return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="RktMeta"></span>
  </td>
 </tr>
</tbody>
</table>
</blockquote>
</div>
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
Work through the code above, for the running example graph, and
determine what the resulting tree would be.
</div>
<p></p>
</blockquote>
<ol>
<li>
<p></p>
<div class="SIntrapara">
Let’s say we start from vertex A.  After the initialization step, we have
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      []
Connected: [A]
Frontier:  [AB(30), AE(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier, and since B is not yet
connected, we use this edge and add the out-edges of B to our frontier:
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30)]
Connected: [A, B]
Frontier:  [BA(30), BE(35), BC(40), AE(50), BF(50)]</pre>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
 <p></p>
 <div class="SIntrapara">
  <p class="Incercise">
   Do Now!
  </p>
 </div>
 <div class="SIntrapara">
  Why do we add BA to the frontier?
 </div>
 <p></p>
</blockquote>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier.  Since A is already
connected, we discard this edge.
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30)]
Connected: [A, B]
Frontier:  [BE(35), BC(40), AE(50), BF(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier, and since E is not yet
connected, we use this edge and add the out-edges of E to our frontier:
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35)]
Connected: [A, B, E]
Frontier:  [EC(15), EB(35), BC(40), AE(50), BF(50), EA(50)]</pre>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
 <p></p>
 <div class="SIntrapara">
  <p class="Incercise">
   Do Now!
  </p>
 </div>
 <div class="SIntrapara">
  Why do we add EA, when AE is already in the frontier?  Why add EB?
 </div>
 <p></p>
</blockquote>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier, and since C is not yet
connected, we use this edge and add the out-edges of B to our frontier:
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15)]
Connected: [A, B, E, C]
Frontier:  [CE(15), CD(25), BC(40), CB(40), AE(50), BF(50), EA(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier.  Since E is already
connected, we discard this edge.
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15)]
Connected: [A, B, E, C]
Frontier:  [CD(25), BC(40), CB(40), AE(50), BF(50), EA(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier, and since D is not yet
connected, we use this edge and add the out-edges of D to our frontier:
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15), CD(25)]
Connected: [A, B, E, C, D]
Frontier:  [DC(25), BC(40), CB(40), AE(50), BF(50), EA(50), DF(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier. Since C is already
connected, we discard this edge.
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15), CD(25)]
Connected: [A, B, E, C, D]
Frontier:  [BC(40), CB(40), AE(50), BF(50), EA(50), DF(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier. Since C is already
connected, we discard this edge.
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15), CD(25)]
Connected: [A, B, E, C, D]
Frontier:  [CB(40), AE(50), BF(50), EA(50), DF(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier. Since B is already
connected, we discard this edge.
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15), CD(25)]
Connected: [A, B, E, C, D]
Frontier:  [AE(50), BF(50), EA(50), DF(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier. Since E is already
connected, we discard this edge.
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15), CD(25)]
Connected: [A, B, E, C, D]
Frontier:  [BF(50), EA(50), DF(50)]</pre>
</div>
<p></p>
</li>
<li>
<p></p>
<div class="SIntrapara">
We select the cheapest edge from the frontier, and since F is not yet
connected, we use this edge and add the out-edges of F to our frontier:
</div>
<div class="SIntrapara">
<pre class="AsciiArt">Tree:      [AB(30), BE(35), EC(15), CD(25), DF(50)]
Connected: [A, B, E, C, D, F]
Frontier:  [BF(50), EA(50), DF(50), FB(50), FD(50)]</pre>
</div>
<p></p>
</li>
<li>
<p>
At this point we could stop, since we have connected all the vertices.  Or,
mechanically, we could work through the remaining edges of the frontier until
it empties out, at which point our algorithm terminates with the tree above.
</p>
</li>
</ol>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
At several points, we added edges to the frontier that had duplicate
edge weights.  Does it matter which of those edges we take to use in our
spanning tree (assuming they don’t create any cycles)?
</div>
<p></p>
</blockquote>
<p>
(Obviously the algorithm sketch above is pointlessly inefficient, since it
processes each edge twice.  At the cost of some slightly more tedious
bookkeeping, we could prevent that: we could choose to add an edge only if its
endpoint was not already connected, which would automatically avoid doubling
back on any edge.  But this isn’t strictly necessary for the overall
correctness of the algorithm.)
</p>
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
Prove that this algorithm actually works.  Use a variant of the
reasoning above (about why the globally minimum edge should be used) to
argue that whenever we connect a new vertex to the growing tree, we could not
possibly have produced a better path to get there, and therefore the tree is
indeed minimal so far.
</div>
<p></p>
</blockquote>
<blockquote class="ExerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Exercise">
Exercise
</p>
</div>
<div class="SIntrapara">
Produce a big-<span style="font-style: italic">O</span> worst-case runtime analysis for Prim’s algorithm.
</div>
<p></p>
</blockquote>
<h5 class="heading">
32.3
<tt>
&nbsp;
</tt>
<a name="(part._.Kruskal_s_algorithm)"></a>Kruskal’s algorithm<span class="button-group"><a href="#(part._.Kruskal_s_algorithm)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h5>
<p></p>
<div class="SIntrapara">
Prim’s algorithm above relied on a min-heap priority queue to constantly
shuffle new edges into the frontier and choose the best-available option
at each stage.  We might reasonably consider edges in another order: simply
sort them from cheapest to most expensive, and use them in increasing order if
at all possible.  But this loses the guarantee that we only have one tree
growing at any given time; we have a <span class="emph">forest</span> instead.  This implies that
we need to keep track of
</div>
<div class="SIntrapara">
<ul>
<li>
<p>
 Each of the trees being grown so far
</p>
</li>
<li>
<p>
 An efficient way to tell if both endpoints of an edge belong to the same
tree
</p>
</li>
</ul>
</div>
<p></p>
<p>
That second point is critical: we didn’t have to worry about that with Prim’s
algorithm because there was only ever one tree, so asking if both endpoints
were in the "same" tree amounted to asking if they were both in the <span class="emph">only</span>
tree, which could be handled by the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">connected</span><span class="RktMeta"></span></span></span> map.  Here, we need to
keep track of <span class="emph">which</span> tree, which means we’re going to need more than a
boolean.
</p>
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
Do Now!
</p>
</div>
<div class="SIntrapara">
Brainstorm some ideas for how to keep track of this information.
How can we tell apart two distinct trees?
</div>
<p></p>
</blockquote>
<p>
We could try to generalize the map a bit, mapping vertices to other
vertices somehow.  But to which ones?  And do we need to update many vertices
in the map, each time we join two trees via an edge?  This sounds potentially
horribly inefficient, but there is a very clever data structure that we can use
to make this work to our advantage.
</p>
<h5 class="heading">
32.3.1
<tt>
&nbsp;
</tt>
<a name="(part._.The_.Union_.Find_data_structure)"></a>The Union/Find data structure<span class="button-group"><a href="#(part._.The_.Union_.Find_data_structure)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h5>
<p>
The goal of the union/find data structure is to allow us to take a set of items
(such as nodes in a graph) and partition them into groups (such as nodes
connected by spanning trees) in such a way that we can easily <span class="emph">find</span>
whether two nodes are in the same group, and <span class="emph">union</span> two disjoint groups
together.  Intuitively, we accomplish this by <span class="emph">naming</span> each group by some
<span class="emph">representative element</span>, and then two items can be checked for whether
they are in the same group by checking if they have the same representative
element.
</p>
<h5 class="heading">
32.3.1.1
<tt>
&nbsp;
</tt>
<a name="(part._.Example)"></a>Example<span class="button-group"><a href="#(part._.Example)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h5>
<p>
Suppose each of our vertices was given a string name (as we’ve been labelling
the vertices so far).  Then
the union-find data structure is a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjPrimType">String</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">String</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> that maps
(the name of) each node to (the name of) a node that it is connected to.
Initially, every node name is mapped to itself, signifying that every node is
its own representative element, or equivalently, that it is not connected to
anything.
</p>
<p>
Recall the example from above:
</p>
<p>
<img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_37.png" alt="image" width="266.0" height="130.1328125">
Our <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="RktMeta"></span></span></span> will map every node name to itself:
</p>
<p></p>
<div class="SIntrapara">
<pre class="AsciiArt">                                     Representatives, visually:
        +---+---+---+---+---+---+    A     B     C     D     E     F
Node:   | A | B | C | D | E | F |
        +---+---+---+---+---+---+
Link:   | A | B | C | D | E | F |
        +---+---+---+---+---+---+


Spanning tree so far:</pre>
</div>
<div class="SIntrapara">
Kruskal’s algorithm begins by sorting the list of edges in the graph by edge
weight, from shortest to longest:
</div>
<p></p>
<p></p>
<div class="SIntrapara">
<pre class="AsciiArt">EC(15)
CD(25)
AB(30)
BE(35)
BC(40)
FD(50)
AE(50)
BF(50)</pre>
</div>
<div class="SIntrapara">
When we add edge <span class="stt">EC(15)</span>, nodes <span class="stt">E</span> and <span class="stt">C</span> are now connected:
</div>
<p></p>
<p></p>
<div class="SIntrapara">
<pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+     A     B     D     E     F
Node:   | A | B | C | D | E | F |                       ^
        +---+---+---+---+---+---+                       |
Link:   | A | B | E | D | E | F |                       C
        +---+---+---+---+---+---+

Spanning tree so far:          (C E)</pre>
</div>
<div class="SIntrapara">
We next add edge <span class="stt">CD(25)</span>.  Since <span class="stt">C</span>’s representative is <span class="stt">E</span>, and
<span class="stt">D</span>’s representative is <span class="stt">D</span>, they are currently separate, so adding this
edge would not create a cycle.  We can therefore <span class="emph">union</span> them and set
<span class="stt">D</span>’s representative’s representative to <span class="stt">C</span>’s representative:
</div>
<p></p>
<p></p>
<div class="SIntrapara">
<pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+     A     B     E     F
Node:   | A | B | C | D | E | F |                 ^
        +---+---+---+---+---+---+                / \
Link:   | A | B | E | E | E | F |               C   D
        +---+---+---+---+---+---+

Spanning tree so far:          (C D) (C E)</pre>
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
 Do Now!
</p>
</div>
<div class="SIntrapara">
Careful! Why must we union the representatives of two nodes, and not
the nodes themselves?
</div>
<p></p>
</blockquote>
</div>
<p></p>
<p>
Next we add edge <span class="stt">AB(30)</span>:
</p>
<p></p>
<div class="SIntrapara">
<pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+     A     E     F
Node:   | A | B | C | D | E | F |     ^     ^
        +---+---+---+---+---+---+     |    / \
Link:   | A | A | E | E | E | F |     B   C   D
        +---+---+---+---+---+---+

Spanning tree so far:          (A B) (C D) (C E)</pre>
</div>
<div class="SIntrapara">
We now have three connected components: Nodes <span class="stt">B</span> and <span class="stt">A</span> form one of
them, node <span class="stt">F</span> is a singleton, and nodes <span class="stt">C</span>, <span class="stt">D</span>, and <span class="stt">E</span> are in
the third component.
</div>
<p></p>
<p>
We add edge <span class="stt">BE(35)</span>. That means we add a link from the representative for
<span class="stt">B</span> (which is <span class="stt">A</span>) to the representative for node <span class="stt">E</span> (which is
<span class="stt">E</span>):
</p>
<p></p>
<div class="SIntrapara">
<pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+       E     F
Node:   | A | B | C | D | E | F |       ^
        +---+---+---+---+---+---+      /|\
Link:   | E | A | E | E | E | F |     A C D
        +---+---+---+---+---+---+     ^
                                      |
                                      B

Spanning tree so far:          (A B) (B E) (C D) (C E)</pre>
</div>
<div class="SIntrapara">
We still have two components.  When we try to add the edge <span class="stt">BC(40)</span> to the
graph, we notice that the representative for node <span class="stt">C</span> is the same as the
representative for the node <span class="stt">B</span>. Therefore adding this edge would create a
cycle, so we discard it.
</div>
<p></p>
<p>
Finally, we add the edge <span class="stt">FD(50)</span>: after this, every node has the same
representative, and therefore all nodes are connected:
</p>
<pre class="AsciiArt">                                      Representatives, visually:
        +---+---+---+---+---+---+       E
Node:   | A | B | C | D | E | F |       ^
        +---+---+---+---+---+---+      /|\
Link:   | E | A | E | E | E | D |     A C D
        +---+---+---+---+---+---+     ^   ^
                                      |   |
                                      B   F

Spanning tree so far:          (A B) (B E) (C D) (C E) (D F)</pre>
<h5 class="heading">
32.3.2
<tt>
&nbsp;
</tt>
<a name="(part._.Putting_the_union_find_data_structure_to_work)"></a>Putting the union/find data structure to work<span class="button-group"><a href="#(part._.Putting_the_union_find_data_structure_to_work)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span>
</h5>
<p>
The full Kruskal’s algorithm needs a union/find data structure to handle
efficiently connecting components, and also needs a list of the edges used by
the algorithm:
</p>
<div class="JavaHighlightBlock">
<blockquote class="SCodeFlow">
<table cellspacing="0" cellpadding="0" class="RktBlk">
<tbody>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">HashMap</span><span class="ProfjKeyword">&lt;</span><span class="ProfjPrimType">String</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">String</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">List</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edgesInTree</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">List</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Edge</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">all</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edges</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">in</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">graph</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">sorted</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">by</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">weights</span><span class="ProfjDefault">;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjError">&nbsp;</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjIdentifier">initialize</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">every</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">node</span><span class="ProfjError">'s </span><span class="ProfjIdentifier">representative</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">itself</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">While</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">there</span><span class="ProfjError">'s </span><span class="ProfjIdentifier">more</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">than</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">one</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">tree</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Pick</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cheapest</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">of</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">graph</span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">suppose</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">it</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">connects</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">and</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjDefault">.</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">If</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">equals</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">:</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">discard</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// they're already connected
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Else</span><span class="ProfjKeyword">:</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Record</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">in</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edgesInTree</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">union</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">          </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">X</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">,</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjWhiteSpace">          </span><span class="ProfjIdentifier">find</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">representatives</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Y</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span>
  </td>
 </tr>
 <tr>
  <td>
   <span class="RktMeta"></span><span class="ProfjType">Return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">the</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">edgesInTree</span><span class="RktMeta"></span>
  </td>
 </tr>
</tbody>
</table>
</blockquote>
</div>
<p>
To <span class="stt">find</span> a representative: if a node name maps to itself, then it is the
representative; otherwise, “follow the links” in the representatives map, and
recursively look up the representative for the current node’s parent.
</p>
<blockquote class="refpara">
<blockquote class="refcolumn">
<blockquote class="refcontent">
<p>
 There are additional heuristics for speeding this algorithm up in
practice, and they make for a <span class="emph">very</span> efficient algorithm. Unfortunately,
analyzing these heuristics is beyond the scope of this course, but you can look
up the “path-compression” heuristic if you are curious.
</p>
</blockquote>
</blockquote>
</blockquote>
<p></p>
<div class="SIntrapara">
To <span class="stt">union</span> two representatives, simply set the value of one representative’s
representative to the other.
</div>
<div class="SIntrapara">
<blockquote class="IncerciseBody">
<p></p>
<div class="SIntrapara">
<p class="Incercise">
 Do Now!
</p>
</div>
<div class="SIntrapara">
Again, why must we only ever union two
representatives, and not two arbitrary nodes?
</div>
<p></p>
</blockquote>
</div>
<p></p>
<div class="navsetbottom">
<span class="navleft">
<div class="nosearchform"></div>
&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="lecture31.html" title="backward to &quot;Lecture 31: Dijkstra's Algorithm for single-source shortest paths&quot;" data-pltdoc="x" rel="prev">← prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture33.html" title="forward to &quot;Lecture 33: Implementing Objects&quot;" data-pltdoc="x" rel="next">next →</a></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
