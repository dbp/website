<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="main.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript">
   (function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
  </script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="notes.html" class="tocviewselflink" data-pltdoc="x">Notes</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a>
        </td>
        <td></td>
        <td>
         <a href="notes.html" class="tocviewlink" data-pltdoc="x">Notes</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          1&nbsp;
         </td>
         <td>
          <a href="propositional.html" class="tocviewlink" data-pltdoc="x">Propositional Logic</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          2&nbsp;
         </td>
         <td>
          <a href="recipe.html" class="tocviewlink" data-pltdoc="x">Design/<span class="mywbr"> &nbsp;</span>Specification Recipe</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          3&nbsp;
         </td>
         <td>
          <a href="pbt_specification.html" class="tocviewlink" data-pltdoc="x">Property Based Testing</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          4&nbsp;
         </td>
         <td>
          <a href="smt.html" class="tocviewlink" data-pltdoc="x">Rosette 1:<span class="mywbr"> &nbsp;</span> SAT &amp; SMT</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          5&nbsp;
         </td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x">Beginning with Lean</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a>
        </td>
        <td>
         5&nbsp;
        </td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x">Beginning with Lean</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          5.1&nbsp;
         </td>
         <td>
          <a href="#%28part._.What_is_proof_%29" class="tocviewlink" data-pltdoc="x">What is proof?</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          5.2&nbsp;
         </td>
         <td>
          <a href="#%28part._.What_is_mechanized_proof_%29" class="tocviewlink" data-pltdoc="x">What is mechanized proof?</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          5.3&nbsp;
         </td>
         <td>
          <a href="#%28part._.How_are_proofs_constructed_%29" class="tocviewlink" data-pltdoc="x">How are proofs constructed?</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          5.4&nbsp;
         </td>
         <td>
          <a href="#%28part._.Moving_towards_.Lean%29" class="tocviewlink" data-pltdoc="x">Moving towards Lean</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          5.5&nbsp;
         </td>
         <td>
          <a href="#%28part._.Functions__logical_operators%29" class="tocviewlink" data-pltdoc="x">Functions, logical operators</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">5.1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.What_is_proof_%29" class="tocsubseclink" data-pltdoc="x">What is proof?</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">5.2
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.What_is_mechanized_proof_%29" class="tocsubseclink" data-pltdoc="x">What is mechanized proof?</a>
     </td>
    </tr>
    <tr>
     <td>
      <span class="tocsublinknumber">5.3
      <tt>
       &nbsp;
      </tt>
     </span>
     <a href="#%28part._.How_are_proofs_constructed_%29" class="tocsubseclink" data-pltdoc="x">How are proofs constructed?</a>
    </td>
   </tr>
   <tr>
    <td>
     <span class="tocsublinknumber">5.4
     <tt>
      &nbsp;
     </tt>
    </span>
    <a href="#%28part._.Moving_towards_.Lean%29" class="tocsubseclink" data-pltdoc="x">Moving towards Lean</a>
   </td>
  </tr>
  <tr>
   <td>
    <span class="tocsublinknumber">5.5
    <tt>
     &nbsp;
    </tt>
   </span>
   <a href="#%28part._.Functions__logical_operators%29" class="tocsubseclink" data-pltdoc="x">Functions, logical operators</a>
  </td>
 </tr>
 <tr>
  <td>
   <span class="tocsublinknumber">5.5.1
   <tt>
    &nbsp;
   </tt>
  </span>
  <a href="#%28part._.Tactics%29" class="tocsubseclink" data-pltdoc="x">Tactics</a>
 </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="maincolumn">
<div class="main">
<div class="versionbox">
<span class="version">8.6</span>
</div>
<div class="navsettop">
<span class="navleft">
<div class="nosearchform"></div>
&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="smt.html" title="backward to &quot;4 Rosette 1: SAT &amp; SMT&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="notes.html" title="up to &quot;Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next →</span></span>&nbsp;
</div>
<h4>
5
<tt>
&nbsp;
</tt>
<a name="(part._proof)"></a>Beginning with Lean
</h4>
<p>
At this point, we’ve learned quite a lot about writing specifications, and we’ve
learned two different techniques for using those specifications to increase the
trust that we have that code does the right thing. Property based testing (PBT)
relies upon writing down our specifications as boolean predicates and then
generating random inputs that we can run the specifications on. Provided that we
run enough, and cover enough of the possible input space, PBT is an incredibly
effective tool. SMT solvers, on the other hand, rely upon translating the
problem into the domain of satisfiability problems, which then allow us to leverage
decades of research into solving those problems to find counterexamples to our
specifications, if they exist.
</p>
<p>
Both of these have tradeoffs, as we have seen. PBT relies upon you exercising enough
of the input space, and knowing how to do that may be highly non-trivial. Indeed, if you
knew what the tricky edge cases of your problem all were, they may not be tricky edge cases!
Some of PBT’s success can be attributed to the fact that we just don’t test well at all,
and compared to a few, hand-chosen cases, PBT is a world better. But especially for high-assurance
uses, or security purposes, it may be slightly less applicable. For example, if the goal was to
show that for any input, the execution time of a particular piece of code was constant
(a very important property for security, to ward off timing attacks), you could certainly get
a lot of benefit out of randomly handing it input and ensuring that no timing differences were
detected, but if it turned out that only very carefully crafted inputs triggered some timing bug,
that random generation may never reach them.
</p>
<p>
SMT is in some sense better, but also, comes with more tradeoffs: encoding problems in terms of SMT
can be difficult if not impossible. Typically, problems have to be finitized, so again, only a portion
of the input space is considered.
</p>
<p>
The alternative is to turn to a full-fledged theorem prover, which will be the subject of the
rest of the semester. Our specifications will remain similar, but the way that we <span style="font-style: italic">use</span> them will
change radically: both the effort we need to put in, and the benefits we can yield in terms of assurance.
</p>
<h5>
5.1
<tt>
&nbsp;
</tt>
<a name="(part._.What_is_proof_)"></a>What is proof?
</h5>
<p>
To start, we need to be clear about what a proof is, and in particular, what
it means within the Lean Theorem Prover. First, what is a proof? A proof is an argument for some
statement, described so that someone else can follow, and in doing so be convinced of the statement. Proofs are thus,
historically, very social and contextual things: a step that the reader will be able to jump over can be left out,
for example. Related to proofs, and in some sense, simpler, are counter-examples: these are refutations of
statements by means of a concrete example. For example, the statement "all prime numbers are odd" can be refuted
by giving the counter-example 2, which is both a prime number and not odd. There is still context, of course:
what is a prime number, what is odd, etc: every bit of mathematics and logic builds upon some shared social
understanding of the meaning of certain things that people over centuries (or millenia) have found useful
in trying to understand the world.
</p>
<h5>
5.2
<tt>
&nbsp;
</tt>
<a name="(part._.What_is_mechanized_proof_)"></a>What is mechanized proof?
</h5>
<p>
Much more recently, but nearly as old as computers (1950s), people have been trying
to use computers to carry about, or assist in carrying out, proofs. The appeal is two-fold: first, if theorems are
intended to be a series of steps, each which follow according to some logical rule from the previous, computers are
quite good at following steps without forgetting ones in the middle. Humans are certainly more creative, but this
comes at a cost: we sometimes make leaps without explanation. Of course, sometimes those leaps are correct,
and some of the most creative, baffling mathematics arises from those kind of jumps (e.g., some of the number
theory of Ramanujan, whose results were divinely inspired, appearing to him in dreams). However, sometimes these leaps
are difficult to confirm, or end up turning out to be not true!
</p>
<p>
The other reason why computers seemed appealing, even from
the beginning, was the thought that if proof was merely the application of logical steps, one after another, perhaps
proof could be rendered mechanical, and people could focus on the "interesting" parts: developing new theories, adding
new rules, and posing new conjectures (to be automatically proved or disproved).
</p>
<p>
It turned out that the initial optimism was somewhat misplaced: while for limited theories, computers can come up with proofs,
for most interesting math, there are simply too many possible approaches, and there is no tractable procedure by which a proof
will be discovered. This lead to an alternative approach, and a new set of tools, proof assistants, of which Lean is one of
the more modern incarnations. In a proof assistant, a person is primarily responsible for constructing the proof, but each
step that they carry out is checked to be valid. Thus, while proofs cannot be discovered automatically (at least, not in general),
even quite rich proofs can be <span style="font-style: italic">checked</span> automatically, and that still turns out to be incredibly valuable, as it
eliminates a serious potential risk. Assuming one trusts the <span style="font-style: italic">proof checker</span> (which, we’ll talk about), one need not
trust the person who wrote the proof, only that the statement says what we want it to say. Given that proofs can often be
orders of magnitude more complicated than theorem statements, this is a huge benefit.
</p>
<h5>
5.3
<tt>
&nbsp;
</tt>
<a name="(part._.How_are_proofs_constructed_)"></a>How are proofs constructed?
</h5>
<p>
Proof assistants have been around for decades, and there have been many
approaches, nevermind many tools for each different approach. Lean comes out of the family of so-called LCF-style proof
assistants, which stands for "logic of computable functions". The basic idea is to take a strongly typed, high-level language, and
add an abstract type "theorem". Then, make the constructors of <span style="font-style: italic">theorem</span> be inference rules of the logical system.
</p>
<p>
For example, the following is an LCF-style presentation of a minimal propositional logic with <span style="font-style: italic">only</span> variables and implication (no <span class="texMathInline">\land</span>, <span class="texMathInline">\lor</span>, etc): (it relies upon having data types; here I’m using Haskell syntax for no particular reason)
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kr">data</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">|</span><span class="w"></span>
<span class="w">               </span><span class="kt">Imp</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="kt">Formula</span><span class="w"></span>
<span class="w">               </span><span class="kr">deriving</span><span class="w"> </span><span class="kt">Eq</span><span class="w"></span>

<span class="c1">-- if we add \bot, is complete!</span><span class="w"></span>
<span class="c1">-- https://en.wikipedia.org/wiki/Implicational_propositional_calculus</span><span class="w"></span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Provable</span><span class="w"> </span><span class="p">([</span><span class="kt">Formula</span><span class="p">],</span><span class="w"> </span><span class="kt">Formula</span><span class="p">)</span><span class="w"></span>

<span class="nf">assume</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"></span>
<span class="nf">assume</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Provable</span><span class="w"> </span><span class="p">([</span><span class="n">a</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>

<span class="nf">intro</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Formula</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"></span>
<span class="nf">intro</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="kt">Provable</span><span class="w"> </span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Provable</span><span class="w"> </span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>

<span class="nf">elim</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"></span>
<span class="nf">elim</span><span class="w"> </span><span class="p">(</span><span class="kt">Provable</span><span class="w"> </span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span><span class="w"> </span><span class="n">imp</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="kt">Provable</span><span class="w"> </span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">imp</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">  </span><span class="kt">Var</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"cannot use [elim] with (Var _) in first argument"</span><span class="w"></span>
<span class="w">  </span><span class="kt">Imp</span><span class="w"> </span><span class="kr">_</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">case</span><span class="w"> </span><span class="n">imp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">Imp</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">of</span><span class="w"></span>
<span class="w">    </span><span class="kt">True</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Provable</span><span class="w"> </span><span class="p">(</span><span class="n">gamma</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kt">False</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="ne">error</span><span class="w"> </span><span class="s">"antecedent of first argument must be the second argument"</span><span class="w"></span>

<span class="cm">{-</span>
<span class="cm">  a |- a</span>
<span class="cm"> -------------</span>
<span class="cm">  a |- b -&gt; a    b |- b</span>
<span class="cm">  ---------------------</span>
<span class="cm">    a,b |- a</span>
<span class="cm">-}</span><span class="w"></span>
<span class="nf">pf1</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"></span>
<span class="nf">pf1</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">elim</span><span class="w"> </span><span class="p">(</span><span class="n">intro</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">assume</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="n">assume</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"></span>
</pre>
</div>
</div>
<p>
This can barely do anything, and certainly not something we could use to
prove interesting theorems, but the ideas of LCF have influenced most modern
proof assistants, including Lean. In particular, there are two important ideas,
one that is visible above, the other that we could add. The first idea is that
we use the typechecking algorithm of a programming language to ensure that the
proofs we have are valid. Above, there are only three proof rules: <span class="default"><code class="highlight-inline"><span class="nf">assume</span><span class="w"></span></code></span>,
<span class="default"><code class="highlight-inline"><span class="nf">intro</span><span class="w"></span></code></span>, and <span class="default"><code class="highlight-inline"><span class="nf">elim</span><span class="w"></span></code></span>, but they embody <span style="font-style: italic">logically valid rules</span>,
and provided the only way to construct <span class="default"><code class="highlight-inline"><span class="kt">Theorem</span><span class="w"></span></code></span>s is via those rules, we will
never be able to construct an invalid theorem. This idea, that there is an abstract
type for theorems, is one of Milner’s original insights that went into LCF. The situation
in Lean is more complicated, but still, the type system ensures that proof rules are
applied in a way that cannot violate logical rules.
</p>
<p>
The second idea is that we can write
normal program procedures to manipulate proofs. These are usually called "tactics", and
can vastly decrease the effort that goes into proofs: indeed, there are even tactics that
carry out search procedures! Since the type system ensures validity, we can be flexible
in what our tactics do, as long as our tactics do not have access to the abstract
<span class="default"><code class="highlight-inline"><span class="kt">Theorem</span><span class="w"></span></code></span> data structure. For example, we could write an <span class="default"><code class="highlight-inline"><span class="nf">introMany</span><span class="w"></span></code></span> tactic
that took a list of variables and introduced them all:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="nf">introMany</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Theorem</span><span class="w"></span>
<span class="nf">introMany</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="n">thm</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">v</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">intro</span><span class="w"> </span><span class="p">(</span><span class="kt">Var</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">thm</span><span class="w"> </span><span class="n">vs</span><span class="w"></span>
</pre>
</div>
</div>
<p>
This tactic could be written by a user, and could not introduce logical inconsistency.
</p>
<h5>
5.4
<tt>
&nbsp;
</tt>
<a name="(part._.Moving_towards_.Lean)"></a>Moving towards Lean
</h5>
<p>
While the idea of having proof rules checked by a language type system and tactics
are both useful, in many ways Lean is a more direct descendent of a different system, AUTOMATH, which was
created in 1968 and developed concurrently with LCF. As its name indicated,
Automath was developed (by computer scientist N.G. de Bruijn) as way to formalize
mathematics. The main insight was to align theorem statements with the types of a language,
and terms with the proofs. A true theorem was then one for which a term with that type
existed. This idea (often called the Curry-Howard correspondance, though many others
realized similar ideas), seeing programs as proofs and types as theorems, turns out to be
an incredibly powerful one. Rather than carefully encoding a set of axioms within the typed
language (as in LCF-style provers), we instead use the entire language. This has a few
consequneces, one of which is that we need to be quite careful in the design of the language
to make sure we don’t introduce logical inconsistency!
</p>
<p>
First, let’s talk about how to represent <span style="font-style: italic">truth</span> and <span style="font-style: italic">falsehood</span> in
Lean. These will be our first encounter with <span style="font-style: italic">data definitions</span> in Lean, which are called
<span style="font-style: italic">inductive types</span>. They are an important enough part of the system that the theory that
underlies Lean is called the Calculus of Inductive Constructions. So what are true and false?
</p>
<p>
Well, it turns out there are <span style="font-style: italic">two</span> different versions, and the difference is very important.
First, we have the ordinary, boolean data definition that should be familiar from any number of
programming languages, though perhaps written in an unfamiliar notation.
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">inductive</span> <span class="n">Bool</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="sd">/-- The boolean value `false`, not to be confused with the proposition `False`. -/</span>
  <span class="bp">|</span> <span class="n">false</span> <span class="o">:</span> <span class="n">Bool</span>
  <span class="sd">/-- The boolean value `true`, not to be confused with the proposition `True`. -/</span>
  <span class="bp">|</span> <span class="n">true</span> <span class="o">:</span> <span class="n">Bool</span>
</pre>
</div>
</div>
<p>
Let’s read this, carefully. First, it says we are declaring a new <span class="default"><code class="highlight-inline"><span class="kd">inductive</span></code></span> type
called <span class="default"><code class="highlight-inline"><span class="n">Bool</span></code></span>. In Lean, everything has a type, including types, which is what the
<span class="default"><code class="highlight-inline"><span class="o">:</span> <span class="kt">Type</span></code></span> is saying: the type of <span class="default"><code class="highlight-inline"><span class="n">Bool</span></code></span> is <span class="default"><code class="highlight-inline"><span class="kt">Type</span></code></span>. This data definition has
two cases: <span class="default"><code class="highlight-inline"><span class="n">false</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">true</span></code></span>. Both <span style="font-style: italic">constructors</span> are declared to have type
<span class="default"><code class="highlight-inline"><span class="n">Bool</span></code></span>. This last fact may seem redundant: in such a simple case, indeed it is, but we can use
the same type definition form for much more interesting type definitions.
</p>
<p>
Aside from the syntax, this should be very familiar. And indeed, we have similar operations on
type <span class="default"><code class="highlight-inline"><span class="n">Bool</span></code></span>: and, or, not, if, etc. However, in Lean, we have a separate, much more important
definition of truth and falsehood that exists for a very important reason. As we mentioned
above, in theorem provers that subscribe to the types-as-theorems idea that originated in AUTOMATH,
we should not be able to prove false! One of the oldest statements from logic is <span style="font-style: italic">ex falso quodlibet</span>.
Translated as "from falsehood, anything follows", the idea is that if you have a proof of false, you
can prove any theorem. As a result, any logical system in which you can <span style="font-style: italic">prove</span> false would
not be very useful. That means if we use our type <span class="default"><code class="highlight-inline"><span class="n">Bool</span></code></span> as our definition of logical truth and
falsehood, we are in trouble, as we can easily "prove" false: we just use the constructor for <span class="default"><code class="highlight-inline"><span class="n">false</span></code></span>.
</p>
<p>
Why is this not an issue in PBT? Essentially, our only reasoning is based on
<span style="font-style: italic">evaluation</span> and <span style="font-style: italic">assertions</span> (often, of equalities). Our only theorems are individual test
cases, and their proofs are based on evaluation, which must terminate. We thus do not have the principle of
explosion (ex falso quodlibet), along with just about any other logical reasoning!
</p>
<p>
So how should we define logical truth and falsehood? Truth is the following:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">inductive</span> <span class="n">True</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="sd">/-- `True` is true, and `True.intro` (or more commonly, `trivial`)</span>
<span class="sd">  is the proof. -/</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">True</span>
</pre>
</div>
</div>
<p>
i.e., <span class="default"><code class="highlight-inline"><span class="n">True</span></code></span> is a inductive type that has type <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span> that has a single constructer, <span class="default"><code class="highlight-inline"><span class="n">intro</span></code></span>.
Why <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span> and not <span class="default"><code class="highlight-inline"><span class="kt">Type</span></code></span>? Lean distinguishes between types that are used for theorems, which have type
<span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span>, and types that are used for computation, which have type <span class="default"><code class="highlight-inline"><span class="kt">Type</span></code></span>. The actual situation is
actually a bit more complicated, as there is an entire hierarchy of types, that exist to avoid circularities
in the logic, but generally we’ll be able to avoid worrying about that.
</p>
<p>
Why is <span class="default"><code class="highlight-inline"><span class="n">True</span></code></span> a type that has a single constructor? Well, logical truth is essentially trivial: it
tells you nothing, on its own, and thus you can always construct a proof of it (you don’t need to know
anything).
</p>
<p>
So what is logical falsehood?
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">inductive</span> <span class="n">False</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre>
</div>
</div>
<p>
This type is much more baffling, at first. It is a type, that has type <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span>, but it has <span style="font-style: italic">no</span>
constructors. Why does in have no constructors? Because it is impossible to construct. This is exactly what
we want out of our logic, which is our programming language! Thus, we can formally write the statement
"from false follows anything", without worrying, since there should be no way of constructing a value of type
<span class="default"><code class="highlight-inline"><span class="n">False</span></code></span>. Note the importance of the distinction between the types (the theorems) and the terms (the proofs).
The type <span class="default"><code class="highlight-inline"><span class="n">False</span></code></span> can easily be written down, and indeed, it is a very important type! We will often want to
express that certain cases are impossible. How will we do that? We will write that if such cases occur,
<span class="default"><code class="highlight-inline"><span class="n">False</span></code></span> will result, and as a result, we need not do anything more in those cases (as they become trivial).
</p>
<h5>
5.5
<tt>
&nbsp;
</tt>
<a name="(part._.Functions__logical_operators)"></a>Functions, logical operators
</h5>
<p>
Now that we have a way to describe truth and falsehood, lets see how we define theorems,
logical operations, etc.  A function of type <span class="default"><code class="highlight-inline"><span class="n">a</span> <span class="bp">-&gt;</span> <span class="n">b</span></code></span> tells
us how to take some input of type <span class="default"><code class="highlight-inline"><span class="n">a</span></code></span> and produce output of type <span class="default"><code class="highlight-inline"><span class="n">b</span></code></span>.
Interpreted as a <span style="font-style: italic">theorem</span>, this is a proof that given <span class="default"><code class="highlight-inline"><span class="n">a</span></code></span> is true, so is
<span class="default"><code class="highlight-inline"><span class="n">b</span></code></span>. What is an example of that? How about, given propositions <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> and
<span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span>, we know <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">P</span></code></span>. We could write that, in Lean, as:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_1</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span> <span class="n">p.1</span>
</pre>
</div>
</div>
<p>
This relies upon the definition of logical and:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">structure</span> <span class="n">And</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="sd">/-- `And.intro : a → b → a ∧ b` is the constructor for the And operation. -/</span>
  <span class="n">intro</span> <span class="o">::</span>
  <span class="sd">/-- Extract the left conjunct from a conjunction. `h : a ∧ b` then</span>
<span class="sd">  `h.left`, also notated as `h.1`, is a proof of `a`. -/</span>
  <span class="n">left</span> <span class="o">:</span> <span class="n">a</span>
  <span class="sd">/-- Extract the right conjunct from a conjunction. `h : a ∧ b` then</span>
<span class="sd">  `h.right`, also notated as `h.2`, is a proof of `b`. -/</span>
  <span class="n">right</span> <span class="o">:</span> <span class="n">b</span>
</pre>
</div>
</div>
<p>
And a separate infix notation definition:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">infixr</span><span class="o">:</span><span class="mi">35</span> <span class="s2">" /</span><span class="se">\\</span><span class="s2"> "</span> <span class="bp">=&gt;</span> <span class="n">And</span>
</pre>
</div>
</div>
<p>
<span class="default"><code class="highlight-inline"><span class="n">And</span></code></span> is defined with <span class="default"><code class="highlight-inline"><span class="kd">structure</span></code></span>, which is a wrapper on top of <span class="default"><code class="highlight-inline"><span class="kd">inductive</span></code></span> that allows
you to give <span style="font-style: italic">names</span> to the fields; in this case, <span class="default"><code class="highlight-inline"><span class="n">left</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">right</span></code></span>. It is <span style="font-style: italic">shorthand</span>
for defining the inductive and defining the accessor functions.
</p>
<p>
What about the definition? That’s new, and there are a couple things going on here. First, the syntax of
making function definitions (or, any definitions). We write them as <span class="default"><code class="highlight-inline"><span class="kd">def</span> <span class="n">NAME</span> <span class="n">ARGS</span> <span class="o">:=</span> <span class="n">BODY</span></code></span>.
</p>
<p>
Here, there are three arguments:
the first two are the types <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span>, and the type annotation (written <span class="default"><code class="highlight-inline"><span class="o">:</span> <span class="n">TYPE</span></code></span>)
indicate that both of those have type <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span>. As we saw before, <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span> is the type of logical statements,
or propositions. Theorems will have <span style="font-style: italic">type</span> <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span> – indeed, in a dependent language like Lean,
everything has a type! Types have types, and the types of types themselves have types.
</p>
<p>
The final argument is <span class="default"><code class="highlight-inline"><span class="n">p</span></code></span>, and it has type <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span></code></span>, i.e., it is a <span style="font-style: italic">conjunction</span> of two
propositions. That is its <span style="font-style: italic">type</span>: the term is simply a pair, and so we can use projections (<span class="default"><code class="highlight-inline"><span class="bp">.</span><span class="mi">1</span></code></span>) and
<span class="default"><code class="highlight-inline"><span class="bp">.</span><span class="mi">2</span></code></span>) to extract out fields from the pair; in this case, the first field is the proposition of type <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span>.
</p>
<p>
So what this <span style="font-style: italic">program</span> does is, given a <span style="font-style: italic">proof</span> of a conjunction (a term of type <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span></code></span>), returns
a proof of <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> (a term of that type).
</p>
<p>
Written in this style, both the theorem (the <span style="font-style: italic">type</span>) and the proof (the <span style="font-style: italic">term</span>) are somewhat mixed together.
</p>
<p>
Now, we could <span style="font-style: italic">also</span> have written a function that took a pair of booleans and returned the first one:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">band_1</span> <span class="o">(</span><span class="n">pr</span> <span class="o">:</span> <span class="n">Bool</span> <span class="bp">×</span> <span class="n">Bool</span><span class="o">)</span> <span class="o">:=</span>  <span class="n">pr.1</span>
</pre>
</div>
</div>
<p>
Note a few differences: first, rather than having a conjunction of two arbitrary logical statements (a pair of two
<span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span>s), we have a pair of <span class="default"><code class="highlight-inline"><span class="n">Bool</span></code></span>s.
</p>
<p>
We can write this in a slightly more separate manner, here writing the theorem
<span class="texMathInline">\forall \,P\, Q. P \land Q \rightarrow Q</span>:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_2</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.2</span>
</pre>
</div>
</div>
<p>
First, we give a <span style="font-style: italic">name</span> to our theorem, <span class="default"><code class="highlight-inline"><span class="n">and_2</span></code></span>. This name
is then given a type, which is the Theorem statement: <span class="default"><code class="highlight-inline"><span class="k">forall</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span></code></span>. Finally, we have the term, which is the proof; it takes in a
pair, and projects out the second component.
</p>
<p>
Now, note that our term doesn’t take the <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> or
<span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span> as arguments. That is because we’ve indicated, with the curly
brackets, that these arguments should be able to be <span style="font-style: italic">inferred</span> from the
rest of the arguments. In particular, if we are given a pair of type
<span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span></code></span>, Lean can figure out what <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> and
<span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span> are. We could have equally written the definition as:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_2'</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">x</span> <span class="bp">=&gt;</span> <span class="n">x.2</span>
</pre>
</div>
</div>
<p>
Though if we do that, Lean will warn us that the <span style="font-style: italic">term</span> parameters <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span>
and <span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span> are unused, which is a good indication that they might
be able to be inferred. This is also an example (one of many) of features that exist
in Lean to make it <span style="font-style: italic">easier</span> to write proofs. Indeed, you can see this going back
all the way to the original idea in LCF to allow programming of tactics to make it
easier to build proofs.
</p>
<h5>
5.5.1
<tt>
&nbsp;
</tt>
<a name="(part._.Tactics)"></a>Tactics
</h5>
<p>
Speaking of tactics, writing proofs as <span style="font-style: italic">explicit</span> terms is something that we
will actually do quite rarely. It turns out, rather than constructing the terms
directly, which for complicated proofs, might be rather involved, we can instead
invoke higher-level tactics that will construct a term for us. We can switch
into "tactic mode" at any point using the keyword <span class="default"><code class="highlight-inline"><span class="kd">by</span></code></span>. On their
own, tactics may not be that helpful, as they allow you to leave out details apparent
in the terms, but Lean is an <span style="font-style: italic">interactive</span> theorem prover, and the tactics
combine with the interactive feedback to provide a really nice environment for
constructing proofs. Let’s see a simple example, still proving the same theorem:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_2''</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">P</span>  <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">_</span>
     <span class="n">cases</span> <span class="o">‹</span><span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span><span class="o">›</span>
     <span class="n">exact</span> <span class="o">‹</span><span class="n">Q</span><span class="o">›</span>
</pre>
</div>
</div>
<p>
Here, we use three tactics. The first, <span class="default"><code class="highlight-inline"><span class="n">intros</span></code></span>, takes
identifiers from the <span style="font-style: italic">goal</span> and moves them into the <span style="font-style: italic">premise</span> of the
proof. This corresponds, in the underlying term, to a function with identifiers. Here
we give explicit names to the propositions <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> and
<span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span>, but giving no name to the conjunction, indicated by an
underscore. We then do case analysis on one of my hypotheses: which one? The one we
didn’t give a name to, and so we refer to it by its type, which Lean allows
me to do using "french quotes" (typed as \f&lt; and \f&gt;): provided there is only one
hypothesis with that type, this is not ambiguous, and it can be easier to read. Case
analysis on a pair will then give me hypotheses for the two conjuncts, and so we can
complete the proof by saying we want the one with type <span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span>.
</p>
<p>
There are many other ways we could write this. First, we could use the tactic
<span class="default"><code class="highlight-inline"><span class="n">assumption</span></code></span> to complete the proof: it looks for a hypothesis
that matches the goal.
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_2''</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">P</span>  <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">_</span>
     <span class="n">cases</span> <span class="o">‹</span><span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span><span class="o">›</span>
     <span class="n">assumption</span>
</pre>
</div>
</div>
<p>
We also could have given an explicit name to the conjunction, and referred to that
with <span class="default"><code class="highlight-inline"><span class="n">cases</span></code></span>:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_2''</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">P</span>  <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">pq</span>
     <span class="n">cases</span> <span class="n">pq</span>
     <span class="n">assumption</span>
</pre>
</div>
</div>
<p>
We can also be more precise with my case analysis. Conjunctions are created with
<span class="default"><code class="highlight-inline"><span class="n">And.intro</span></code></span>, which has two fields, so we can pattern match to get:
</p>
<div class="default">
<div class="highlight">
<pre><span></span><span class="kd">def</span> <span class="n">and_2''</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">P</span>  <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="n">P</span> <span class="bp">/\</span> <span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">Q</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">P</span> <span class="n">Q</span> <span class="n">pq</span>
     <span class="n">cases</span> <span class="n">pq</span> <span class="k">with</span> <span class="bp">|</span> <span class="n">intro</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">exact</span> <span class="n">b</span>
</pre>
</div>
</div>
<div class="navsetbottom">
<span class="navleft">
<div class="nosearchform"></div>
&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="smt.html" title="backward to &quot;4 Rosette 1: SAT &amp; SMT&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="notes.html" title="up to &quot;Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next →</span></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
