<!DOCTYPE html>
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="main.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a>
        </td>
        <td></td>
        <td>
         <a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr>all, Intro to PBT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span> Proof Practice</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Trees</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a>
        </td>
        <td></td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          1&nbsp;
         </td>
         <td>
          <a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          2&nbsp;
         </td>
         <td>
          <a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">2
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a>
     </td>
    </tr>
   </tbody>
  </table>
 </div>
</div>
<div class="maincolumn">
 <div class="main">
  <div class="versionbox">
   <span class="version">8.7</span>
  </div>
  <div class="navsettop">
   <span class="navleft">
   <div class="nosearchform"></div>
   &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
  </span>
  <span class="navright">&nbsp;&nbsp;<a href="l21.html" title="backward to &quot;Lecture 21: Proof Practice&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l23.html" title="forward to &quot;Lecture 23: Trees&quot;" data-pltdoc="x">next →</a></span>&nbsp;
 </div>
 <h4>
  <a name="(part._l22)"></a>Lecture 22: Generalizing hypotheses
 </h4>
 <h5>
  1
  <tt>
   &nbsp;
  </tt>
  <a name="(part._.Purpose)"></a>Purpose
 </h5>
 <p>
  Explore how to construct proofs when the induction hypotheses are too weak.
 </p>
 <h5>
  2
  <tt>
   &nbsp;
  </tt>
  <a name="(part._.Outline)"></a>Outline
 </h5>
 <p>
  In HW2, we defined a compiler from <span class="RktSym">AddExpressions</span><span class="RktMeta"></span> to a stack
of <span class="RktSym">Instr</span><span class="RktMeta"></span>s: i.e., a simple stack-based calculator. We wrote a specification for compiler correctness, and tested that using PBT. Today, we’ll
recreate that same example in Lean, and this time, rather than testing the correctness on some randomly generated examples, we’ll <span style="font-style: italic">prove</span> it correct.
 </p>
 <p>
  Here, we define an inductive type for <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span>, and a function
to evaluate them. I’m showing a naming convenience that Lean has here,
where if you have a value <span class="default"><code class="highlight-inline"><span class="n">v</span></code></span> of type <span class="default"><code class="highlight-inline"><span class="n">foo</span></code></span>, if you write
<span class="default"><code class="highlight-inline"><span class="n">v.bar</span></code></span>, Lean will look for a function called <span class="default"><code class="highlight-inline"><span class="n">foo.bar</span></code></span> and
call it on <span class="default"><code class="highlight-inline"><span class="n">v</span></code></span>. i.e., <span class="default"><code class="highlight-inline"><span class="n">v.bar</span></code></span> is shorthand for
<span class="default"><code class="highlight-inline"><span class="n">foo.bar</span> <span class="n">v</span></code></span>. That means that by writing <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span></code></span>, we
can write <span class="default"><code class="highlight-inline"><span class="n">e_1.eval</span></code></span> to mean <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span> <span class="n">e_1</span></code></span>. Also,
in the <span style="font-style: italic">definition</span> of <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span></code></span>, we can write
pattern matching cases <span style="font-style: italic">without</span> the <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span> prefix that
would normally be needed.
 </p>
 <p>
  I’ve also used subscripts – you can write them by typing <span class="RktSym">\_1</span><span class="RktMeta"></span>.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">inductive</span> <span class="n">ArithExpr</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">(</span><span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">ArithExpr.eval</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="bp">=&gt;</span> <span class="n">e₁.eval</span> <span class="bp">+</span> <span class="n">e₂.eval</span>
</pre>
  </div>
 </div>
 <p>
  Now, we need to implement our stack calculator, and translation (or compiler) to it.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">inductive</span> <span class="n">Instr</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">push</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span>
<span class="kd">def</span> <span class="n">Instr.eval</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Instr</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">push</span> <span class="n">n</span> <span class="o">::</span> <span class="n">is</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Instr.eval</span> <span class="n">is</span> <span class="o">(</span><span class="n">n</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">::</span> <span class="n">is</span><span class="o">,</span> <span class="n">n1</span> <span class="o">::</span> <span class="n">n2</span> <span class="o">::</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Instr.eval</span> <span class="n">is</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">::</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
</pre>
  </div>
 </div>
 <p>
  As before, we define <span class="default"><code class="highlight-inline"><span class="n">instr</span></code></span> as either <span class="default"><code class="highlight-inline"><span class="n">push</span> <span class="n">n</span></code></span> or
<span class="default"><code class="highlight-inline"><span class="n">add</span></code></span>, and define an evaluation function for instructions. This time, pattern matching made it easier to define, so we didn’t bother to separate out into a separate function on single instructions and one on sequences.
 </p>
 <p>
  Now finally, we define our compile function:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">def</span> <span class="n">ArithExpr.compile</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Instr</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">Instr.push</span> <span class="n">n</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="bp">=&gt;</span> <span class="n">e₁.compile</span> <span class="bp">++</span> <span class="n">e₂.compile</span> <span class="bp">++</span> <span class="o">[</span><span class="n">Instr.add</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <p>
  Here I’ve chosen to use <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span> as the <span style="font-style: italic">namespace</span> for
the function, as that is the <span style="font-style: italic">input</span> type, so I can write
<span class="default"><code class="highlight-inline"><span class="n">e_1.compile</span></code></span> to mean <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.compile</span> <span class="n">e_1</span></code></span>.
 </p>
 <p>
  Now, we can prove that the compiler is correct. First, we write the
statement of compiler correctness, leaving the proof blank:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">compile_correct1</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</pre>
  </div>
 </div>
 <p>
  This says exactly what we want: if we compile an expression, and then
run it, we end up with a stack that has a single element: the number we would get if we had evaluated the expression.
Let’s see if we can prove it:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">compile_correct2</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">rfl</span> 
    <span class="n">case</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
      <span class="gr">sorry</span>
</pre>
  </div>
 </div>
 <p>
  We proceed by induction on the structure of our expressions, which makes sense, since they are inductive structures, and our compiler follows that structure.
 </p>
 <p>
  We can prove the base case by unfolding the definitions of
compile and both evaluations. In the other case, we can do the same
unfoldings, but then things go wrong. Let’s look carefully at where
we are stuck:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">e₁</span> <span class="n">e₂</span><span class="o">:</span> <span class="n">ArithExpr</span>
<span class="n">ih₁</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span><span class="o">]</span>
<span class="n">ih₂</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
<span class="bp">⊢</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₁</span> <span class="bp">++</span> <span class="n">ArithExpr.compile</span> <span class="n">e₂</span> <span class="bp">++</span>
  <span class="o">[</span><span class="n">Instr.add</span><span class="o">])</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <p>
  The last lines show what we need to prove: that evaluating the result
of compiling <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span>, appended to each other followed
by <span class="default"><code class="highlight-inline"><span class="n">Instr.add</span></code></span>, is the same as evaluating <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">e₂</span></code></span>
and adding them. Seems reasonable enough, but we are stuck. The
problem is that our inductive hypotheses can’t help us: they are
the only thing we know about <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">e₂</span></code></span>, but directly we
can’t use them, since they say what happens when we evaluate <span style="font-style: italic">just</span> the compiled <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> or <span class="default"><code class="highlight-inline"><span class="n">e₂</span></code></span>, not when we evaluate the larger program that we have.
 </p>
 <p>
  When using an interactive theorem prover, it can be tempting to just
move forward, doing whatever seems like it might work. While for
simple proofs this may work, it is often a bad idea in general. Instead,
whenever you aren’t sure what the next step should be, stop and
think about why you are stuck, and why you think the theorem is true
(or not true) – use <span style="font-style: italic">that</span> to move forward.
 </p>
 <p>
  Here, one of the problems is that
our obligation is about <span class="default"><code class="highlight-inline"><span class="n">Instr.eval</span></code></span>ing a bunch of things in
sequence, but our hypotheses are only about parts of that. We would
like to use the induction hypotheses to "step through" the evaluation.
 </p>
 <p>
  Let’s define an auxiliary theorem to help us do exactly that:
 </p>
 <blockquote class="refpara">
  <blockquote class="refcolumn">
   <blockquote class="refcontent">
    <p>
     Note: to go back and define such a helper theorem, we’ll often use the "pause" button in the Lean Infoview, so we can define the theorem while still having access to the state of the proof when we got stuck (as often we’ll be copying parts of it to make the theorem statement). Once we’ve defined the theorem, we can go back to where we got stuck and resume.
    </p>
   </blockquote>
  </blockquote>
 </blockquote>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">instr_eval_app1</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">is</span> <span class="n">is'</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Instr</span><span class="o">),</span>
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">is</span> <span class="bp">++</span> <span class="n">is'</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> 
      <span class="n">Instr.eval</span> <span class="n">is'</span> <span class="o">(</span><span class="n">Instr.eval</span> <span class="n">is</span> <span class="o">[])</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</pre>
  </div>
 </div>
 <p>
  Now, at this point, we have two possibilities. We can either stop and
prove this new theorem, or we can <span style="font-style: italic">assume</span> that it is true, and
then use it to prove our original theorem, and then come back and prove
the auxiliary later, once you know its useful.
 </p>
 <p>
  Which you do depends both
on your style, but also how much you trust the auxiliary theorem to be
true! If you do a bunch of work on the main theorem and then find out
the auxiliary theorem is false, you’ve wasted a lot of time. On the other hand, if you do a bunch of work proving a helper theorem and it
turns out not to be what you need, you’ve also wasted time!
 </p>
 <p>
  Here, we’re pretty sure that the helper theorem is true, so we’ll come back to
prove it later. Let’s see if it’ll help us prove our theorem.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">compile_correct3</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app1</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app1</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih₁</span><span class="o">]</span>
      <span class="gr">sorry</span>
</pre>
  </div>
 </div>
 <p>
  This seemed to help, but we’re still stuck. Let’s look at what we have:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">e</span> <span class="n">e₂</span><span class="o">:</span> <span class="n">ArithExpr</span>
<span class="n">ih₁</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span><span class="o">]</span>
<span class="n">ih₂</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
<span class="bp">⊢</span> <span class="n">Instr.eval</span> <span class="o">[</span><span class="n">instr.add</span><span class="o">]</span>
  <span class="o">(</span><span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₂</span><span class="o">)</span>
    <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span><span class="o">])</span> <span class="bp">=</span>
  <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <p>
  So, first we were able to use our lemma to turn our single
<span class="default"><code class="highlight-inline"><span class="n">Instr.eval</span></code></span> into a sequence of nested <span class="default"><code class="highlight-inline"><span class="n">Instr.eval</span></code></span>s. And
the innermost one we can use our induction hypothesis on. But now we
are stuck, because we want to use our other induction hypothesis (<span class="default"><code class="highlight-inline"><span class="n">ih₂</span></code></span>), but
it doesn’t apply, as it tells us how <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.compile</span> <span class="n">e₂</span></code></span> runs
in an <span style="font-style: italic">empty</span> stack, not in a stack with <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span> <span class="n">e₁</span></code></span> on it!
 </p>
 <p>
  This is a case where our induction hypotheses are <span style="font-style: italic">not strong
enough</span>, and indeed, our entire theorem is not strong enough to be
proved. This may seem like a strange claim, that we need to make the
theorem more general in order to prove it, but when proving via
induction, the theorem you are proving is also how the induction
hypotheses are constructed, so if you need stronger induction
hypotheses, it may mean you need a more general theorem. Then if we
can prove this, we can define the original theorem as a corollary.
 </p>
 <p>
  Let’s define a new theorem. Note that we also have to generalize our
helper lemma, or else it will not apply!
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">instr_eval_app2</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">is</span> <span class="n">is'</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Instr</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span><span class="o">),</span>
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">is</span> <span class="bp">++</span> <span class="n">is'</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> 
      <span class="n">Instr.eval</span> <span class="n">is'</span> <span class="o">(</span><span class="n">Instr.eval</span> <span class="n">is</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">compile_correct_helper</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span><span class="o">),</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">(</span><span class="n">e.eval</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="bp">=&gt;</span> 
      <span class="n">intro</span> <span class="n">s</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app2</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app2</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih₁</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih₂</span><span class="o">]</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Instr.eval</span><span class="o">]</span>
      <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">compile_correct</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">),</span>
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span> 
    <span class="k">fun</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">compile_correct_helper</span> <span class="n">e</span> <span class="o">[]</span>
</pre>
  </div>
 </div>
 <p>
  Now, we almost have the result: the only issue is that the order
of our operands is backwards. Now, we could finish this proof by
appealing to the commutativity of addition, but before doing that,
its worth wondering <span style="font-style: italic">why</span> this happened. If we do that,
we realize that our definition of compile is wrong! Since we are
pushing onto a stack, we should be compiling the second operand first,
then the first. Or, perhaps the <span class="default"><code class="highlight-inline"><span class="n">Instr.add</span></code></span> instruction should
swap when it computes. Once we fix that, the proof goes through.
 </p>
 <div class="navsetbottom">
  <span class="navleft">
  <div class="nosearchform"></div>
  &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
 </span>
 <span class="navright">&nbsp;&nbsp;<a href="l21.html" title="backward to &quot;Lecture 21: Proof Practice&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l23.html" title="forward to &quot;Lecture 23: Trees&quot;" data-pltdoc="x">next →</a></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
