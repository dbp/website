<!DOCTYPE html>
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="main.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a>
        </td>
        <td></td>
        <td>
         <a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr>all, Intro to PBT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span> Proof Practice</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l22.html" class="tocviewlink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Trees</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a>
        </td>
        <td></td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          1&nbsp;
         </td>
         <td>
          <a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          2&nbsp;
         </td>
         <td>
          <a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">2
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a>
     </td>
    </tr>
   </tbody>
  </table>
 </div>
</div>
<div class="maincolumn">
 <div class="main">
  <div class="versionbox">
   <span class="version">8.7</span>
  </div>
  <div class="navsettop">
   <span class="navleft">
   <div class="nosearchform"></div>
   &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
  </span>
  <span class="navright">&nbsp;&nbsp;<a href="l19.html" title="backward to &quot;Lecture 19: Inductive types &amp; proofs&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l21.html" title="forward to &quot;Lecture 21: Proof Practice&quot;" data-pltdoc="x">next →</a></span>&nbsp;
 </div>
 <h4>
  <a name="(part._l20)"></a>Lecture 20: Lists
 </h4>
 <h5>
  1
  <tt>
   &nbsp;
  </tt>
  <a name="(part._.Purpose)"></a>Purpose
 </h5>
 <p>
  Practice proofs with lists.
 </p>
 <h5>
  2
  <tt>
   &nbsp;
  </tt>
  <a name="(part._.Outline)"></a>Outline
 </h5>
 <p>
  Today, we’ll do a few proofs about lists. This is practice that should
be useful for the homework, and should help you get more familiar
with the interactive proof environment. While the theorems we will
prove today and tomorrow are not particularly interesting, they should
be good exercises.
 </p>
 <p>
  As a warm up, we’ll look at a proof we did last time, but framed slightly differently: this time using the overloaded infix <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span> append syntax, rather than the actual <span class="default"><code class="highlight-inline"><span class="n">List.append</span></code></span> function.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">list_app_r_nil</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">T</span><span class="o">),</span> <span class="n">l</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">T</span> <span class="n">l</span>
     <span class="n">induction</span> <span class="n">l</span>
     <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
     <span class="n">case</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span> <span class="n">ih</span> <span class="bp">=&gt;</span> 
       <span class="c1">-- simp only [HAppend.hAppend, Append.append, List.append]</span>
       <span class="k">have</span> <span class="n">h1</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">h</span> <span class="o">::</span> <span class="o">(</span><span class="n">t</span> <span class="bp">++</span> <span class="o">[])</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">rfl</span>
       <span class="n">rw</span> <span class="o">[</span><span class="n">h1</span><span class="o">]</span>
       <span class="n">rw</span> <span class="o">[</span><span class="n">ih</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <p>
  Note that the <span class="default"><code class="highlight-inline"><span class="n">nil</span></code></span> case proceeds as before, but the <span class="default"><code class="highlight-inline"><span class="n">cons</span></code></span> case doesn’t: in particular, while it might look like we could immediately <span class="default"><code class="highlight-inline"><span class="n">rw</span></code></span> with our induction hypothesis, this is actually a misleading consequence of the binding precedence of <span class="default"><code class="highlight-inline"><span class="o">::</span></code></span> vs <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span>: since <span class="default"><code class="highlight-inline"><span class="o">::</span></code></span> binds <span style="font-style: italic">tighter</span> than <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span>, what we have is equivalent to <span class="default"><code class="highlight-inline"><span class="o">(</span><span class="n">h</span><span class="o">::</span><span class="n">t</span><span class="o">)</span> <span class="bp">++</span> <span class="o">[]</span></code></span>, which means that our induction hypothesis, which is an equality about <span class="default"><code class="highlight-inline"><span class="n">t</span> <span class="bp">++</span> <span class="o">[]</span></code></span>, does not directly apply. This was true in our previous proof too, though it was more obvious, since without the infix operator <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span>, we could see the precedence more clearly.
 </p>
 <p>
  But there’s more: if we try to do <span class="default"><code class="highlight-inline"><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">List.append</span><span class="o">]</span></code></span>, as we did before, nothing would change. This is because <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span> is not syntax for <span class="default"><code class="highlight-inline"><span class="n">List.append</span></code></span>, but instead, is a generic abstraction for appending, which in the particular case of Lists, will turn out to be <span class="default"><code class="highlight-inline"><span class="n">List.append</span></code></span>.
 </p>
 <p>
  We can make this go through by simplifying through the abstraction (shown commented out), but this is an opportunity to show a helpful tactic: <span class="default"><code class="highlight-inline"><span class="k">have</span></code></span>, which allows us to define an intermediate result and prove that, which we will then have as a lemma. We can use this to show that <span class="default"><code class="highlight-inline"><span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="bp">++</span> <span class="o">[]</span></code></span> is equal to <span class="default"><code class="highlight-inline"><span class="n">h</span> <span class="o">::</span> <span class="o">(</span><span class="n">t</span> <span class="bp">++</span> <span class="o">[])</span></code></span>, without having to know what the exact functions are, because <span class="default"><code class="highlight-inline"><span class="n">rfl</span></code></span> will run whicheven side evaluates to the other. Once we have that, we can rewrite using it, and at that point, our induction hypothesis is usable.
 </p>
 <p>
  While this is, in some sense, a lesson showing why we will usually use <span class="default"><code class="highlight-inline"><span class="n">List.append</span></code></span> instead of <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span>, this strategy of using <span class="default"><code class="highlight-inline"><span class="k">have</span></code></span> to make fine-grained changes is generally quite useful.
 </p>
 <p></p>
 <table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;">
  <tbody>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Use</span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Description</span>
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="k">have</span> <span class="n">H</span> <span class="o">:</span> <span class="n">T</span> <span class="o">:=</span> <span class="kd">by</span> <span class="n">tac</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      Introduces a new local theorem called <span class="default"><code class="highlight-inline"><span class="n">H</span></code></span>, whose statement is <span class="default"><code class="highlight-inline"><span class="n">T</span></code></span>, proved by the tactic (or series of tacics <span class="default"><code class="highlight-inline"><span class="n">tac</span></code></span>.
     </p>
    </td>
   </tr>
  </tbody>
 </table>
 <p></p>
 <p>
  To go over carefully how this works, its helpful to think a bit about how
append works. The actual definition of append is a tiny bit more
complicated, but we could define an equivalent function like this:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">my_append</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="p">}</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">A</span><span class="w"></span>
<span class="n">| [], l =&gt; l</span>
<span class="n">|</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="n">::</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="o">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">::</span><span class="w"> </span><span class="p">(</span><span class="n">my_append</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  This should be very familiar from Fundies 1: it is a recursive
function that treats its second argument as a simple input, adding
each element of the first as it recurs until it reaches the end of
the first list and returns the second list.
 </p>
 <p>
  Looking at this definition, it should be clear that doing
<span style="font-style: italic">induction</span> on the first list is the right way to prove this, as
the definition does <span style="font-style: italic">recursion</span> on this list. Induction and
recursion are two sides of the same coin, and in particular, the
definition requires that we know whether the first list is empty or
non-empty to unfold, which are exactly the cases we consider when
doing induction.
 </p>
 <p>
  In the empty case, we need to show that <span class="default"><code class="highlight-inline"><span class="o">[]</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[]</span></code></span>. This
follows by reducing the definition of <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span>. Another way of
saying this is that it follows by <span style="font-style: italic">definitional</span> equality,
as by merely unfolding the definition of <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span> we can see that
these are equal. This means we can use this using the tactic
<span class="default"><code class="highlight-inline"><span class="n">rfl</span></code></span>.
 </p>
 <p>
  In the non-empty case, we need to show that
<span class="default"><code class="highlight-inline"><span class="bp">⊢</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span></code></span>, where we know, as an inductive
hypothesis, that <span class="default"><code class="highlight-inline"><span class="n">t</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">t</span></code></span>. This looks like you could just
rewrite with the hypothesis and be done, but operator precedence is
a bit tricky here. The <span class="default"><code class="highlight-inline"><span class="o">::</span></code></span> binds tighter than <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span> (you
can right click on either and click "Go to Definition" – <span class="default"><code class="highlight-inline"><span class="o">::</span></code></span> has
precedence 67, whereas <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span> has precedence 65). That means that,
if we had explicit parenthesis, what we are trying to show is:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">ih</span><span class="o">:</span> <span class="n">t</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">t</span>
<span class="bp">⊢</span> <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span> <span class="bp">++</span> <span class="o">[]</span> <span class="bp">=</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span>
</pre>
  </div>
 </div>
 <p>
  However, we know from the definition of <span class="default"><code class="highlight-inline"><span class="bp">++</span></code></span> that if the first
argument is a non-empty list, this is equivalent to
<span class="default"><code class="highlight-inline"><span class="n">h</span> <span class="o">::</span> <span class="o">(</span><span class="n">t</span> <span class="bp">++</span> <span class="o">[])</span></code></span>, at which point we could rewrite using the
hypothesis. To make these steps explicit, and as a useful trick when
proving particular equivalences, we define this as an intermediate
helper with <span class="default"><code class="highlight-inline"><span class="k">have</span></code></span>. This holds by <span style="font-style: italic">definitional</span> equality
—<wbr> i.e., reduction —<wbr> which can be done by the tactic
<span class="default"><code class="highlight-inline"><span class="n">rfl</span></code></span>.
 </p>
 <p>
  Now that we have that lemma, we can rewrite using it, and that then
gets the goal in a form where rewriting with the induction hypothesis
is sufficient to complete the proof. Note that <span class="default"><code class="highlight-inline"><span class="n">rw</span></code></span>, like many
tactics, will check if the result is a trivial equality and complete
the proof with <span class="default"><code class="highlight-inline"><span class="n">refl</span></code></span> if so.
 </p>
 <p>
  Let’s now do the other direction:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">list_app_l_nil</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">A</span><span class="o">),</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span> 
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">l</span>
     <span class="n">rfl</span>
<span class="kd">theorem</span> <span class="n">list_app_l_nil'</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">List</span> <span class="n">A</span><span class="o">),</span> <span class="n">List.append</span> <span class="o">[]</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="o">:=</span> 
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">l</span>
     <span class="n">rfl</span>
</pre>
  </div>
 </div>
 <p>
  Here, the whole proof follows by <span style="font-style: italic">definitional</span> equality, and
so we don’t need induction at all! Why? Well, if we look back at the
definition of append, we see that we recur on the first argument,
which means that if it is empty, <span class="default"><code class="highlight-inline"><span class="o">[]</span> <span class="bp">++</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span></code></span> by the definition
of append!
 </p>
 <p>
  This asymmetry may seem odd at first, but if you think about the actual
program that we are proving facts around, the behavior is very
different based on which argument we are talking about! Indeed, the
program will never inspect the second argument at all.
 </p>
 <p>
  Let’s do one more exercise together, this time, it’ll be a proof about numbers:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">def</span> <span class="n">nat_sub</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">a</span><span class="o">,</span> <span class="n">Nat.zero</span>         <span class="bp">=&gt;</span> <span class="n">a</span>
  <span class="bp">|</span> <span class="n">Nat.zero</span><span class="o">,</span> <span class="n">_</span>  <span class="bp">=&gt;</span> <span class="n">Nat.zero</span>
  <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">a</span><span class="o">,</span> <span class="n">Nat.succ</span> <span class="n">b</span> <span class="bp">=&gt;</span> <span class="n">nat_sub</span> <span class="n">a</span> <span class="n">b</span>

<span class="kd">theorem</span> <span class="n">sub_pred</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> 
  <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span>
    <span class="n">induction</span> <span class="n">n</span>
    <span class="n">case</span> <span class="n">zero</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">m</span> <span class="bp">&lt;;&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Nat.pred</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">IH</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">m</span>
      <span class="n">case</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">,</span> <span class="n">Nat.pred</span><span class="o">]</span>
      <span class="n">case</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span><span class="bp">;</span> <span class="gr">sorry</span>
</pre>
  </div>
 </div>
 <p>
  Here, we define an alternate definition of subtraction on natural numbers. This alternate definition is actually the one that is used in HW7; it’s a bit simpler than the standard library one, which depends on an auxiliary "predecessor" function (that is iteratively applied). What we’ll prove here is a connection between that predecessor function and our new <span class="default"><code class="highlight-inline"><span class="n">nat_sub</span></code></span>: this would be a first step towards showing the two functions are equivalent (analogously to how in HW, you show two versions of addition equivalent).
 </p>
 <p>
  We try to prove it by induction on <span class="default"><code class="highlight-inline"><span class="n">n</span></code></span>. We can get through the zero case, though it takes a bit of work: <span class="default"><code class="highlight-inline"><span class="n">simp</span> <span class="n">only</span></code></span> doesn’t work on the second case, as it relies upon the argument that the function is structurally recursive on, which is the second one; however, Lean defines equations for patterns in a definition, and so we can also try <span class="default"><code class="highlight-inline"><span class="n">rw</span></code></span> using the function. Using <span class="default"><code class="highlight-inline"><span class="n">rw</span></code></span> on a function actually rewrites using one of the equations that defines the function: <span class="default"><code class="highlight-inline"><span class="n">nat_sub._eq_1</span></code></span>, <span class="default"><code class="highlight-inline"><span class="n">nat_sub._eq_2</span></code></span>, or <span class="default"><code class="highlight-inline"><span class="n">nat_sub._eq_3</span></code></span>. In order to do this, we actually have to know whethere <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span> is zero or not, but once we do this, we can complete the base case. But the inductive case really doesn’t work: we end up with
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">IH</span><span class="o">:</span> <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">)</span>
<span class="bp">⊢</span> <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="n">m</span>
</pre>
  </div>
 </div>
 <p>
  We can’t simplify using <span class="default"><code class="highlight-inline"><span class="n">nat_sub</span></code></span>, and we can try doing case analysis on <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span> again, and that works fine for the case when <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span> is zero, but in the successor case, we have a problem: neither side of our inductive hypothesis matches. When we simplify, we are left with:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">IH</span><span class="o">:</span> <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">))</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">))</span>
<span class="bp">⊢</span> <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">)</span>
</pre>
  </div>
 </div>
 <p>
  This looks close: the problem is that our inductive hypotheses is now about <span class="default"><code class="highlight-inline"><span class="n">Nat.succ</span> <span class="n">m</span></code></span> instead of <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span>. This makes sense: we did case analysis on <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span>, and we are in the successor case, so we broke apart our original <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span>. But this is unprovable.
 </p>
 <p>
  How do we solve this? Well, we actually have to go back to the beginning: if we don’t introduce <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span> until <span style="font-style: italic">after</span> doing induction, our inductive hypothesis will be for an arbitrary <span class="default"><code class="highlight-inline"><span class="n">m</span></code></span>, not the one that we have been doing case analysis on. Since we haven’t used <span class="default"><code class="highlight-inline"><span class="n">IH</span></code></span> yet, this won’t cause any of the other cases to change, but it will mean that at this point, we’ll have:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">IH</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">),</span> <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">)</span>
</pre>
  </div>
 </div>
 <p>
  Which is exactly what we need to complete the proof. This exercise was mostly intended to show that if you don’t need to introduce variables in order to do induction, it is better to wait until <span style="font-style: italic">after</span> induction to introduce them, as that will mean the induction hypothesis you get is stronger. Many times, it won’t matter, but sometimes it will, and introducing the variables after doing induction doesn’t cost you anything.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">sub_pred'</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> 
  <span class="n">Nat.pred</span> <span class="o">(</span><span class="n">nat_sub</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=</span> <span class="n">nat_sub</span> <span class="n">n</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">m</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">n</span>
    <span class="n">induction</span> <span class="n">n</span>
    <span class="n">case</span> <span class="n">zero</span> <span class="bp">=&gt;</span> 
      <span class="n">intros</span> <span class="n">m</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">m</span> <span class="bp">&lt;;&gt;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Nat.pred</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">IH</span> <span class="bp">=&gt;</span>
      <span class="n">intros</span> <span class="n">m</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">m</span>
      <span class="n">case</span> <span class="n">zero</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">,</span> <span class="n">Nat.pred</span><span class="o">]</span>
      <span class="n">case</span> <span class="n">succ</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">nat_sub</span><span class="o">]</span><span class="bp">;</span> <span class="n">rw</span> <span class="o">[</span><span class="n">IH</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <p>
  <span class="Larger">Practice</span>
 </p>
 <p>
  Now, let’s practice with some exercises about lists. First, we’ll prove a theorem about length:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">list_length_cons</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">A</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="n">List</span> <span class="n">A</span><span class="o">),</span> 
  <span class="o">(</span><span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">t.length</span> <span class="bp">+</span> <span class="mi">1</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">h</span> <span class="n">t</span>
    <span class="n">rfl</span>
</pre>
  </div>
 </div>
 <p>
  This, again, followed directly from defintional equality, since
<span class="default"><code class="highlight-inline"><span class="n">length</span></code></span> is defined essentially as follows:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">my_length</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="p">}</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">Nat</span><span class="w"></span>
<span class="n">| [] =&gt; 0</span>
<span class="n">|</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="n">::</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">my_length</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  Now, let’s prove a simple fact about natural numbers:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">theorem</span><span class="w"> </span><span class="n">nat_zero_add</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">n</span><span class="o">,</span><span class="w"> </span><span class="n">Nat.add</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">:=</span><span class="w"></span>
<span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">intros</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">    </span><span class="n">induction</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">rfl</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">IH</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span>
<span class="w">      </span><span class="n">simp</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="p">[</span><span class="n">Nat.add</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="n">rw</span><span class="w"> </span><span class="p">[</span><span class="n">IH</span><span class="p">]</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  This is a straightforward proof by induction: in the base case, it is trivial (by <span class="default"><code class="highlight-inline"><span class="n">rfl</span></code></span>); in the recursive case, we simplify and use the induction hypothesis.
 </p>
 <p>
  Let’s prove another fact, this one about successor:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">theorem</span><span class="w"> </span><span class="n">nat_succ_add</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Nat</span><span class="p">)</span><span class="o">,</span><span class="w"> </span>
<span class="w">  </span><span class="n">Nat.add</span><span class="w"> </span><span class="p">(</span><span class="n">Nat.succ</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">Nat.succ</span><span class="w"> </span><span class="p">(</span><span class="n">Nat.add</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="n">:=</span><span class="w"></span>
<span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">intros</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">    </span><span class="n">revert</span><span class="w"> </span><span class="n">n</span><span class="w"></span>
<span class="w">    </span><span class="n">induction</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="nb">&lt;</span><span class="c1">;&gt; intros n</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">rfl</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">succ</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">IH</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="p">[</span><span class="n">Nat.add</span><span class="p">]</span><span class="w"></span>
<span class="w">                      </span><span class="n">rw</span><span class="w"> </span><span class="p">[</span><span class="n">IH</span><span class="p">]</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  This was interesting, as we had two arguments, and we
had to decide which to do induction on! In general, if
you are proving a fact about a recursive function, you will want to do induction on the argument that the function is structurally recursive on. In this case, that was the <span style="font-style: italic">second</span> argument. Once we figure that out, the proof ends up being as simple as the previous one.
 </p>
 <p>
  Note that in this proof we followed our strategy of always leaving other variables in the goal when we do induction, but since we were inducting on the <span style="font-style: italic">second</span> argument, we had to first introduce both, and then move the first argument back to the goal, which we can do with <span class="default"><code class="highlight-inline"><span class="n">revert</span></code></span>. In this proof, it wasn’t actually necessary, but in some, it may be, and it’s a good habit to get into: always introduce the rest of the variables <span style="font-style: italic">after</span> doing induction.
 </p>
 <p></p>
 <table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;">
  <tbody>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Use</span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Description</span>
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">revert</span> <span class="n">id</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      If a variable <span class="default"><code class="highlight-inline"><span class="n">id</span> <span class="o">:</span> <span class="n">T</span></code></span> is in the premises, move it back into the goal by changing the goal to by <span class="default"><code class="highlight-inline"><span class="k">forall</span> <span class="n">id</span> <span class="o">:</span> <span class="n">T</span><span class="o">,</span> <span class="bp">...</span></code></span> where the goal was <span class="default"><code class="highlight-inline"><span class="bp">...</span></code></span>. This is effectively undoing <span class="default"><code class="highlight-inline"><span class="n">intros</span></code></span> and can be useful if you want to do induction on the second (or third) argument while leaving the rest in the goal.
     </p>
    </td>
   </tr>
  </tbody>
 </table>
 <p></p>
 <p>
  These lemmas may be useful when we go to prove a more interesting fact about length:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">list_length_app</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">A</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">l1</span> <span class="n">l2</span> <span class="o">:</span> <span class="n">List</span> <span class="n">A</span><span class="o">),</span> 
 <span class="o">(</span><span class="n">List.append</span> <span class="n">l1</span> <span class="n">l2</span><span class="o">)</span><span class="bp">.</span><span class="n">length</span> <span class="bp">=</span> <span class="n">Nat.add</span> <span class="n">l1.length</span> <span class="n">l2.length</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">A</span> <span class="n">l1</span> <span class="n">l2</span>
    <span class="n">induction</span> <span class="n">l1</span>
    <span class="n">case</span> <span class="n">nil</span> <span class="bp">=&gt;</span> 
      <span class="n">rw</span> <span class="o">[</span><span class="n">list_app_l_nil'</span><span class="o">]</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">List.length</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">nat_zero_add</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">cons</span> <span class="n">h</span> <span class="n">t</span> <span class="n">ih</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">List.length</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">nat_succ_add</span><span class="o">]</span>
      <span class="n">rfl</span>
</pre>
  </div>
 </div>
 <p>
  We’ll proceed by induction on the first list argument.
 </p>
 <p>
  This is the first proof we’ve done where we’ve had to use previous lemmas: indeed, it would not be possible to do it "all at once", as there are separate inductive arguments that need to be made to carry out individual steps.
 </p>
 <p>
  In the empty case, we’ll first rewrite using the lemma we just proved,
that <span class="default"><code class="highlight-inline"><span class="n">List.append</span> <span class="o">[]</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span></code></span>, and then we’ll do definitional simplification
using the <span class="default"><code class="highlight-inline"><span class="n">List.length</span></code></span> function to get that
<span class="default"><code class="highlight-inline"><span class="n">List.length</span> <span class="o">[]</span> <span class="bp">=</span> <span class="mi">0</span></code></span>. Now we are left with a seemingly trivial
conundrum: <span class="default"><code class="highlight-inline"><span class="bp">⊢</span> <span class="n">List.length</span> <span class="n">l2</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">List.length</span> <span class="n">l2</span></code></span>. Now, to
understand whether this holds <span style="font-style: italic">definitionally</span>, we need to know
how addition is defined. On natural numbers, addition is defined to recur
on the <span style="font-style: italic">second</span> argument, which means that this is actually
not a trivial equality. Fortunately, this is a theorem we just proved!
 </p>
 <p>
  In the non-empty list case, we first <span class="default"><code class="highlight-inline"><span class="n">simp</span> <span class="n">only</span></code></span> with <span class="default"><code class="highlight-inline"><span class="n">List.length</span></code></span>. At this point, we can
use our inductive hypothesis, and we are almost finished: the only
issue is a problem of associativity. Our goal is:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="bp">⊢</span> <span class="n">Nat.add</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">l2</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">Nat.add</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">t</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">List.length</span> <span class="n">l2</span><span class="o">)</span>
</pre>
  </div>
 </div>
 <p>
  Or, if we abstract out a bit, replacing <span class="default"><code class="highlight-inline"><span class="bp">+</span> <span class="mi">1</span></code></span> with <span class="default"><code class="highlight-inline"><span class="n">Nat.succ</span></code></span>:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="bp">⊢</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Nat.add</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">a</span><span class="o">)</span> <span class="n">b</span>
</pre>
  </div>
 </div>
 <p>
  This should be true, but it is not true <span style="font-style: italic">definitionally</span>. Luckily, we had already proved this as a theorem, so we can nearly complete the proof by using it. After rewriting, the goal can be closed with <span class="default"><code class="highlight-inline"><span class="n">rfl</span></code></span>.
 </p>
 <div class="navsetbottom">
  <span class="navleft">
  <div class="nosearchform"></div>
  &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
 </span>
 <span class="navright">&nbsp;&nbsp;<a href="l19.html" title="backward to &quot;Lecture 19: Inductive types &amp; proofs&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l21.html" title="forward to &quot;Lecture 21: Proof Practice&quot;" data-pltdoc="x">next →</a></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
