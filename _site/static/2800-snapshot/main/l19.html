<!DOCTYPE html>
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="main.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a>
        </td>
        <td></td>
        <td>
         <a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr>all, Intro to PBT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span> Proof Practice</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l22.html" class="tocviewlink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Trees</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a>
        </td>
        <td></td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          1&nbsp;
         </td>
         <td>
          <a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          2&nbsp;
         </td>
         <td>
          <a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">2
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a>
     </td>
    </tr>
   </tbody>
  </table>
 </div>
</div>
<div class="maincolumn">
 <div class="main">
  <div class="versionbox">
   <span class="version">8.7</span>
  </div>
  <div class="navsettop">
   <span class="navleft">
   <div class="nosearchform"></div>
   &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
  </span>
  <span class="navright">&nbsp;&nbsp;<a href="l18.html" title="backward to &quot;Lecture 18: Proving with tactics&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l20.html" title="forward to &quot;Lecture 20: Lists&quot;" data-pltdoc="x">next →</a></span>&nbsp;
 </div>
 <h4>
  <a name="(part._l19)"></a>Lecture 19: Inductive types &amp; proofs
 </h4>
 <h5>
  1
  <tt>
   &nbsp;
  </tt>
  <a name="(part._.Purpose)"></a>Purpose
 </h5>
 <p>
  Inductive types &amp; inductive proofs
 </p>
 <h5>
  2
  <tt>
   &nbsp;
  </tt>
  <a name="(part._.Outline)"></a>Outline
 </h5>
 <p>
  As we’ve learned to program with Lean, we’ve seen several inductive types: not only natural
numbers, but lists and various logical connectives and constants.
 </p>
 <p>
  Today, we’re going to go into more detail about inductive types, and how we
can program and prove with them.
 </p>
 <p>
  Inductive types allow us to define both structures and enumerations: they
are the single type definition mechanism that we have, and they are
incredibly powerful. Indeed, the theory that underlies Lean is called the
Calculus of Inductive Constructions for a reason!
 </p>
 <p>
  We will show two different ways of defining an arithmetic expression (in the form of a binary tree) in the following:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="n">| num : Nat -&gt; ArithExp</span>
<span class="n">  |</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  This is the first, and the representation that underlies everything else.
Since everything has a type, our new inductive type must be given a type:
in this case, <span class="default"><code class="highlight-inline"><span class="kt">Type</span></code></span>. Then, we have a list of constructors. There can
be any (finite) number of constructors, including zero! Each constructor
can taken any number of arguments (including zero!) and must return the
type being constructed. The only final restriction is called the
"positivity" test. That means you cannot define a type like:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">inductive</span> <span class="n">MyT</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">C</span> <span class="o">:</span> <span class="o">(</span><span class="n">MyT</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">MyT</span>
</pre>
  </div>
 </div>
 <p>
  Positions in types are called "negative" or "positive", and all occurrences
of the type being defined must be positive in its definition. Positive
occurrences are the arguments to the constructor, or the return types of
function arguments to the constructor. Negative occurrences are arguments
to function arguments to the constructor, as above. That means we could
define a type like this:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">inductive</span> <span class="n">MyT</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">C</span> <span class="o">:</span> <span class="o">(</span><span class="kt">Prop</span> <span class="bp">-&gt;</span> <span class="n">MyT</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">MyT</span>
</pre>
  </div>
 </div>
 <p>
  This requirement is a much more subtle version of the requirement that all
functions terminate. If negative occurrences in types were allowed, it would
be possible to construct instances of uninhabited types, and in particular
prove logical falsehood. This, in turn, would render the logic not useful
as a logic, so it is ruled out by the system. We generally won’t run into
this, but if you do see that error, you should have some idea of what
you should be looking for.
 </p>
 <p>
  To construct elements of type <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span>, we use the constructors:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="n">def</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  To use an <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span> in code or in a proof, we can use
<span style="font-style: italic">pattern matching</span>, a common feature in typed functional
programming, and one we’ve started getting familiar with. This is a more
concise form of the pattern of conditionally branching on which case of
the data type you are in, and then binding the corresponding elements.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="n">def</span><span class="w"> </span><span class="n">a4</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="n">with</span><span class="w"> </span>
<span class="w">          </span><span class="n">| ArithExp.add e1 _ =&gt; e1</span>
<span class="n">          |</span><span class="w"> </span><span class="k">_</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">a3</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  A <span class="default"><code class="highlight-inline"><span class="k">match</span></code></span> expression takes an expression (here <span class="default"><code class="highlight-inline"><span class="n">a3</span></code></span>), and then
a series of clauses. Lean requires that the clauses are exhaustive: they
must cover all of the cases of the inductive type, but you can use wildcard
(<span class="default"><code class="highlight-inline"><span class="n">_</span></code></span>) patterns to cover multiple cases, or within cases. Note that
both in the constructors and pattern matching we are using qualified names:
<span class="default"><code class="highlight-inline"><span class="n">ArithExp.add</span></code></span>, not <span class="default"><code class="highlight-inline"><span class="n">add</span></code></span>. When we define a new inductive type,
Lean creates what is called a namespace, and puts the constructors inside.
This means you can use the same constructor names for different inductive
types, which is convenient. You can also define your own namespaces
explicitly, which we may do at times.
 </p>
 <p>
  While that syntax of inductive definition is the core syntax, we will often use
the following shorthand, which gives names to the arguments to constructors,
writing them a bit more like enumerated struct definitions:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="n">| num (n : Nat)</span>
<span class="n">  |</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="p">)</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  This is a logically equivalent type, but it comes with convenient field
names. In a case where you have multiple cases of the inductive type, this
is a little less useful, as until you know which case you are in, you can’t
use the fields to access data, though you can use them to construct data
without knowing the order:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">a5</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  You can also apply only some of the arguments, and end up with a
<span style="font-style: italic">partially applied</span> function expecting the rest:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">#check</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span>
<span class="n">--</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  Let’s practice by writing a function that uses pattern matching to evaluate
our arith expressions to a number:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">Nat</span><span class="w"></span>
<span class="w">  </span><span class="n">| ArithExp.num n =&gt; n</span>
<span class="n">  |</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Nat.add</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  We’ll come back to using this in a proof in a bit.
 </p>
 <p>
  Let’s now define a new inductive type, this time for colors. It should be
an enumeration of a few constants:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="n">| red : Color</span>
<span class="n">  |</span><span class="w"> </span><span class="n">green</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Color</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">blue</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Color</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  Now, let’s define a different representation, where our type has a
single constructor that takes three natural numbers as arguments (for red,
green, blue light values):
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">RGB</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">RGB</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  We can now define functions that convert between the two representations:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">colortoRGB</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">RGB</span><span class="w"></span>
<span class="w">  </span><span class="n">| Color.red =&gt; RGB.mk 255 0 0</span>
<span class="n">  |</span><span class="w"> </span><span class="n">Color.green</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">RGB.mk</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="n">| Color.blue =&gt; RGB.mk 0 0 255</span>

<span class="n">def RGBtoColor : RGB -&gt; Color</span>
<span class="n">  |</span><span class="w"> </span><span class="n">RGB.mk</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Color.red</span><span class="w"></span>
<span class="w">  </span><span class="n">| RGB.mk 0 255 0 =&gt; Color.green</span>
<span class="n">  |</span><span class="w"> </span><span class="n">RGB.mk</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Color.blue</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="k">_</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Color.red</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  What had to happen when we converted from RGB to color? We had to pick
a way of handling "all the rest" of the colors. In this case, we just
turned everything else into Red. There are other approaches, but the
important part is that Lean will always make us handle every case in some
way. This is quite different from similar pattern matching in functional
languages like Haskell or OCaml, where you can leave out cases and get
errors at runtime.
 </p>
 <p>
  Now, let’s prove that if we convert from Color to RGB and back, we get the same thing:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">theorem</span><span class="w"> </span><span class="n">colorRGB_roundtrip</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="n">c</span><span class="o">,</span><span class="w"> </span><span class="n">RGBtoColor</span><span class="w"> </span><span class="p">(</span><span class="n">colortoRGB</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">:=</span><span class="w"></span>
<span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">intros</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
<span class="w">    </span><span class="n">cases</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="nb">&lt;</span><span class="c1">;&gt; simp only [colortoRGB, RGBtoColor]</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  <span class="Larger">Inductive proofs</span>
 </p>
 <p>
  Our motivation for moving to Lean was to be able to prove properties about
unbounded data. Now we know how to define inductive data types,
which allow us to describe all sorts of unbounded data: not only numbers,
but lists, trees, graphs, etc. Any of the data types that you designed
in Fundies 1 are types that you should be able to write down as a suitable
inductive definition.
 </p>
 <p>
  But writing data definitions and defining functions over them was not our
goal: we wanted to prove properties. Let’s start to talk about how that
works.
 </p>
 <p>
  We’ve shown how in Lean, logical statements are types, and terms that have
the type are proofs of the statement. Just as possibly many terms can have the
same type, there are often many ways to prove the same statement. We’ve shown,
in detail, how we can apply this to minimal propositional logic – how implication
is expressed through function arrows, and application corresponds to modus ponens.
 </p>
 <p>
  Now we are going to talk about how recursion corresponds to induction.
 </p>
 <p>
  Inductive types are named that because they can be defined inductively – i.e.,
the constructors can refer to the type itself. Provided there is at least one
base case (i.e., a constructor that does not refer to itself), we can build
examples of the data: i.e., it is <span style="font-style: italic">inhabited</span>.
 </p>
 <p>
  We will use an inductive type by pattern matching, and often computing
recursively.
 </p>
 <p>
  We’ll start by proving a simple property of lists: that appending an empty list results in the same list. Proving this on the <span style="font-style: italic">left</span> is trivial (try it!), but on the right requires induction, because of how <span class="default"><code class="highlight-inline"><span class="n">List.append</span></code></span> is defined.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="n">theorem</span><span class="w"> </span><span class="n">list_app_r_nil</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">forall</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">,</span><span class="w"></span>
<span class="w">  </span><span class="n">List.append</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="n">List.nil</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="n">:=</span><span class="w"></span>
<span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">intros</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">L</span><span class="w"></span>
<span class="w">    </span><span class="n">induction</span><span class="w"> </span><span class="n">L</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="p">[</span><span class="n">List.append</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="n">IH</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">simp</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="p">[</span><span class="n">List.append</span><span class="p">]</span><span class="w"></span>
<span class="w">                        </span><span class="n">rw</span><span class="w"> </span><span class="p">[</span><span class="n">IH</span><span class="p">]</span><span class="w"></span>
</pre>
  </div>
 </div>
 <p>
  Here we see a few new tactics. Not only <span class="default"><code class="highlight-inline"><span class="n">induction</span></code></span>, but <span class="default"><code class="highlight-inline"><span class="n">simp</span> <span class="n">only</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">rw</span></code></span>.
 </p>
 <p></p>
 <table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;">
  <tbody>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Use</span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Description</span>
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">induction</span> <span class="n">id</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      If <span class="default"><code class="highlight-inline"><span class="n">id</span></code></span> is a hypothesis that is an inductive type, replace the current goal with cases for each of the constructors of the inductive type.
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">id</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="bp">...</span><span class="o">]</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      Evaluates the goal, but only using the functions specified in the list
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">id</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="bp">...</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      The same as above, but simplifies in a hypothesis H
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">rw</span> <span class="o">[</span><span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="bp">...</span><span class="o">]</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      If <span class="default"><code class="highlight-inline"><span class="n">HN</span></code></span> are equations that are hypotheses or theorems, rewrite the goal with them. Note that after rewriting, the tactic will attempt to close the goal using <span class="default"><code class="highlight-inline"><span class="n">rfl</span></code></span>
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">H1</span><span class="o">,</span> <span class="n">H2</span><span class="o">,</span> <span class="bp">...</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      The arrow allows to rewrite using the equation the other direction, and the <span class="default"><code class="highlight-inline"><span class="n">at</span> <span class="n">H</span></code></span> allows you to specify a hypothesis where you rewrite, rather than the goal
     </p>
    </td>
   </tr>
  </tbody>
 </table>
 <p></p>
 <p>
  Now, consider our <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span> inductive type, and <span class="default"><code class="highlight-inline"><span class="n">eval</span></code></span> function. We talked about this as <span style="font-style: italic">programming</span>: it
is a function that takes an expression and returns a number. But we can
also think of the type as a logical statement: that given an
<span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span>, it is possible to construct a <span class="default"><code class="highlight-inline"><span class="n">Nat</span></code></span>. This isn’t a
terribly interesting statement, because we can construct a <span class="default"><code class="highlight-inline"><span class="n">Nat</span></code></span>
without anything: we can just use <span class="default"><code class="highlight-inline"><span class="mi">0</span></code></span>, or <span class="default"><code class="highlight-inline"><span class="mi">1</span></code></span>, or any of the
infinite other <span class="default"><code class="highlight-inline"><span class="n">Nat</span></code></span>s. It thus has lots of proofs, many of which
are probably not very useful, at least if we want to treat them also
as programs.
 </p>
 <p>
  Things become much more interesting when we introduce the ability to
express <span style="font-style: italic">equivalence</span> in our logical statements. There are two
different ways of doing this in Lean. First, we can express it as
two implications: a statement <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> is equivalent to a statement
<span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span> if <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">-&gt;</span> <span class="n">Q</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">Q</span> <span class="bp">-&gt;</span> <span class="n">P</span></code></span>. We can write this
compactly as <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">&lt;-&gt;</span> <span class="n">Q</span></code></span>. Constructing a proof for such a theorem
involves proving both implications. The other form of equivalence is
<span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">=</span> <span class="n">Q</span></code></span>, which is an inductive type with a single constructor
that takes two identical elements. This means that if you have a proof
(i.e., term) of type <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">=</span> <span class="n">Q</span></code></span>, you know that <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">Q</span></code></span>
must actually be the same, as that’s the only way you could have
constructed the term. We’ll use both forms of equivalence, though
the latter is <span style="font-style: italic">stronger</span>, since it shows that the two
statements must actually be the same, whereas <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">&lt;-&gt;</span> <span class="n">Q</span></code></span> only
means that you can prove them each from the other. The other issue is
that <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">&lt;-&gt;</span> <span class="n">Q</span></code></span> is only defined for propositions, whereas
<span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="bp">=</span> <span class="n">Q</span></code></span> is defined for any type.
 </p>
 <p>
  Let’s use this with our <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span> definition. Let’s define an
optimization, <span class="default"><code class="highlight-inline"><span class="n">const_fold</span></code></span>, that replaces any <span class="default"><code class="highlight-inline"><span class="n">ArithExp.add</span></code></span>
 of two numbers with the result of the
operation.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">def</span> <span class="n">const_fold</span> <span class="o">:</span> <span class="n">ArithExp</span> <span class="bp">→</span> <span class="n">ArithExp</span>
  <span class="bp">|</span> <span class="n">ArithExp.num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.num</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">ArithExp.add</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">ArithExp.num</span> <span class="n">n</span><span class="o">,</span> <span class="n">ArithExp.num</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.num</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">l'</span><span class="o">,</span> <span class="n">r'</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.add</span> <span class="o">(</span><span class="n">const_fold</span> <span class="n">l'</span><span class="o">)</span> 
                             <span class="o">(</span><span class="n">const_fold</span> <span class="n">r'</span><span class="o">)</span>
</pre>
  </div>
 </div>
 <p>
  We can prove that this is correct, by showing that the result of
calling <span class="default"><code class="highlight-inline"><span class="n">eval</span></code></span> on the result of <span class="default"><code class="highlight-inline"><span class="n">const_fold</span></code></span> is the same as
calling <span class="default"><code class="highlight-inline"><span class="n">eval</span></code></span> on the original expression, for all expressions.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">const_fold_correct1</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExp</span><span class="o">),</span> <span class="n">eval</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">eval</span> <span class="o">(</span><span class="n">const_fold</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">l</span> <span class="n">r</span> <span class="n">ihl</span> <span class="n">ihr</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">l</span> <span class="k">with</span> 
        <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">r</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">num</span> <span class="n">m</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihr</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
        <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">r</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">num</span> <span class="n">m</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihl</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">_</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihr</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">ihl</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <p>
  First, note that this was what we <span style="font-style: italic">approximated</span> earlier, using PBT or Rosette. Now we have proved it for all expressions. We did it by <span style="font-style: italic">induction</span>. What is induction? It’s a strategy for constructing a proof for an arbitrary sized piece of data, in the same way as we write recursive functions over arbitrary sized data.
 </p>
 <p>
  Let’s look at the proof state after we run the <span class="default"><code class="highlight-inline"><span class="n">induction</span></code></span> tactic. See we have <span style="font-style: italic">two</span> goals now: one for each case of our data type. This is the same way that a recursive function on <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span> would have two cases in pattern matching, or two branches in a template. In the base case(s) we have to prove the statement in that case. In the other cases, we have to prove the statement, but we can use (analogously to recursive calls!) the statement on the subparts of the data. i.e., we can assume it already holds on the subparts of the data.
 </p>
 <p>
  Why does this work? Well, for any example piece of data, it is built out of the constructors, and if we have proved each of these cases, we can build up a proof of the example by starting with the proofs of the base case and then applying the inductive cases over and over. Since we can do that for <span style="font-style: italic">any</span> data, it works for all!
 </p>
 <p>
  Now, that was kind of repetitive. If we do a little work, we can make that proof a lot shorter, by relying on some of the tacticals:
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">theorem</span> <span class="n">const_fold_correct2</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExp</span><span class="o">),</span> <span class="n">eval</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">eval</span> <span class="o">(</span><span class="n">const_fold</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">l</span> <span class="n">r</span> <span class="n">ihl</span> <span class="n">ihr</span> <span class="bp">=&gt;</span> 
      <span class="o">(</span><span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">])</span>
        <span class="bp">&lt;;&gt;</span> <span class="n">cases</span> <span class="n">l</span>
        <span class="bp">&lt;;&gt;</span> <span class="n">cases</span> <span class="n">r</span>
        <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
        <span class="bp">&lt;;&gt;</span> <span class="o">(</span><span class="n">try</span> <span class="o">(</span><span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihr</span><span class="o">]))</span>
        <span class="bp">&lt;;&gt;</span> <span class="o">(</span><span class="n">try</span> <span class="o">(</span><span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihl</span><span class="o">]))</span>
        <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
      
</pre>
  </div>
 </div>
 <p>
  Here, in addition to <span class="default"><code class="highlight-inline"><span class="bp">&lt;;&gt;</span></code></span>, which we’ve seen before, we introduce a new one, <span class="default"><code class="highlight-inline"><span class="n">try</span></code></span>, which takes a tactic and even if that tactic fails, still succeeds. This is important because chaining with <span class="default"><code class="highlight-inline"><span class="bp">&lt;;&gt;</span></code></span> will only proceed if every tactic along the chain succeeds, so if there are operations that may not succeed, but we want later operations to work, we must wrap them in <span class="default"><code class="highlight-inline"><span class="n">try</span></code></span>. <span style="font-weight: bold">Note that <span class="default"><code class="highlight-inline"><span class="bp">&lt;;&gt;</span></code></span> binds tighter than <span class="default"><code class="highlight-inline"><span class="n">try</span></code></span>, so you must wrap <span class="default"><code class="highlight-inline"><span class="n">try</span></code></span> in parentheses!</span>
 </p>
 <p></p>
 <table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;">
  <tbody>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Use</span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span style="font-weight: bold">Tactic Description</span>
     </p>
    </td>
   </tr>
   <tr>
    <td style="border-bottom: 1px solid black;">
     <p>
      <span class="default"><code class="highlight-inline"><span class="n">try</span> <span class="n">tac</span></code></span>
     </p>
    </td>
    <td style="border-bottom: 1px solid black;">
     <p>
      Run tactic <span class="default"><code class="highlight-inline"><span class="n">tac</span></code></span>, and even if <span class="default"><code class="highlight-inline"><span class="n">tac</span></code></span> fails, still succeed, which is important when wrapping inside of <span class="default"><code class="highlight-inline"><span class="bp">&lt;;&gt;</span></code></span>, as the chain will stop at the first failing tactic.
     </p>
    </td>
   </tr>
  </tbody>
 </table>
 <p></p>
 <p>
  Now, let’s add, as an exercise, another case to our inductive type: this time for multiplication. Then we’ll update eval, and our constant folding function, and our proof to account for this.
 </p>
 <div class="default">
  <div class="highlight">
   <pre><span></span><span class="kd">inductive</span> <span class="n">ArithExp</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">(</span><span class="n">l</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ArithExp</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">mul</span> <span class="o">(</span><span class="n">l</span> <span class="n">r</span> <span class="o">:</span> <span class="n">ArithExp</span><span class="o">)</span>


<span class="kd">def</span> <span class="n">eval</span> <span class="o">:</span> <span class="n">ArithExp</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">ArithExp.num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">ArithExp.add</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">Nat.add</span> <span class="o">(</span><span class="n">eval</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">eval</span> <span class="n">r</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ArithExp.mul</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">Nat.mul</span> <span class="o">(</span><span class="n">eval</span> <span class="n">l</span><span class="o">)</span> <span class="o">(</span><span class="n">eval</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">const_fold</span> <span class="o">:</span> <span class="n">ArithExp</span> <span class="bp">→</span> <span class="n">ArithExp</span>
  <span class="bp">|</span> <span class="n">ArithExp.num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.num</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">ArithExp.add</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span>
    <span class="k">match</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span> <span class="k">with</span>
    <span class="bp">|</span> <span class="n">ArithExp.num</span> <span class="n">n</span><span class="o">,</span> <span class="n">ArithExp.num</span> <span class="n">m</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.num</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span>
    <span class="bp">|</span> <span class="n">l'</span><span class="o">,</span> <span class="n">r'</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.add</span> <span class="o">(</span><span class="n">const_fold</span> <span class="n">l'</span><span class="o">)</span> 
                             <span class="o">(</span><span class="n">const_fold</span> <span class="n">r'</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">ArithExp.mul</span> <span class="n">l</span> <span class="n">r</span> <span class="bp">=&gt;</span> <span class="n">ArithExp.mul</span> <span class="o">(</span><span class="n">const_fold</span> <span class="n">l</span><span class="o">)</span> 
                                     <span class="o">(</span><span class="n">const_fold</span> <span class="n">r</span><span class="o">)</span>

<span class="kd">theorem</span> <span class="n">const_fold_correct1</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExp</span><span class="o">),</span> <span class="n">eval</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">eval</span> <span class="o">(</span><span class="n">const_fold</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">l</span> <span class="n">r</span> <span class="n">ihl</span> <span class="n">ihr</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
      <span class="n">cases</span> <span class="n">l</span> <span class="k">with</span> 
        <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">r</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">num</span> <span class="n">m</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">add</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihr</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">mul</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span> <span class="n">at</span> <span class="n">ihr</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihr</span><span class="o">]</span>
        <span class="bp">|</span> <span class="n">add</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">r</span> <span class="k">with</span>
          <span class="bp">|</span> <span class="n">num</span> <span class="n">m</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">,</span> <span class="n">eval</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihl</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">add</span> <span class="bp">=&gt;</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihr</span><span class="o">,</span> <span class="bp">&lt;-</span> <span class="n">ihl</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
          <span class="bp">|</span> <span class="n">mul</span> <span class="bp">=&gt;</span> 
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">,</span> <span class="n">const_fold</span><span class="o">]</span>
            <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">ihl</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span> <span class="n">at</span> <span class="n">ihr</span>
            <span class="n">rw</span> <span class="o">[</span><span class="n">ihr</span><span class="o">]</span>
            <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
        <span class="bp">|</span> <span class="n">mul</span> <span class="bp">=&gt;</span> 
          <span class="n">rw</span> <span class="o">[</span><span class="n">ihl</span><span class="o">,</span> <span class="n">ihr</span><span class="o">]</span>
          <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">eval</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">mul</span> <span class="n">l</span> <span class="n">r</span> <span class="n">ihl</span> <span class="n">ihr</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">const_fold</span><span class="o">,</span> <span class="n">eval</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ihr</span><span class="o">,</span> <span class="n">ihl</span><span class="o">]</span>
</pre>
  </div>
 </div>
 <div class="navsetbottom">
  <span class="navleft">
  <div class="nosearchform"></div>
  &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
 </span>
 <span class="navright">&nbsp;&nbsp;<a href="l18.html" title="backward to &quot;Lecture 18: Proving with tactics&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l20.html" title="forward to &quot;Lecture 20: Lists&quot;" data-pltdoc="x">next →</a></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
