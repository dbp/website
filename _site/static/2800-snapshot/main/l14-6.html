<!DOCTYPE html>
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=0.8">
  <title>
   dbp.io
  </title>
  <link rel="stylesheet" type="text/css" href="scribble.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="manual-racket.css" title="default">
  <link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default">
  <link rel="stylesheet" type="text/css" href="main.css" title="default">
  <script type="text/javascript" src="scribble-common.js"></script>
  <script type="text/javascript">
   (function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
  </script>
  <script type="text/javascript" src="manual-racket.js"></script>
 </head>
 <body id="scribble-racket-lang-org">
  <div class="tocset">
   <div class="tocview">
    <div class="tocviewlist tocviewlisttopspace">
     <div class="tocviewtitle">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td style="width: 1em;">
          <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">►</a>
         </td>
         <td></td>
         <td>
          <a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <div class="tocviewsublisttop" style="display: none;" id="tocview_0">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">▼</a>
        </td>
        <td></td>
        <td>
         <a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublist" style="display: block;" id="tocview_1">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr>all, Intro to PBT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l14-5.html" class="tocviewlink" data-pltdoc="x">Lecture 14.5:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 14.6:<span class="mywbr"> &nbsp;</span> Propositional logic, beginning with inductive types</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Inductive proofs</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Lists</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Trees</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a>
         </td>
        </tr>
        <tr>
         <td align="right"></td>
         <td>
          <a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="tocviewlist">
     <table cellspacing="0" cellpadding="0">
      <tbody>
       <tr>
        <td style="width: 1em;">
         <a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">►</a>
        </td>
        <td></td>
        <td>
         <a href="" class="tocviewselflink" data-pltdoc="x">Lecture 14.6:<span class="mywbr"> &nbsp;</span> Propositional logic, beginning with inductive types</a>
        </td>
       </tr>
      </tbody>
     </table>
     <div class="tocviewsublistbottom" style="display: none;" id="tocview_2">
      <table cellspacing="0" cellpadding="0">
       <tbody>
        <tr>
         <td align="right">
          1&nbsp;
         </td>
         <td>
          <a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          2&nbsp;
         </td>
         <td>
          <a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a>
         </td>
        </tr>
        <tr>
         <td align="right">
          3&nbsp;
         </td>
         <td>
          <a href="#%28part._.Re-doing_a_propositional_logic_proof%29" class="tocviewlink" data-pltdoc="x">Re-<wbr>doing a propositional logic proof</a>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="tocsub">
    <div class="tocsubtitle">
     On this page:
    </div>
    <table class="tocsublist" cellspacing="0">
     <tbody>
      <tr>
       <td>
        <span class="tocsublinknumber">1
        <tt>
         &nbsp;
        </tt>
       </span>
       <a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a>
      </td>
     </tr>
     <tr>
      <td>
       <span class="tocsublinknumber">2
       <tt>
        &nbsp;
       </tt>
      </span>
      <a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a>
     </td>
    </tr>
    <tr>
     <td>
      <span class="tocsublinknumber">3
      <tt>
       &nbsp;
      </tt>
     </span>
     <a href="#%28part._.Re-doing_a_propositional_logic_proof%29" class="tocsubseclink" data-pltdoc="x">Re-<wbr>doing a propositional logic proof</a>
    </td>
   </tr>
  </tbody>
 </table>
</div>
</div>
<div class="maincolumn">
<div class="main">
 <div class="versionbox">
  <span class="version">8.7</span>
 </div>
 <div class="navsettop">
  <span class="navleft">
  <div class="nosearchform"></div>
  &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
 </span>
 <span class="navright">&nbsp;&nbsp;<a href="l14-5.html" title="backward to &quot;Lecture 14.5: Propositional logic &amp; programming&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l15.html" title="forward to &quot;Lecture 15: Inductive proofs&quot;" data-pltdoc="x">next →</a></span>&nbsp;
</div>
<h4>
 <a name="(part._l14-6)"></a>Lecture 14.6: Propositional logic, beginning with inductive types
</h4>
<h5>
 1
 <tt>
  &nbsp;
 </tt>
 <a name="(part._.Purpose)"></a>Purpose
</h5>
<p>
 More propositional logic, more on proofs, some inductive types
</p>
<h5>
 2
 <tt>
  &nbsp;
 </tt>
 <a name="(part._.Outline)"></a>Outline
</h5>
<h5>
 3
 <tt>
  &nbsp;
 </tt>
 <a name="(part._.Re-doing_a_propositional_logic_proof)"></a>Re-doing a propositional logic proof
</h5>
<p>
 Let’s prove a theorem that you did in HW1:
</p>
<p>
 <span class="texMathDisplay">\neg (P \lor Q) \equiv \neg P \land \neg Q</span>
</p>
<p>
 Here we’ve written <span class="texMathInline">\equiv</span> as "if-and-only-if" double implication,
rather than propositional equality. Both allow Lean to rewrite.
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="kd">theorem</span> <span class="n">demorgan1</span> <span class="o">:</span> <span class="k">forall</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">},</span> <span class="bp">¬</span><span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">↔</span> <span class="bp">¬</span><span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span><span class="n">Q</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">P</span> <span class="n">Q</span>
     <span class="n">constructor</span>
     <span class="n">case</span> <span class="n">mp</span> <span class="bp">=&gt;</span> <span class="n">intro</span>
                <span class="n">constructor</span> 
                <span class="n">case</span> <span class="n">left</span> <span class="bp">=&gt;</span> 
                  <span class="n">intro</span><span class="bp">;</span> <span class="n">apply</span> <span class="o">‹</span><span class="bp">¬</span><span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)›</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">Or.inl</span><span class="bp">;</span> <span class="n">assumption</span>
                <span class="n">case</span> <span class="n">right</span> <span class="bp">=&gt;</span> 
                  <span class="n">intro</span><span class="bp">;</span> <span class="n">apply</span> <span class="o">‹</span><span class="bp">¬</span><span class="o">(</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">)›</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">Or.inr</span><span class="bp">;</span> <span class="n">assumption</span>
     <span class="n">case</span> <span class="n">mpr</span> <span class="bp">=&gt;</span> <span class="n">intro</span>
                 <span class="n">intro</span>
                 <span class="n">cases</span> <span class="o">‹</span><span class="bp">¬</span> <span class="n">P</span> <span class="bp">∧</span> <span class="bp">¬</span> <span class="n">Q</span><span class="o">›</span> 
                 <span class="n">cases</span> <span class="o">‹</span><span class="n">P</span> <span class="bp">∨</span> <span class="n">Q</span><span class="o">›</span>
                 <span class="n">case</span> <span class="n">inl</span> <span class="bp">=&gt;</span> <span class="n">apply</span> <span class="o">‹</span><span class="bp">¬</span><span class="n">P</span><span class="o">›</span><span class="bp">;</span> <span class="n">assumption</span>
                 <span class="n">case</span> <span class="n">inr</span> <span class="bp">=&gt;</span> <span class="n">apply</span> <span class="o">‹</span><span class="bp">¬</span><span class="n">Q</span><span class="o">›</span><span class="bp">;</span> <span class="n">assumption</span>
</pre>
 </div>
</div>
<p>
 Interestingly, the other proof that you did:
</p>
<p>
 <span class="texMathDisplay">\neg (P \land Q) \equiv \neg P \lor \neg Q</span>
</p>
<p>
 cannot be done in the core logic of Lean. The issue is that it is not
constructive; it can be done if we add classical axioms.
</p>
<p>
 <span class="Larger">Stepping back: proofs here vs. proofs with truth tables</span>
</p>
<p>
 Now that we’ve seen a few proofs, including doing a proof that
you did in propositional logic, it’s important to understand
the difference between proofs in Lean and proofs in propositional
logic.
</p>
<p>
 In propositional logic, all variables can be either true or false,
and thus any formula can be computed via a finite truth table. In
a higher order logic like Lean, propositional variables are not
either true or false, but rather, they are either <span style="font-style: italic">provable</span>
or not provable. For a statement to be provable, it means that we
have constructed a proof term with that type, but that type may
involve data of arbitrary size, and thus the truth or falseness of
a given statement cannot be determined by a finite truth table. Thus
while the proof we just did of one of De Morgan’s laws is syntactically
the same as what you did in HW1, it is a much more powerful proof,
as it holds for any provable propositions, not just for T/F propositional
variables. Another way to think about this is that Lean has propositional
logic embedded, by way of the boolean data type. Thus, our proof
from HW1 was the following:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="kd">theorem</span> <span class="n">demorganprop</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">{</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">Bool</span><span class="o">},</span> <span class="n">not</span> <span class="o">(</span><span class="n">or</span> <span class="n">P</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">=</span> <span class="n">and</span> <span class="o">(</span><span class="n">not</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">not</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:=</span>
    <span class="kd">by</span> <span class="n">intros</span> <span class="n">P</span> <span class="n">Q</span>
       <span class="n">cases</span> <span class="n">P</span> <span class="bp">&lt;;&gt;</span> <span class="n">cases</span> <span class="n">Q</span> <span class="bp">&lt;;&gt;</span> <span class="n">rfl</span>
</pre>
 </div>
</div>
<p>
 Here we can see a new tactic: <span class="default"><code class="highlight-inline"><span class="bp">&lt;;&gt;</span></code></span>, which is used to chain
tactics together by applying what follows to everything that comes out of
the former. Here we can see that by doing case analysis on the two boolean
inputs, we can complete the proof trivially, as once we have constants,
simply evaluating the expression will give us the result.
</p>
<p>
 Attemptying to do that for the other proof will fail, as we cannot do
case analysis on <span class="default"><code class="highlight-inline"><span class="kt">Prop</span></code></span>: it is not an inductive type with a finite
number of constructors.
</p>
<p>
 In the past two days, we’ve seen several inductive types: not only natural
numbers, but various logical connectives and constants.
</p>
<p>
 Today, we’re going to go into more detail about inductive types, and how we
can program with them.
</p>
<p>
 Inductive types allow us to define both structures and enumerations: they
are the single type definition mechanism that we have, and they are
incredibly powerful. Indeed, the theory that underlies Lean is called the
Calculus of Inductive Constructions for a reason!
</p>
<p>
 We will show two different ways of defining an arithmetic expression (in the form of a binary tree) in the following:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="n">| num : Nat -&gt; ArithExp</span>
<span class="n">  |</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 This is the first, and the representation that underlies everything else.
Since everything has a type, our new inductive type must be given a type:
in this case, <span class="default"><code class="highlight-inline"><span class="kt">Type</span></code></span>. Then, we have a list of constructors. There can
be any (finite) number of constructors, including zero! Each constructor
can taken any number of arguments (including zero!) and must return the
type being constructed. The only final restriction is called the
"positivity" test. That means you cannot define a type like:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="kd">inductive</span> <span class="n">MyT</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">C</span> <span class="o">:</span> <span class="o">(</span><span class="n">MyT</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">MyT</span>
</pre>
 </div>
</div>
<p>
 Positions in types are called "negative" or "positive", and all occurrences
of the type being defined must be positive in its definition. Positive
occurrences are the arguments to the constructor, or the return types of
function arguments to the constructor. Negative occurrences are arguments
to function arguments to the constructor, as above. That means we could
define a type like this:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="kd">inductive</span> <span class="n">MyT</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">C</span> <span class="o">:</span> <span class="o">(</span><span class="kt">Prop</span> <span class="bp">-&gt;</span> <span class="n">MyT</span><span class="o">)</span> <span class="bp">-&gt;</span> <span class="n">MyT</span>
</pre>
 </div>
</div>
<p>
 This requirement is a much more subtle version of the requirement that all
functions terminate. If negative occurrences in types were allowed, it would
be possible to construct instances of uninhabited types, and in particular
prove logical falsehood. This, in turn, would render the logic not useful
as a logic, so it is ruled out by the system. We generally won’t run into
this, but if you do see that error, you should have some idea of what
you should be looking for.
</p>
<p>
 To construct elements of type <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span>, we use the constructors:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">10</span><span class="w"></span>
<span class="n">def</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 To use an <span class="default"><code class="highlight-inline"><span class="n">ArithExp</span></code></span> in code or in a proof, we can use
<span style="font-style: italic">pattern matching</span>, a common feature in typed functional
programming, but possibly one you have not seen before. This is a more
concise form of the pattern of conditionally branching on which case of
the data type you are in, and then binding the corresponding elements.
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="n">def</span><span class="w"> </span><span class="n">a4</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">a3</span><span class="w"> </span><span class="n">with</span><span class="w"> </span>
<span class="w">          </span><span class="n">| ArithExp.add e1 _ =&gt; e1</span>
<span class="n">          |</span><span class="w"> </span><span class="k">_</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">a3</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 A <span class="default"><code class="highlight-inline"><span class="k">match</span></code></span> expression takes an expression (here <span class="default"><code class="highlight-inline"><span class="n">a3</span></code></span>), and then
a series of clauses. Lean requires that the clauses are exhaustive: they
must cover all of the cases of the inductive type, but you can use wildcard
(<span class="default"><code class="highlight-inline"><span class="n">_</span></code></span>) patterns to cover multiple cases, or within cases. Note that
both in the constructors and pattern matching we are using qualified names:
<span class="default"><code class="highlight-inline"><span class="n">ArithExp.add</span></code></span>, not <span class="default"><code class="highlight-inline"><span class="n">add</span></code></span>. When we define a new inductive type,
Lean creates what is called a namespace, and puts the constructors inside.
This means you can use the same constructor names for different inductive
types, which is convenient. You can also define your own namespaces
explicitly, which we may do at times.
</p>
<p>
 While that syntax of inductive definition is the core syntax, we will often use
the following shorthand, which gives names to the arguments to constructors,
writing them a bit more like enumerated struct definitions:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="n">| num (n : Nat)</span>
<span class="n">  |</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">mul</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="p">)</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 This is a logically equivalent type, but it comes with convenient field
names. In a case where you have multiple cases of the inductive type, this
is a little less useful, as until you know which case you are in, you can’t
use the fields to access data, though you can use them to construct data
without knowing the order:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">a5</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 You can also apply only some of the arguments, and end up with a
<span style="font-style: italic">partially applied</span> function expecting the rest:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">#check</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">:=</span><span class="w"> </span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span>
<span class="n">--</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">ArithExp.num</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 Let’s practice by writing a function that uses pattern matching to evaluate
our arith expressions to a number:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">def</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">ArithExp</span><span class="w"> </span><span class="n">→</span><span class="w"> </span><span class="n">Nat</span><span class="w"></span>
<span class="w">  </span><span class="n">| ArithExp.num n =&gt; n</span>
<span class="n">  |</span><span class="w"> </span><span class="n">ArithExp.add</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">ArithExp.mul</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="nb">eval</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 Let’s define a new inductive type, this time for colors. It should be
an enumeration of a few constants:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="n">| red : Color</span>
<span class="n">  |</span><span class="w"> </span><span class="n">green</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Color</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">blue</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Color</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 Now, let’s define a different representation, where our type has a
single constructor that takes three natural numbers as arguments (for red,
green, blue light values):
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">inductive</span><span class="w"> </span><span class="n">RGB</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">where</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="n">mk</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">Nat</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">RGB</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 We can now define functions that convert between the two representations:
</p>
<div class="default">
 <div class="highlight">
  <pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">colortoRGB</span><span class="w"> </span><span class="n">:</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="k">-&gt;</span><span class="w"> </span><span class="n">RGB</span><span class="w"></span>
<span class="w">  </span><span class="n">| Color.red =&gt; RGB.mk 255 0 0</span>
<span class="n">  |</span><span class="w"> </span><span class="n">Color.green</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">RGB.mk</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">  </span><span class="n">| Color.blue =&gt; RGB.mk 0 0 255</span>

<span class="n">def RGBtoColor : RGB -&gt; Color</span>
<span class="n">  |</span><span class="w"> </span><span class="n">RGB.mk</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Color.red</span><span class="w"></span>
<span class="w">  </span><span class="n">| RGB.mk 0 255 0 =&gt; Color.green</span>
<span class="n">  |</span><span class="w"> </span><span class="n">RGB.mk</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Color.blue</span><span class="w"></span>
<span class="w">  </span><span class="err">|</span><span class="w"> </span><span class="k">_</span><span class="w"> </span><span class="k">=&gt;</span><span class="w"> </span><span class="n">Color.red</span><span class="w"></span>
</pre>
 </div>
</div>
<p>
 What had to happen when we converted from RGB to color? We had to pick
a way of handling "all the rest" of the colors. In this case, we just
turned everything else into Red. There are other approaches, but the
important part is that Lean will always make us handle every case in some
way. This is quite different from similar pattern matching in functional
languages like Haskell or OCaml, where you can leave out cases and get
errors at runtime.
</p>
<div class="navsetbottom">
 <span class="navleft">
 <div class="nosearchform"></div>
 &nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span>
</span>
<span class="navright">&nbsp;&nbsp;<a href="l14-5.html" title="backward to &quot;Lecture 14.5: Propositional logic &amp; programming&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l15.html" title="forward to &quot;Lecture 15: Inductive proofs&quot;" data-pltdoc="x">next →</a></span>&nbsp;
</div>
</div>
</div>
<div id="contextindicator">
&nbsp;
</div>
</body>
</html>
