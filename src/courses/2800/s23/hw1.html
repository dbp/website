<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3.1&nbsp;Homework 1</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{â€¦}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="notes.html" class="tocviewlink" data-pltdoc="x">Notes</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="homework.html" class="tocviewselflink" data-pltdoc="x">Homework</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>3&nbsp;</td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 1</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="hw2.html" class="tocviewlink" data-pltdoc="x">Homework 2</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td>3.1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 1</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1.1&nbsp;</td><td><a href="#%28part._.Problem_1%29" class="tocviewlink" data-pltdoc="x">Problem 1</a></td></tr><tr><td align="right">3.1.2&nbsp;</td><td><a href="#%28part._.Problem_2%29" class="tocviewlink" data-pltdoc="x">Problem 2</a></td></tr><tr><td align="right">3.1.3&nbsp;</td><td><a href="#%28part._.Problem_3%29" class="tocviewlink" data-pltdoc="x">Problem 3</a></td></tr><tr><td align="right">3.1.4&nbsp;</td><td><a href="#%28part._.Problem_4%29" class="tocviewlink" data-pltdoc="x">Problem 4</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Problem_1%29" class="tocsubseclink" data-pltdoc="x">Problem 1</a></td></tr><tr><td><span class="tocsublinknumber">3.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Problem_2%29" class="tocsubseclink" data-pltdoc="x">Problem 2</a></td></tr><tr><td><span class="tocsublinknumber">3.1.3<tt>&nbsp;</tt></span><a href="#%28part._.Problem_3%29" class="tocsubseclink" data-pltdoc="x">Problem 3</a></td></tr><tr><td><span class="tocsublinknumber">3.1.4<tt>&nbsp;</tt></span><a href="#%28part._.Problem_4%29" class="tocsubseclink" data-pltdoc="x">Problem 4</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.6</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="homework.html" title="backward to &quot;3 Homework&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="homework.html" title="up to &quot;3 Homework&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="hw2.html" title="forward to &quot;3.2 Homework 2&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>3.1<tt>&nbsp;</tt><a name="(part._hw1)"></a>Homework 1</h4><h5>3.1.1<tt>&nbsp;</tt><a name="(part._.Problem_1)"></a>Problem 1</h5><p>We can express propositional logic using boolean functions in ISL w/ Lambda, a
language you are familiar with from Fundamentals 1. Most are built in, but some
we will define. See the following table, which lists the logical operator and
the corresponding ISL function (or definition, if it&rsquo;s not built in).</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>operator in logic</p></td><td style="border-bottom: 1px solid black;"><p>operator in ISL w/ Lambda</p></td></tr><tr><td><p><span class="texMathInline">\land</span></p></td><td><p>and</p></td></tr><tr><td><p><span class="texMathInline">\lor</span></p></td><td><p>or</p></td></tr><tr><td><p><span class="texMathInline">\neg</span></p></td><td><p>not</p></td></tr><tr><td><p><span class="texMathInline">\Rightarrow</span></p></td><td><p>(lambda (P Q) (and P (not Q)))</p></td></tr><tr><td><p><span class="texMathInline">\equiv</span></p></td><td><p>boolean=?</p></td></tr><tr><td><p><span class="texMathInline">\otimes</span></p></td><td><p>(lambda (P Q) (or (and P (not Q)) (and Q (not P))))</p></td></tr><tr><td><p><span class="texMathInline">ite</span></p></td><td><p>if</p></td></tr></table></p><p>For example, <span class="texMathInline">P \land Q</span> can be expressed as the following function:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">and</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Translate the following expressions in logic into corresponding function definitions,
named <span class="RktSym">p2</span><span class="RktMeta"></span>,<span class="RktSym">p3</span><span class="RktMeta"></span>, <span class="RktSym">p4</span><span class="RktMeta"></span>. Note that the number (and names) of arguments
may be different for the different expressions, as they do not all use the same variables.</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>definition name</p></td><td style="border-bottom: 1px solid black;"><p>logical expression</p></td></tr><tr><td><p><span class="RktSym">p2</span><span class="RktMeta"></span></p></td><td><p><span class="texMathInline">(P \land Q) \lor \neg (R \land S)</span></p></td></tr><tr><td><p><span class="RktSym">p3</span><span class="RktMeta"></span></p></td><td><p><span class="texMathInline">P \Rightarrow \neg Q</span></p></td></tr><tr><td><p><span class="RktSym">p4</span><span class="RktMeta"></span></p></td><td><p><span class="texMathInline">\neg (P \land Q) \equiv \neg P \lor \neg Q</span></p></td></tr></table></p><h5>3.1.2<tt>&nbsp;</tt><a name="(part._.Problem_2)"></a>Problem 2</h5><p>Just as we can express propositional logical statements as code, we can also express proofs about propositional logic in code.
These proofs are often written as truth tables, with the goal to show that a given expression is always true (or maybe is never true)
regardless of the assignment of variables. You can do this by enumerating, in a table, all possible assignments of variables.</p><p>For example, if we wanted to know that <span class="texMathInline">P \land \neg P</span> is false or <span style="font-style: italic">unsatisfiable</span> (i.e., for all possible assignments of
variables, the result in false), we can define the following truth table to prove it:</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span class="texMathInline">P</span></p></td><td style="border-bottom: 1px solid black;"><p><span class="texMathInline">P  \land \neg P</span></p></td></tr><tr><td><p><span class="texMathInline">T</span></p></td><td><p><span class="texMathInline">F</span></p></td></tr><tr><td><p><span class="texMathInline">F</span></p></td><td><p><span class="texMathInline">F</span></p></td></tr></table></p><p>Here we see, regardless of whether we assign <span class="texMathInline">T</span> or <span class="texMathInline">F</span> to <span class="texMathInline">P</span>, our expression ends up <span class="texMathInline">F</span>.</p><p>To do this in code, we can express each row of the truth table as a unit test. We can define the above expression as:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">and</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>And then write the two lines of the truth table:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This then corresponds to a proof that is <span style="font-style: italic">verified</span> by running those tests. If one of our cases were wrong, we would
get a test failure.</p><p>For this problem, you should prove that the two following equalities (these are De Morgan&rsquo;s Laws) hold for all
possible assignments (i.e., are <span style="font-style: italic">valid</span>) by first defining them (<span class="RktSym">p5</span><span class="RktMeta"></span> and <span class="RktSym">p6</span><span class="RktMeta"></span>)
and then defining their truth tables using <span class="stt">check-expect</span>.
<span style="font-style: italic">Remember to include all possible combinations of inputs!</span></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>equation name</p></td><td style="border-bottom: 1px solid black;"><p>logical expression</p></td></tr><tr><td><p><span class="RktSym">p5</span><span class="RktMeta"></span></p></td><td><p><span class="texMathInline">\neg (P \land Q) \equiv \neg P \lor \neg Q</span></p></td></tr><tr><td><p><span class="RktSym">p6</span><span class="RktMeta"></span></p></td><td><p><span class="texMathInline">\neg (P \lor Q) \equiv \neg P \land \neg Q</span></p></td></tr></table></p><h5>3.1.3<tt>&nbsp;</tt><a name="(part._.Problem_3)"></a>Problem 3</h5><p>We&rsquo;ve seen that logical implication (<span class="texMathInline">\Rightarrow</span>) can be defined in
terms of <span class="texMathInline">\land</span> and <span class="texMathInline">\neg</span> (including in the table in Problem 1).</p><p>It turns out, there are many cases when you can define one operator in
terms of another.</p><p>In this exercise, for each operator, define a version of if in terms of just <span class="RktSym">if</span><span class="RktMeta"></span>. For example,
<span class="texMathInline">\neg P</span>, would be represented as <span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">op_neg</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span>. You are welcome to validate your
encodings using tests, but you are not required.</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>operator</p></td><td style="border-bottom: 1px solid black;"><p>definition name</p></td></tr><tr><td><p><span class="texMathInline">\land</span></p></td><td><p><span class="RktSym">op_and</span><span class="RktMeta"></span></p></td></tr><tr><td><p><span class="texMathInline">\lor</span></p></td><td><p><span class="RktSym">op_or</span><span class="RktMeta"></span></p></td></tr><tr><td><p><span class="texMathInline">\Rightarrow</span></p></td><td><p><span class="RktSym">op_implies</span><span class="RktMeta"></span></p></td></tr><tr><td><p><span class="texMathInline">\equiv</span></p></td><td><p><span class="RktSym">op_equal</span><span class="RktMeta"></span></p></td></tr><tr><td><p><span class="texMathInline">\otimes</span></p></td><td><p><span class="RktSym">op_xor</span><span class="RktMeta"></span></p></td></tr></table></p><h5>3.1.4<tt>&nbsp;</tt><a name="(part._.Problem_4)"></a>Problem 4</h5><p>Simplifying propositional formulas is an important topic, as simpler formulas, especially if they have fewer variables,
are easier to check for validity (truth), unsatisfiability (falsehood), etc.</p><p>For example, if I have the expression <span class="texMathInline">P \land (Q \lor \neg Q)</span>, we can see that the
subexpression <span class="texMathInline">Q \lor \neg Q</span> will always be true, no matter the assignment of <span class="texMathInline">Q</span>, and thus we
could first simplify this to <span class="texMathInline">P \land T</span>. But since <span class="texMathInline">P \land T</span> is equivalent to just <span class="texMathInline">P</span>,
we can further simplify.</p><p>In code, what this means is that the function:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">and</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">or</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Q</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Is equivalent to the function:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">P</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>And we can check that using a truth table, which has four rows since there are two variables.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">p7s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Here we left <span class="RktSym">Q</span><span class="RktMeta"></span> as an input to <span class="RktSym">p7s</span><span class="RktMeta"></span> to make it obvious that the truth table test is showing they are equivalent
on all inputs. Note that it is of course equivalent to a function that does not have the extra argument, but the truth table may
be harder to understand, so for this problem, we will write our simplified versions in this more verbose form, even when we can
eliminate variables.</p><p>Your task, in this problem, is to perform simplifications of this form for the three problems below, and include
truth tables that confirm that your simplifications were correct. We are giving you the
expressions written both in logical syntax and in the ISL code that we expect you to simplify &amp; test with.</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>expression</p></td><td style="border-bottom: 1px solid black;"><p>in code</p></td><td style="border-bottom: 1px solid black;"><p>your simplified version</p></td></tr><tr><td><p><span class="texMathInline">(P \land Q) \land (P \land \neg Q)</span></p></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p9</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p9s</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><p><span class="texMathInline">(P \land Q \land P) \lor (Q \land R)</span></p></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p10</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p10s</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr><tr><td><p><span class="texMathInline">(P \land Q \land R) \lor (\neg Q \land S \land Q)</span></p></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p11</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="hspace">&nbsp;</span><span class="RktSym">S</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">S</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></td><td><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p11s</span><span class="hspace">&nbsp;</span><span class="RktSym">P</span><span class="hspace">&nbsp;</span><span class="RktSym">Q</span><span class="hspace">&nbsp;</span><span class="RktSym">R</span><span class="hspace">&nbsp;</span><span class="RktSym">S</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr></table></blockquote></td></tr></table></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="homework.html" title="backward to &quot;3 Homework&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="homework.html" title="up to &quot;3 Homework&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="hw2.html" title="forward to &quot;3.2 Homework 2&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>