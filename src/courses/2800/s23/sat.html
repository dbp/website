<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2.4&nbsp;Rosette 1: SAT &amp; SMT</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="notes.html" class="tocviewselflink" data-pltdoc="x">Notes</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td>2&nbsp;</td><td><a href="notes.html" class="tocviewlink" data-pltdoc="x">Notes</a></td></tr></table><div class="tocviewsublistbottom" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="propositional.html" class="tocviewlink" data-pltdoc="x">Propositional Logic</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="recipe.html" class="tocviewlink" data-pltdoc="x">Design/<span class="mywbr"> &nbsp;</span>Specification Recipe</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="pbt_specification.html" class="tocviewlink" data-pltdoc="x">Property Based Testing</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Rosette 1:<span class="mywbr"> &nbsp;</span> SAT &amp; SMT</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="proof.html" class="tocviewlink" data-pltdoc="x">Lean 1:<span class="mywbr"> &nbsp;</span> What is Proof</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.6</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="pbt_specification.html" title="backward to &quot;2.3 Property Based Testing&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="notes.html" title="up to &quot;2 Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="proof.html" title="forward to &quot;2.5 Lean 1: What is Proof&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>2.4<tt>&nbsp;</tt><a name="(part._sat)"></a>Rosette 1: SAT &amp; SMT</h4><p>Up until now, our sole method for taking a specification and checking that it is
satisfied has been property-based testing (PBT). While PBT is certainly an
incredibly important and useful tool from formal methods, and indeed, is a tool
that you can adapt to nearly any setting in which you are working, it is not the
only one, and it has some flaws. The main one is that it relies upon the random
sampling doing a good job of covering <span style="font-style: italic">representative</span> cases relevant to
your property.</p><p>There are two ways that this can be limiting. The first is that it may be that
the space is huge, and the bugs only show up in particular edge cases: ideally,
the random generation knows about common edge cases (e.g., empty lists, the
number 0, etc), but what if the edge case for your function was the number 117?
If a PBT framework is generating random 32bit or 64bit numbers, there is a very
small chance it&rsquo;ll hit 117. The other potential problem is a bit more difficult,
though perhaps more obvious: some properties have preconditions, and that is
often handled by generating data and dropping examples that don&rsquo;t satisfy the
precondition.&#160;For example, you may have functions that operate over balanced
binary search trees, but your generators are just giving you random binary
trees, and you only run the test when you get balanced binary search trees. But
these may be quite rare, so you could generate thousands of candidates and drop
all but a few, which is not a great way of getting good coverage.</p><p>The next formal methods technique that we&rsquo;re going to explore allows us to do a
bit better, and it relies upon a very old problem in computer science: SAT.</p><p>The SAT problem is the following: given a boolean formula, is there an
assignment of variables that makes the formula true. e.g.,</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(P \/ Q) /\ (~P \/ ~Q)</span></p></td></tr></table></p><p>Is satisfiable, which we can convince ourselves of, among other ways, by way of a truth table:</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>P</p></td><td style="border-bottom: 1px solid black;"><p>Q</p></td><td style="border-bottom: 1px solid black;"><p>(P \/ Q) /\ (~P \/ ~Q)</p></td></tr><tr><td><p>T</p></td><td><p>T</p></td><td><p>F</p></td></tr><tr><td><p>T</p></td><td><p>F</p></td><td><p>T</p></td></tr><tr><td><p>F</p></td><td><p>T</p></td><td><p>T</p></td></tr><tr><td><p>F</p></td><td><p>F</p></td><td><p>F</p></td></tr></table></p><p>Now, if you think about the problem for a bit, you&rsquo;ll realize that the size of
the truth table would have to have <span class="stt">2^n</span> rows, where <span class="stt">n</span> is the number of
variables, which is going to become quite intractable quite fast. But, you might
also suspect that there are shortcuts you could make based on the structure of
the formula to not have to enumerate and compute every single one of those
assignments. And indeed, people have been working on this problem for decades.
It is both an incredibly important problem theoretically, but in more recent
time, has become very important practically, as there are now solvers for this
problem that are much much more efficient than the naive exponential approach
(and more importantly, the generalized SMT problem where the variables can be
something other than booleans).</p><p>How does this help? And why are SMT solvers an important topic? Well, it turns
out that if we are careful, we can <span style="font-style: italic">translate</span> lots of problems we care
about into SAT (or SMT), such that whether or not there is an assignment that
makes the formula true (so whether it is <span style="font-style: italic">satisfiable</span>) is the true if
and only if the property we care about in our original problem holds.</p><p>How exactly those translations (sometimes called reductions) work is beyond this
class&#8212;<wbr></wbr>it likely will come up, at least in passing, in an algorithms class, and
you can certainly study more about SMT solvers specifically, but we are going to
use a particular system called Rosette that is able to translate large portions
of a subset of the Racket programming language (that corresponds pretty close to
ISL) into a form understandable to the SMT solvers. What Rosette is doing is a
little more complicated, as it doesn&rsquo;t actually translate the whole program, but
rather, it runs portions of the program (using a technique called partial
evaluation) and only sends to the SMT solver what is actually necessary, but for
our purposes, we can treat it as though it is translating the entire
specification so that the SMT solver (in this case, Z3) can understand it.</p><p>Let&rsquo;s see how this works. First, we need to install the <span class="stt">rosette</span> package,
which you can do within DrRacket by <span class="stt">File-&gt;Install Package</span>, putting
<span class="stt">rosette</span> as the package name and clicking <span class="stt">Install</span>.</p><p>Then, let&rsquo;s write a simple program. We&rsquo;ll define a property and then test it
first using PBT and then using Rosette. This is our first encounter, so is
intended to be tiny, and is certainly something we could have handled with PBT
(or with simple unit tests); we&rsquo;ll get to more complicated examples soon. The
complete program is below. Be sure you have
chosen "Determine language from source" at the bottom left of DrRacket, so it&rsquo;ll
recognize that we are using Rosette from the first line.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">0</span><span class="hspace">&nbsp;</span></span></span><font class="badlink"><span class="RktModLink"><span class="RktMod">#lang</span></span></font><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><font class="badlink"><span class="RktModLink"><span class="RktSym">rosette/safe</span></span></font><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">1</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">2</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">require</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">quickcheck</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">3</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">4</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">bnot</span><span class="hspace">&nbsp;</span><span class="RktCmt">:</span><span class="hspace">&nbsp;</span><span class="RktCmt">Boolean</span><span class="hspace">&nbsp;</span><span class="RktCmt">-&gt;</span><span class="hspace">&nbsp;</span><span class="RktCmt">Boolean</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">5</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bnot</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">6</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">7</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">8</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bnot-prop</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="hspace">&nbsp;</span><span class="stt">9</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bnot</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="stt">10</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="stt">11</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">quickcheck</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">property</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">arbitrary-boolean</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bnot-prop</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="stt">12</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="stt">13</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">define-symbolic</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">boolean?</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="Smaller"><span class="Smaller"><span class="stt">14</span><span class="hspace">&nbsp;</span></span></span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">verify</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">assert</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">bnot-prop</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>If you run this, you notice two things are printed in the interactions window:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">OK, passed 100 tests.</span></p></td></tr><tr><td><p><span class="stt">(unsat)</span></p></td></tr></table></p><p>The first, which you are familiar with, is the output from <span class="RktSym">quickcheck</span><span class="RktMeta"></span>,
which showed that the property held. This should be obvious: the property, which
is actually a total correctness property on <span class="RktSym">not</span><span class="RktMeta"></span>, is that not applied to a
boolean returns a different boolean. We only actually need to test this on
<span class="RktVal">#t</span><span class="RktMeta"></span> and <span class="RktVal">#f</span><span class="RktMeta"></span>, but doing more tests is fine.</p><p>The second line is the output from Rosette, which corresponds to the <span class="RktSym">verify</span><span class="RktMeta"></span>
expression on line <span class="stt">14</span>. Rosette can do several things, but the one that
we will use in this class is verify that particular properties hold. In this
case, we want to <span class="RktSym">assert</span><span class="RktMeta"></span> that the <span class="RktSym">bnot-prop</span><span class="RktMeta"></span> holds on an arbitrary
boolean <span class="RktSym">b1</span><span class="RktMeta"></span>. Symbolic values become variables in queries that are passed to
the SMT solver; in this case, we have only one, <span class="RktSym">b1</span><span class="RktMeta"></span>. What <span class="RktSym">verify</span><span class="RktMeta"></span> does
is attemp to find a counter-example to the query it is given; in this case, the
assertion that <span class="RktSym">bnot-prop</span><span class="RktMeta"></span> should hold on the symbolic value <span class="RktSym">b1</span><span class="RktMeta"></span>.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="pbt_specification.html" title="backward to &quot;2.3 Property Based Testing&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="notes.html" title="up to &quot;2 Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="proof.html" title="forward to &quot;2.5 Lean 1: What is Proof&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>