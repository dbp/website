<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 29: Functions vs. Relations</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="minted.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default"/><link rel="stylesheet" type="text/css" href="main.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr><tr><td align="right"></td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Lean Tactic Reference</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a></td></tr><tr><td align="right"></td><td><a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a></td></tr><tr><td align="right"></td><td><a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a></td></tr><tr><td align="right"></td><td><a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a></td></tr><tr><td align="right"></td><td><a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a></td></tr><tr><td align="right"></td><td><a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr></wbr>all, Intro to PBT</a></td></tr><tr><td align="right"></td><td><a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a></td></tr><tr><td align="right"></td><td><a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a></td></tr><tr><td align="right"></td><td><a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a></td></tr><tr><td align="right"></td><td><a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a></td></tr><tr><td align="right"></td><td><a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a></td></tr><tr><td align="right"></td><td><a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a></td></tr><tr><td align="right"></td><td><a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a></td></tr><tr><td align="right"></td><td><a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a></td></tr><tr><td align="right"></td><td><a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a></td></tr><tr><td align="right"></td><td><a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a></td></tr><tr><td align="right"></td><td><a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a></td></tr><tr><td align="right"></td><td><a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a></td></tr><tr><td align="right"></td><td><a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a></td></tr><tr><td align="right"></td><td><a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a></td></tr><tr><td align="right"></td><td><a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span>  Proof Practice</a></td></tr><tr><td align="right"></td><td><a href="l22.html" class="tocviewlink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a></td></tr><tr><td align="right"></td><td><a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Generalize</a></td></tr><tr><td align="right"></td><td><a href="l24.html" class="tocviewlink" data-pltdoc="x">Lecture 24:<span class="mywbr"> &nbsp;</span> Standard Libraries</a></td></tr><tr><td align="right"></td><td><a href="l25.html" class="tocviewlink" data-pltdoc="x">Lecture 25:<span class="mywbr"> &nbsp;</span> Forward Reasoning</a></td></tr><tr><td align="right"></td><td><a href="l26.html" class="tocviewlink" data-pltdoc="x">Lecture 26:<span class="mywbr"> &nbsp;</span> Proof Automation</a></td></tr><tr><td align="right"></td><td><a href="l27.html" class="tocviewlink" data-pltdoc="x">Lecture 27:<span class="mywbr"> &nbsp;</span> Compiler Correctness</a></td></tr><tr><td align="right"></td><td><a href="l28.html" class="tocviewlink" data-pltdoc="x">Lecture 28:<span class="mywbr"> &nbsp;</span> Induction</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 29:<span class="mywbr"> &nbsp;</span> Functions vs. Relations</a></td></tr><tr><td align="right"></td><td><a href="l30.html" class="tocviewlink" data-pltdoc="x">Lecture 30:<span class="mywbr"> &nbsp;</span> Why logic?</a></td></tr><tr><td align="right"></td><td><a href="l31.html" class="tocviewlink" data-pltdoc="x">Lecture 31:<span class="mywbr"> &nbsp;</span> Linear Logic</a></td></tr><tr><td align="right"></td><td><a href="l32.html" class="tocviewlink" data-pltdoc="x">Lecture 32</a></td></tr><tr><td align="right"></td><td><a href="l33.html" class="tocviewlink" data-pltdoc="x">Lecture 33</a></td></tr><tr><td align="right"></td><td><a href="l34.html" class="tocviewlink" data-pltdoc="x">Lecture 34</a></td></tr><tr><td align="right"></td><td><a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a></td></tr><tr><td align="right"></td><td><a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a></td></tr><tr><td align="right"></td><td><a href="l37.html" class="tocviewlink" data-pltdoc="x">Lecture 37</a></td></tr><tr><td align="right"></td><td><a href="l38.html" class="tocviewlink" data-pltdoc="x">Lecture 38</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 29:<span class="mywbr"> &nbsp;</span> Functions vs. Relations</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Functions%29" class="tocviewlink" data-pltdoc="x">Functions</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Relations%29" class="tocviewlink" data-pltdoc="x">Relations</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Relations%29" class="tocsubseclink" data-pltdoc="x">Relations</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l28.html" title="backward to &quot;Lecture 28: Induction&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l30.html" title="forward to &quot;Lecture 30: Why logic?&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._l29)"></a>Lecture 29: Functions vs. Relations</h4><h5>1<tt>&nbsp;</tt><a name="(part._.Purpose)"></a>Purpose</h5><p>Explore functions vs. relations.</p><h5>2<tt>&nbsp;</tt><a name="(part._.Outline)"></a>Outline</h5><p>You&rsquo;ve written many functions in your programming career, and a bunch in this class. You&rsquo;ve also now seen quite a few "relations" in this class, which often capture similar ideas. e.g., we had an even function:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">even</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Bool</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span>  <span class="n">true</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">false</span>
<span class="bp">|</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">even</span> <span class="n">n</span>
</pre></div>
</div><p>And an even relation (we had another as well, but we&rsquo;ll get to that):</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">ev</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ev</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">SS</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">ev</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ev</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">))</span>
</pre></div>
</div><p>We talked (and proved) that the two were equivalent by showing that if you had one you could get the other, e.g., proved the following theorem:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">even_ev</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="n">even</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">true</span> <span class="bp">&lt;-&gt;</span> <span class="n">ev</span> <span class="n">n</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</pre></div>
</div><p>But how are they different, and how are they the same? That is the purpose of this lecture.</p><h5>3<tt>&nbsp;</tt><a name="(part._.Functions)"></a>Functions</h5><p>First, we need to be more formal about what a function is. Mathematically (and the functions in Lean are <span style="font-style: italic">mathematical functions</span>, i.e., given the same input, they always return the same output), a function is a mapping from inputs to outputs. Another way of stating that is that it is a (potentially infinite) set of input-output pairs, with the restriction that for any input, there is only one output (as calling a function on a particular input can only give you <span style="font-style: italic">one</span> output).</p><p>e.g., we could characterize even as:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">0, true</span></p></td></tr><tr><td><p><span class="stt">1, false</span></p></td></tr><tr><td><p><span class="stt">2, true</span></p></td></tr><tr><td><p><span class="stt">3, false</span></p></td></tr><tr><td><p><span class="stt">4, true</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><p>Where we would have to give infinite pairs.</p><p>We can do this for any finction. For example, the factorial function:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">factorial</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> 
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">factorial</span> <span class="n">n</span>
</pre></div>
</div><p>Could also be defined as:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">0,1</span></p></td></tr><tr><td><p><span class="stt">1,1</span></p></td></tr><tr><td><p><span class="stt">2,2</span></p></td></tr><tr><td><p><span class="stt">3,6</span></p></td></tr><tr><td><p><span class="stt">4,24</span></p></td></tr><tr><td><p><span class="stt">5,120</span></p></td></tr><tr><td><p><span class="stt">...</span></p></td></tr></table></p><h5>4<tt>&nbsp;</tt><a name="(part._.Relations)"></a>Relations</h5><p>So what is a relation? A relation is a generalization of a function, in that it does not have the restriction that there is only a single output for a given input. Instead, it is a set of niput-output pairs, where there can be multiple outputs for a given input. So any function <span style="font-style: italic">is</span> as relation, but some relations are not functions. More concisely, you can think of a relation as a connection between inputs and outputs. One way you might get to a relation is by defining a function, and then making the function <span style="font-style: italic">nondeterministic</span>, i.e., allow it to potentially return different outputs for the same input.</p><p>How can we represent relations? Well, in any language we can represent a relation as a predicate (boolean returning function) on pairs (of input-output). e.g., a relation for even could be:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">even_rel</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">×</span> <span class="n">Bool</span> <span class="bp">-&gt;</span> <span class="n">Bool</span> 
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">==</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">false</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">n</span> <span class="bp">%</span> <span class="mi">2</span> <span class="bp">==</span> <span class="mi">1</span>
</pre></div>
</div><p>Or we could represent the factorial relation as:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">factorial_rel</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">×</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Bool</span> 
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">factorial</span> <span class="n">n</span> <span class="bp">==</span> <span class="n">m</span>
</pre></div>
</div><p>The latter being a bit circular, but a valid definition.</p><p>But in Lean, we have another way of representing relation that turns out to be really useful when we are writing proofs. Rather than writing them as functions that take pairs and return booleans, we can define them as inductive types.</p><p>This is useful because if we are trying to prove something about, e.g., the factorial function, if we have the function, all we know is the input and output: the structure of the code is opaque. But if we represent it as an relation, and encode that as an inductive type, then the structure of the computation corresponds to the constructors of the indpuctive type. We can do case analysis, induction, etc. We&rsquo;ve seen the <span class="default"><code class="highlight-inline"><span class="n">ev</span></code></span> relation many times, so let&rsquo;s do one for <span class="default"><code class="highlight-inline"><span class="n">factorial</span></code></span> instead:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">fact</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">O</span> <span class="o">:</span> <span class="n">fact</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="bp">|</span> <span class="n">S</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">fact</span> <span class="n">n</span> <span class="n">m</span><span class="o">)</span> <span class="o">:</span> <span class="n">fact</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="o">((</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">*</span> <span class="n">m</span><span class="o">)</span>
</pre></div>
</div><p>Now, why does that relation mean the same thing? And in general, why does this approach work? Rather than proving it (which we&rsquo;ll do later), let&rsquo;s look at how the <span class="default"><code class="highlight-inline"><span class="n">factorial</span></code></span> function evaluates. e.g., <span class="default"><code class="highlight-inline"><span class="n">factorial</span> <span class="mi">4</span></code></span>:</p><div class="default"><div class="highlight"><pre><span></span><span class="n">factorial</span> <span class="mi">4</span> <span class="bp">=</span>
<span class="mi">4</span> <span class="bp">*</span> <span class="n">factorial</span> <span class="mi">3</span> <span class="bp">=</span>
<span class="mi">4</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">*</span> <span class="n">factorial</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">=</span>
<span class="mi">4</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="n">factorial</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span>
<span class="mi">4</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">factorial</span> <span class="mi">0</span><span class="o">))</span> <span class="bp">=</span>
<span class="mi">4</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">3</span> <span class="bp">*</span> <span class="o">(</span><span class="mi">2</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">=</span> <span class="mi">24</span>
</pre></div>
</div><p>Now, we know this, and we can confirm that we got from the beginning to the end by running <span class="default"><code class="highlight-inline"><span class="k">#eval</span> <span class="n">factorial</span> <span class="mi">4</span></code></span>, but if we are trying to prove something about the factorial function, e.g., we have a hypotheses <span class="default"><code class="highlight-inline"><span class="n">factorial</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span></code></span>, there is no way to extract that <span style="font-style: italic">structure</span> from the hypothesis.</p><p>Now, let&rsquo;s look at the same thing, but with the relation. In this case, we want to see how a value of type <span class="default"><code class="highlight-inline"><span class="n">fact</span> <span class="mi">4</span> <span class="mi">24</span></code></span> is constructured: i.e., how we construct a proof that the pair <span style="font-style: italic">(4, 24)</span> is in the factorial relation.</p><div class="default"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="n">fact.S</span> <span class="mi">3</span> <span class="n">_</span> <span class="o">(</span><span class="n">fact.S</span> <span class="mi">2</span> <span class="n">_</span> <span class="o">(</span><span class="n">fact.S</span> <span class="mi">1</span> <span class="n">_</span> <span class="o">(</span><span class="n">fact.S</span> <span class="mi">0</span> <span class="n">_</span> <span class="n">fact.O</span><span class="o">)))</span> <span class="o">:</span> <span class="n">fact</span> <span class="mi">4</span> <span class="mi">24</span><span class="o">)</span>
</pre></div>
</div><p>We can see that the <span style="font-style: italic">term</span> is a sequence of constructors, each of which is a step in the computation: the same steps as we see above when we wrote out how <span class="default"><code class="highlight-inline"><span class="n">factorial</span></code></span> evaluated, but unlike something on paper, this is an actual value we can use in our proofs.</p><p>To see this, and to see how this structure can be useful in our proofs, lets show that the two representations are equivalent. One direction (going from the inductive) ends up being easier, because the inductive relation contains so much more structure we can make use of in our proof:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">fact_factorial</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">fact</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">&lt;-&gt;</span> <span class="n">factorial</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">m</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">m</span>
    <span class="n">apply</span> <span class="n">Iff.intro</span>
    <span class="n">case</span> <span class="n">mp</span> <span class="bp">=&gt;</span>
      <span class="n">intros</span> <span class="n">H</span>
      <span class="n">induction</span> <span class="n">H</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">factorial</span><span class="o">,</span> <span class="bp">*</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">mpr</span> <span class="bp">=&gt;</span>
      <span class="n">intros</span> <span class="n">H</span>
      <span class="n">revert</span> <span class="n">m</span>
      <span class="n">induction</span> <span class="n">n</span> <span class="bp">&lt;;&gt;</span> <span class="n">intros</span> <span class="n">m</span> <span class="n">H</span>
      <span class="n">case</span> <span class="n">zero</span> <span class="bp">=&gt;</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">factorial</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">H</span><span class="o">]</span>
        <span class="n">constructor</span>
      <span class="n">case</span> <span class="n">succ</span> <span class="n">n</span> <span class="n">IH</span> <span class="bp">=&gt;</span>
        <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">factorial</span><span class="o">]</span> <span class="n">at</span> <span class="n">H</span>
        <span class="n">rw</span> <span class="o">[</span><span class="bp">&lt;-</span> <span class="n">H</span><span class="o">]</span>
        <span class="n">constructor</span>
        <span class="n">apply</span> <span class="n">IH</span>
        <span class="n">rfl</span>
</pre></div>
</div><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l28.html" title="backward to &quot;Lecture 28: Induction&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l30.html" title="forward to &quot;Lecture 30: Why logic?&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>