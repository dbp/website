<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 22: Generalizing hypotheses</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default"/><link rel="stylesheet" type="text/css" href="main.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr><tr><td align="right"></td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Lean Tactic Reference</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a></td></tr><tr><td align="right"></td><td><a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a></td></tr><tr><td align="right"></td><td><a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a></td></tr><tr><td align="right"></td><td><a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a></td></tr><tr><td align="right"></td><td><a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a></td></tr><tr><td align="right"></td><td><a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr></wbr>all, Intro to PBT</a></td></tr><tr><td align="right"></td><td><a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a></td></tr><tr><td align="right"></td><td><a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a></td></tr><tr><td align="right"></td><td><a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a></td></tr><tr><td align="right"></td><td><a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a></td></tr><tr><td align="right"></td><td><a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a></td></tr><tr><td align="right"></td><td><a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a></td></tr><tr><td align="right"></td><td><a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a></td></tr><tr><td align="right"></td><td><a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a></td></tr><tr><td align="right"></td><td><a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a></td></tr><tr><td align="right"></td><td><a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a></td></tr><tr><td align="right"></td><td><a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a></td></tr><tr><td align="right"></td><td><a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a></td></tr><tr><td align="right"></td><td><a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a></td></tr><tr><td align="right"></td><td><a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a></td></tr><tr><td align="right"></td><td><a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span>  Proof Practice</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a></td></tr><tr><td align="right"></td><td><a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Generalize</a></td></tr><tr><td align="right"></td><td><a href="l24.html" class="tocviewlink" data-pltdoc="x">Lecture 24:<span class="mywbr"> &nbsp;</span> Standard Libraries</a></td></tr><tr><td align="right"></td><td><a href="l25.html" class="tocviewlink" data-pltdoc="x">Lecture 25:<span class="mywbr"> &nbsp;</span> Forward Reasoning</a></td></tr><tr><td align="right"></td><td><a href="l26.html" class="tocviewlink" data-pltdoc="x">Lecture 26:<span class="mywbr"> &nbsp;</span> Proof Automation</a></td></tr><tr><td align="right"></td><td><a href="l27.html" class="tocviewlink" data-pltdoc="x">Lecture 27:<span class="mywbr"> &nbsp;</span> Compiler Correctness</a></td></tr><tr><td align="right"></td><td><a href="l28.html" class="tocviewlink" data-pltdoc="x">Lecture 28:<span class="mywbr"> &nbsp;</span> Induction</a></td></tr><tr><td align="right"></td><td><a href="l29.html" class="tocviewlink" data-pltdoc="x">Lecture 29:<span class="mywbr"> &nbsp;</span> Functions vs. Relations</a></td></tr><tr><td align="right"></td><td><a href="l30.html" class="tocviewlink" data-pltdoc="x">Lecture 30:<span class="mywbr"> &nbsp;</span> Why logic?</a></td></tr><tr><td align="right"></td><td><a href="l31.html" class="tocviewlink" data-pltdoc="x">Lecture 31:<span class="mywbr"> &nbsp;</span> Linear Logic</a></td></tr><tr><td align="right"></td><td><a href="l32.html" class="tocviewlink" data-pltdoc="x">Lecture 32</a></td></tr><tr><td align="right"></td><td><a href="l33.html" class="tocviewlink" data-pltdoc="x">Lecture 33</a></td></tr><tr><td align="right"></td><td><a href="l34.html" class="tocviewlink" data-pltdoc="x">Lecture 34</a></td></tr><tr><td align="right"></td><td><a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a></td></tr><tr><td align="right"></td><td><a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a></td></tr><tr><td align="right"></td><td><a href="l37.html" class="tocviewlink" data-pltdoc="x">Lecture 37</a></td></tr><tr><td align="right"></td><td><a href="l38.html" class="tocviewlink" data-pltdoc="x">Lecture 38</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l21.html" title="backward to &quot;Lecture 21:  Proof Practice&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l23.html" title="forward to &quot;Lecture 23: Generalize&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._l22)"></a>Lecture 22: Generalizing hypotheses</h4><h5>1<tt>&nbsp;</tt><a name="(part._.Purpose)"></a>Purpose</h5><p>Explore how to construct proofs when the induction hypotheses are too weak.</p><h5>2<tt>&nbsp;</tt><a name="(part._.Outline)"></a>Outline</h5><p>In HW2, we defined a compiler from <span class="RktSym">AddExpressions</span><span class="RktMeta"></span> to a stack
of <span class="RktSym">Instr</span><span class="RktMeta"></span>s: i.e., a simple stack-based calculator. Today, we&rsquo;ll
recreate that example in Lean, and this time, prove it correct.</p><p>Here, we define an inductive type for <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span>, and a function
to evaluate them. I&rsquo;m showing a naming convenience that Lean has here,
where if you have a value <span class="default"><code class="highlight-inline"><span class="n">v</span></code></span> of type <span class="default"><code class="highlight-inline"><span class="n">foo</span></code></span>, if you write
<span class="default"><code class="highlight-inline"><span class="n">v.bar</span></code></span>, Lean will look for a function called <span class="default"><code class="highlight-inline"><span class="n">foo.bar</span></code></span> and
call it on <span class="default"><code class="highlight-inline"><span class="n">v</span></code></span>. i.e., <span class="default"><code class="highlight-inline"><span class="n">v.bar</span></code></span> is shorthand for
<span class="default"><code class="highlight-inline"><span class="n">foo.bar</span> <span class="n">v</span></code></span>. That means that by writing <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span></code></span>, we
can write <span class="default"><code class="highlight-inline"><span class="n">e_1.eval</span></code></span> to mean <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span> <span class="n">e_1</span></code></span>. Also,
in the <span style="font-style: italic">definition</span> of <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span></code></span>, we can write
pattern matching cases <span style="font-style: italic">without</span> the <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span> prefix that
would normally be needed.</p><p>I&rsquo;ve also used subscripts &ndash; you can write them by typing <span class="RktSym">\_1</span><span class="RktMeta"></span>.</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">ArithExpr</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">(</span><span class="n">e₁</span> <span class="n">e₂</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">ArithExpr.eval</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="bp">=&gt;</span> <span class="n">e₁.eval</span> <span class="bp">+</span> <span class="n">e₂.eval</span>
</pre></div>
</div><p>Now, we need to implement our stack calculator, and translation (or compiler) to it.</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">Instr</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">push</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span>
<span class="kd">def</span> <span class="n">Instr.eval</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Instr</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="o">[],</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">s</span>
  <span class="bp">|</span> <span class="n">push</span> <span class="n">n</span> <span class="o">::</span> <span class="n">is</span><span class="o">,</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Instr.eval</span> <span class="n">is</span> <span class="o">(</span><span class="n">n</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">::</span> <span class="n">is</span><span class="o">,</span> <span class="n">n1</span> <span class="o">::</span> <span class="n">n2</span> <span class="o">::</span> <span class="n">s</span> <span class="bp">=&gt;</span> <span class="n">Instr.eval</span> <span class="n">is</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">::</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="o">[]</span>
</pre></div>
</div><p>As before, we define <span class="default"><code class="highlight-inline"><span class="n">instr</span></code></span> as either <span class="default"><code class="highlight-inline"><span class="n">push</span> <span class="n">n</span></code></span> or
<span class="default"><code class="highlight-inline"><span class="n">add</span></code></span>, and define an evaluation function for single instructions
and sequences of instructions.</p><p>Now finally, we define our compile function:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">ArithExpr.compile</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">→</span> <span class="n">List</span> <span class="n">Instr</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">[</span><span class="n">Instr.push</span> <span class="n">n</span><span class="o">]</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="bp">=&gt;</span> <span class="n">e₁.compile</span> <span class="bp">++</span> <span class="n">e₂.compile</span> <span class="bp">++</span> <span class="o">[</span><span class="n">Instr.add</span><span class="o">]</span>
</pre></div>
</div><p>Here I&rsquo;ve chosen to use <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span> as the <span style="font-style: italic">namespace</span> for
the function, as that is the <span style="font-style: italic">input</span> type, so I can write
<span class="default"><code class="highlight-inline"><span class="n">e_1.compile</span></code></span> to mean <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.compile</span> <span class="n">e_1</span></code></span>.</p><p>Now, we can prove that the compiler is correct. First, we write the
statement of compiler correctness, leaving the proof blank:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">compile_correct1</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</pre></div>
</div><p>This says exactly what we want: if we compile an expression, and then
run it, we get the same result as if we had evaluated the expression.
Let&rsquo;s see if we can prove it:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">compile_correct2</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
      <span class="gr">sorry</span>
</pre></div>
</div><p>We proceed by induction on the structure of our expressions, which makes sense, since they are inductive structures, and our compiler follows that structure.</p><p>We can prove the base case by unfolding the definitions of
compile and both evaluations. In the other case, we can do the same
unfoldings, but then things go wrong. Let&rsquo;s look carefully at where
we are stuck:</p><div class="default"><div class="highlight"><pre><span></span><span class="n">e₁</span> <span class="n">e₂</span><span class="o">:</span> <span class="n">ArithExpr</span>
<span class="n">ih₁</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span><span class="o">]</span>
<span class="n">ih₂</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
<span class="bp">⊢</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₁</span> <span class="bp">++</span> <span class="n">ArithExpr.compile</span> <span class="n">e₂</span> <span class="bp">++</span>
  <span class="o">[</span><span class="n">Instr.add</span><span class="o">])</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
</pre></div>
</div><p>The last lines show what we need to prove: that evaluating the result
of compiling <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span>, appended to each other followed
by <span class="default"><code class="highlight-inline"><span class="n">Instr.add</span></code></span>, is the same as evaluating <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">e₂</span></code></span>
and adding them. Seems reasonable enough, but we are stuck. The
problem is that our inductive hypotheses can&rsquo;t help us: they are
the only thing we know about <span class="default"><code class="highlight-inline"><span class="n">e₁</span></code></span> and <span class="default"><code class="highlight-inline"><span class="n">e₂</span></code></span>, but directly we
can&rsquo;t use them.</p><p>Often, when using an interactive theorem prover, its tempting to just
move forward, doing whatever seems like it might work. While for
simple proofs this may work, it&rsquo;s a bad idea in general. Instead,
whenever you aren&rsquo;t sure what the next step should be, stop and
think about why you are stuck, and why you think the theorem is true
(or not true) &ndash; use <span style="font-style: italic">that</span> to move forward.</p><p>Here, one of the problems is that
our obligation is about <span class="default"><code class="highlight-inline"><span class="n">Instr.eval</span></code></span>ing a bunch of things in
sequence, but our hypotheses are only about parts of that. We would
like to use the induction hypotheses to "step through" the evaluation.</p><p>Let&rsquo;s define an auxiliary lemma:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">instr_eval_app1</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">is</span> <span class="n">is&#39;</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Instr</span><span class="o">),</span>
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">is</span> <span class="bp">++</span> <span class="n">is&#39;</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> 
      <span class="n">Instr.eval</span> <span class="n">is&#39;</span> <span class="o">(</span><span class="n">Instr.eval</span> <span class="n">is</span> <span class="o">[])</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</pre></div>
</div><p>Now, at this point, we have two possibilities. We can either stop and
prove this new theorem, or we can <span style="font-style: italic">assume</span> that it is true, and
then use it to prove our original theorem, and then come back and prove
the auxiliary later, once you know its useful.</p><p>Which you do depends both
on your style, but also how much you trust the auxiliary lemma to be
true! If you do a bunch of work on the main theorem and then find out
the auxiliary lemma is false, you&rsquo;ve wasted a lot of time. On the other hand, if you do a bunch of work proving a helper lemma and it
turns out not to be what you need, you&rsquo;ve also wasted time!</p><p>Here, we&rsquo;re pretty sure that the lemma is true, so we&rsquo;ll come back to
prove it later. Let&rsquo;s see if it&rsquo;ll help us prove our theorem.</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">compile_correct3</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="bp">=&gt;</span> 
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app1</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app1</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih₁</span><span class="o">]</span>
      <span class="gr">sorry</span>
</pre></div>
</div><p>This seemed to help, but we&rsquo;re still stuck. Let&rsquo;s look at what we have:</p><div class="default"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="n">e₂</span><span class="o">:</span> <span class="n">ArithExpr</span>
<span class="n">ih₁</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₁</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span><span class="o">]</span>
<span class="n">ih₂</span><span class="o">:</span> <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
<span class="bp">⊢</span> <span class="n">Instr.eval</span> <span class="o">[</span><span class="n">instr.add</span><span class="o">]</span>
  <span class="o">(</span><span class="n">Instr.eval</span> <span class="o">(</span><span class="n">ArithExpr.compile</span> <span class="n">e₂</span><span class="o">)</span>
    <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span><span class="o">])</span> <span class="bp">=</span>
  <span class="o">[</span><span class="n">ArithExpr.eval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">ArithExpr.eval</span> <span class="n">e₂</span><span class="o">]</span>
</pre></div>
</div><p>So, first we were able to use our lemma to turn our single
<span class="default"><code class="highlight-inline"><span class="n">Instr.eval</span></code></span> into a sequence of nested <span class="default"><code class="highlight-inline"><span class="n">Instr.eval</span></code></span>s. And
the innermost one we can use our induction hypothesis on. But now we
are stuck, because we want to use our other induction hypothesis, but
it doesn&rsquo;t apply, as it tells us how <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.compile</span> <span class="n">e₂</span></code></span> runs
in an empty stack, not in a stack with <span class="default"><code class="highlight-inline"><span class="n">ArithExpr.eval</span> <span class="n">e₁</span></code></span> on it!</p><p>This is a case where our <span style="font-style: italic">induction</span> hypotheses are not strong
enough, and indeed, our entire theorem is not strong enough to be
proved. This may seem like a strange claim, that we need to make the
theorem more general in order to prove it, but when proving via
induction, the theorem you are proving is also how the induction
hypotheses are constructed, so if you need stronger induction
hypotheses, it may mean you need a more general theorem. Then if we
can prove this, we can define the original theorem as a corollary.</p><p>Let&rsquo;s define a new theorem. Note that we also have to generalize our
helper lemma, or else it will not apply!</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">instr_eval_app2</span> <span class="o">:</span> 
  <span class="k">forall</span> <span class="o">(</span><span class="n">is</span> <span class="n">is&#39;</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Instr</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span><span class="o">),</span>
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">is</span> <span class="bp">++</span> <span class="n">is&#39;</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> 
      <span class="n">Instr.eval</span> <span class="n">is&#39;</span> <span class="o">(</span><span class="n">Instr.eval</span> <span class="n">is</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">compile_correct_helper</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">List</span> <span class="n">Nat</span><span class="o">),</span> 
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="n">s</span> <span class="bp">=</span> <span class="o">(</span><span class="n">e.eval</span> <span class="o">::</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
  <span class="kd">by</span> 
    <span class="n">intro</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">e₁</span> <span class="n">e₂</span> <span class="n">ih₁</span> <span class="n">ih₂</span> <span class="bp">=&gt;</span> 
      <span class="n">intro</span> <span class="n">s</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">ArithExpr.compile</span><span class="o">,</span> <span class="n">Instr.eval</span><span class="o">,</span> <span class="n">ArithExpr.eval</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app2</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">instr_eval_app2</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih₁</span><span class="o">]</span>
      <span class="n">rw</span> <span class="o">[</span><span class="n">ih₂</span><span class="o">]</span>
      <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">Instr.eval</span><span class="o">]</span>
      <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">compile_correct</span> <span class="o">:</span>
  <span class="k">forall</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">),</span>
    <span class="n">Instr.eval</span> <span class="o">(</span><span class="n">e.compile</span><span class="o">)</span> <span class="o">[]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">e.eval</span><span class="o">]</span> <span class="o">:=</span> 
    <span class="k">fun</span> <span class="n">e</span> <span class="bp">=&gt;</span> <span class="n">compile_correct_helper</span> <span class="n">e</span> <span class="o">[]</span>
</pre></div>
</div><p>Now, we almost have the result: the only issue is that the order
of our operands is backwards. Now, we could finish this proof by
appealing to the commutativity of addition, but before doing that,
its worth wondering <span style="font-style: italic">why</span> this happened. If we do that,
we realize that our definition of compile is wrong! Since we are
pushing onto a stack, we should be compiling the second operand first,
then the first. Or, perhaps the <span class="default"><code class="highlight-inline"><span class="n">Instr.add</span></code></span> instruction should
swap when it computes. Once we fix that, the proof goes through.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l21.html" title="backward to &quot;Lecture 21:  Proof Practice&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l23.html" title="forward to &quot;Lecture 23: Generalize&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>