<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 27: Compiler Correctness</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="minted.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default"/><link rel="stylesheet" type="text/css" href="main.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr><tr><td align="right"></td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Lean Tactic Reference</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a></td></tr><tr><td align="right"></td><td><a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a></td></tr><tr><td align="right"></td><td><a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a></td></tr><tr><td align="right"></td><td><a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a></td></tr><tr><td align="right"></td><td><a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a></td></tr><tr><td align="right"></td><td><a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr></wbr>all, Intro to PBT</a></td></tr><tr><td align="right"></td><td><a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a></td></tr><tr><td align="right"></td><td><a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a></td></tr><tr><td align="right"></td><td><a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a></td></tr><tr><td align="right"></td><td><a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a></td></tr><tr><td align="right"></td><td><a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a></td></tr><tr><td align="right"></td><td><a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a></td></tr><tr><td align="right"></td><td><a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a></td></tr><tr><td align="right"></td><td><a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a></td></tr><tr><td align="right"></td><td><a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a></td></tr><tr><td align="right"></td><td><a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a></td></tr><tr><td align="right"></td><td><a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a></td></tr><tr><td align="right"></td><td><a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a></td></tr><tr><td align="right"></td><td><a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a></td></tr><tr><td align="right"></td><td><a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a></td></tr><tr><td align="right"></td><td><a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span>  Proof Practice</a></td></tr><tr><td align="right"></td><td><a href="l22.html" class="tocviewlink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a></td></tr><tr><td align="right"></td><td><a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Generalize</a></td></tr><tr><td align="right"></td><td><a href="l24.html" class="tocviewlink" data-pltdoc="x">Lecture 24:<span class="mywbr"> &nbsp;</span> Standard Libraries</a></td></tr><tr><td align="right"></td><td><a href="l25.html" class="tocviewlink" data-pltdoc="x">Lecture 25:<span class="mywbr"> &nbsp;</span> Forward Reasoning</a></td></tr><tr><td align="right"></td><td><a href="l26.html" class="tocviewlink" data-pltdoc="x">Lecture 26:<span class="mywbr"> &nbsp;</span> Proof Automation</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 27:<span class="mywbr"> &nbsp;</span> Compiler Correctness</a></td></tr><tr><td align="right"></td><td><a href="l28.html" class="tocviewlink" data-pltdoc="x">Lecture 28:<span class="mywbr"> &nbsp;</span> Induction</a></td></tr><tr><td align="right"></td><td><a href="l29.html" class="tocviewlink" data-pltdoc="x">Lecture 29:<span class="mywbr"> &nbsp;</span> Functions vs. Relations</a></td></tr><tr><td align="right"></td><td><a href="l30.html" class="tocviewlink" data-pltdoc="x">Lecture 30:<span class="mywbr"> &nbsp;</span> Why logic?</a></td></tr><tr><td align="right"></td><td><a href="l31.html" class="tocviewlink" data-pltdoc="x">Lecture 31:<span class="mywbr"> &nbsp;</span> Linear Logic</a></td></tr><tr><td align="right"></td><td><a href="l32.html" class="tocviewlink" data-pltdoc="x">Lecture 32</a></td></tr><tr><td align="right"></td><td><a href="l33.html" class="tocviewlink" data-pltdoc="x">Lecture 33</a></td></tr><tr><td align="right"></td><td><a href="l34.html" class="tocviewlink" data-pltdoc="x">Lecture 34</a></td></tr><tr><td align="right"></td><td><a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a></td></tr><tr><td align="right"></td><td><a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a></td></tr><tr><td align="right"></td><td><a href="l37.html" class="tocviewlink" data-pltdoc="x">Lecture 37</a></td></tr><tr><td align="right"></td><td><a href="l38.html" class="tocviewlink" data-pltdoc="x">Lecture 38</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 27:<span class="mywbr"> &nbsp;</span> Compiler Correctness</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Compiler_.Correctness%29" class="tocviewlink" data-pltdoc="x">Compiler Correctness</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Small-step_.Semantics%29" class="tocviewlink" data-pltdoc="x">Small-<wbr></wbr>step Semantics</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.A_complete_proof%29" class="tocviewlink" data-pltdoc="x">A complete proof</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Compiler_.Correctness%29" class="tocsubseclink" data-pltdoc="x">Compiler Correctness</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Small-step_.Semantics%29" class="tocsubseclink" data-pltdoc="x">Small-<wbr></wbr>step Semantics</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.A_complete_proof%29" class="tocsubseclink" data-pltdoc="x">A complete proof</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l26.html" title="backward to &quot;Lecture 26: Proof Automation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l28.html" title="forward to &quot;Lecture 28: Induction&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._l27)"></a>Lecture 27: Compiler Correctness</h4><h5>1<tt>&nbsp;</tt><a name="(part._.Purpose)"></a>Purpose</h5><p>Learn how compilers are verified.</p><h5>2<tt>&nbsp;</tt><a name="(part._.Outline)"></a>Outline</h5><p>First, we are going to talk about a new logical construct: the existential. In logic,
<span class="texMathInline">\exists x. P(x)</span> means that there is some <span class="texMathInline">x</span> such that <span class="texMathInline">P</span>, some logical statement, holds on
<span class="texMathInline">x</span>. For example, if
<span class="texMathInline">P</span> were the statement "student x is named Alex", then
<span class="texMathInline">\exists x.P(x)</span> would be a true statement if there were a student named Alex. This is in contrast to
<span class="texMathInline">\forall x.P(x)</span> which means all students must be named Alex for the statement to be true.</p><p>We can encode existentials in Lean by using an inductive type:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">Exists</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">p</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">w</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">p</span> <span class="n">w</span><span class="o">)</span> <span class="o">:</span> <span class="n">Exists</span> <span class="n">p</span>
</pre></div>
</div><p>The type <span class="default"><code class="highlight-inline"><span class="n">Exists</span> <span class="n">P</span></code></span>, thus, is a type that can be constructed using <span class="default"><code class="highlight-inline"><span class="n">Exists.intro</span></code></span> by passing it two things: a value <span class="default"><code class="highlight-inline"><span class="n">w</span></code></span> and a proof that <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> holds on <span class="default"><code class="highlight-inline"><span class="n">w</span></code></span>.</p><p>This is a slightly different version of the existential than the one typically used in math: like everything else in Lean, it is constructive. What that means is that if we have a proof of Exists P, not only do we know that there is some element for which P holds, we actually have such an element! Whereas in the classical existential, just knowing
<span class="texMathInline">\exists x.P(x)</span> doesn&#8217;t mean that you actually have such an
<span class="texMathInline">x</span>.</p><p>There is syntactic shorthand for writing this like you write forall, as we can see in this theorem. You can also see a tactic, which calls the constructor for you, with the particular value:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">T</span> <span class="o">:</span> <span class="n">exists</span> <span class="n">x</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">exists</span> <span class="mi">2</span>
</pre></div>
</div><p>The <span class="default"><code class="highlight-inline"><span class="n">exists</span></code></span> tactic will do some basic simplification and close obvious goals after plugging in the value.</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">Tactic Use</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">Tactic Description</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span class="default"><code class="highlight-inline"><span class="n">exists</span> <span class="n">e</span></code></span></p></td><td style="border-bottom: 1px solid black;"><p>Given a goal of type <span class="default"><code class="highlight-inline"><span class="n">Exists</span> <span class="n">P</span></code></span>, <span class="default"><code class="highlight-inline"><span class="n">exists</span> <span class="n">e</span></code></span> will instantiate the existential with the witness value <span class="default"><code class="highlight-inline"><span class="n">e</span></code></span> and close the goal if <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="n">e</span></code></span> is trivially provable. If <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="n">e</span></code></span> is not immediately provable, <span class="default"><code class="highlight-inline"><span class="n">P</span> <span class="n">e</span></code></span> will become the goal.</p></td></tr></table></p><h5>3<tt>&nbsp;</tt><a name="(part._.Compiler_.Correctness)"></a>Compiler Correctness</h5><p>Earlier on in the semester, we talked at a high level about what it means for a compiler, which is a program that translates code written in one programming language into another programming language, to be correct.</p><p>In English, the statement, often abbreviated as semantics preservation, is that the meaning of the source language should be preserved by compilation to the target.</p><p>Formally, this requires giving meaning to both the source language and the target language. Usually, the target language already has a well-defined meaning: you can run the programs. Source languages may not already have very formal definitions, but they usually at least have informal definitions, in the form of documentation, language specifications, etc. One of the first tasks, often, for a compiler verification effort is to give a formal definition of the source language.</p><p>With just a definition of the source and target language (as, say, interpreters that allow us to run the programs), one could use property based testing to try to verify that the compiler works. However, there are a couple reasons why compilers have been a main target of formal verification efforts with tools like Lean: first, running programs, especially programs that are not tiny, can take a while! If you are trying to test your compiler on thousands or millions of programs, if each of them takes even a couple seconds to run, this could be a very very slow process. But, more significantly, most languages are incredibly complex, with many different features that potentially interact in complex ways. Indeed, the amount of combinations of different features means that actually covering a representative set of programs may be very difficult. This isn&rsquo;t to say that doing randomized testing isn&rsquo;t worthwhile: this kind of testing (often called "fuzz testing", which it is just looking for crashes) is used very effectively to find bugs. But in programs as complex as compilers (which may be hundreds of thousands of lines, if not millions), there is little hope that you can find all the bugs by just randomly testing.</p><p>While the overall theorem statement remains the same, when it comes time to actually prove that the compiler preserves semantics, the particular approach to proof becomes quite important. In particular, doing naive induction on, e.g., the source program, most likely won&rsquo;t work on any interesting programming language. Indeed, even in the small one we&rsquo;ll use for HW, that approach would fail. Instead, we need a more sophisticated proof strategy. There are various strategies that people have come up with: we&rsquo;ll use the most common one used in practice, which is called a simulation.</p><p>At a high level, the idea is quite simple: we define a new relation, called the simulation relation, and we then prove that as the source and target program evaluate, they remain related by this relation. Provided we can show that at every step, they remain connected by this relation, then we can show that when the source program terminates (if it does), the target program must terminate at a related value, which is generally what we&rsquo;ll need to show correctness.</p><p>One thing this requires is that we have a way of talking about single steps of evaluation: we need them as data, not as code, so we can write proofs that inspect them.</p><h5>4<tt>&nbsp;</tt><a name="(part._.Small-step_.Semantics)"></a>Small-step Semantics</h5><p>First, we define a relation that shows how a single step of evaluation happens. Then, we have another relation called <span class="default"><code class="highlight-inline"><span class="n">Rstar</span></code></span>. This is a relation that takes another relation <span class="default"><code class="highlight-inline"><span class="n">P</span></code></span> as an argument: in our case, it&rsquo;ll take our single step relation. <span class="default"><code class="highlight-inline"><span class="n">Rstar</span></code></span> has two constructors: reflexivity (two elements are related to themselves) and the step relation (if P holds from a to b, and Rstar P holds from b to c, then Rstar P holds from a to c).</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">ArithExpr</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">ArithExpr.eval</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">→</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span> <span class="bp">=&gt;</span> <span class="n">e1.eval</span> <span class="bp">+</span> <span class="n">e2.eval</span>

<span class="kd">inductive</span> <span class="n">ArithExpr.step</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">add1</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">,</span> 
         <span class="n">ArithExpr.step</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="bp">-&gt;</span> 
         <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span><span class="o">,</span> 
         <span class="n">ArithExpr.step</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="bp">-&gt;</span> 
         <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n1</span> <span class="n">n2</span><span class="o">,</span>
         <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n1</span><span class="o">)</span> 
                                       <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n2</span><span class="o">))</span>
                        <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>

<span class="kd">inductive</span> <span class="n">Rstar</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="o">:=</span>
<span class="bp">|</span> <span class="n">refl</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">a</span><span class="o">,</span> <span class="n">Rstar</span> <span class="n">P</span> <span class="n">a</span> <span class="n">a</span>
<span class="bp">|</span> <span class="n">step</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">P</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="n">Rstar</span> <span class="n">P</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">-&gt;</span> <span class="n">Rstar</span> <span class="n">P</span> <span class="n">a</span> <span class="n">c</span>
</pre></div>
</div><p>We can prove helper theorems that show how evaluation of subterms gets lifted into the evaluation of the whole term.</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">rstar_add1</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">,</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="bp">-&gt;</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span> <span class="n">rst</span>
    <span class="n">induction</span> <span class="n">rst</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">Rstar.refl</span><span class="o">]</span>
    <span class="n">apply</span> <span class="n">Rstar.step</span>
    <span class="n">apply</span> <span class="n">ArithExpr.step.add1</span>
    <span class="n">assumption</span>
    <span class="n">assumption</span>

<span class="kd">theorem</span> <span class="n">rstar_add2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span><span class="o">,</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="bp">-&gt;</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2&#39;</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="n">rst</span>
    <span class="n">induction</span> <span class="n">rst</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">Rstar.refl</span><span class="o">]</span>
    <span class="n">apply</span> <span class="n">Rstar.step</span>
    <span class="n">apply</span> <span class="n">ArithExpr.step.add2</span>
    <span class="n">assumption</span>
    <span class="n">assumption</span>
</pre></div>
</div><p>Once we have a compiler, we can define a relation that shows how the source program and the target program are related. The simplest relation, which we&rsquo;ll be able to use for the compiler in homework, says that a term is related to its compile version:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">sim</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">comp</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span> <span class="o">:</span> <span class="n">sim</span> <span class="n">e</span> <span class="o">(</span><span class="n">compile</span> <span class="n">e</span><span class="o">)</span>
</pre></div>
</div><p>Then, we prove four theorems, which take us step-by-step to the end:</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">compile_sim</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span>
    <span class="n">sim</span> <span class="n">e</span> <span class="o">(</span><span class="n">compile</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">sim_step</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">t1</span> <span class="n">t1&#39;</span><span class="o">,</span>
    <span class="n">ArithExpr.step</span> <span class="n">t1</span> <span class="n">t1&#39;</span> <span class="bp">-&gt;</span>
    <span class="k">forall</span> <span class="n">t2</span><span class="o">,</span>
    <span class="n">sim</span> <span class="n">t1</span> <span class="n">t2</span> <span class="bp">-&gt;</span>
    <span class="n">exists</span> <span class="n">t2&#39;</span><span class="o">,</span> <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">t2</span> <span class="n">t2&#39;</span> <span class="bp">/\</span> <span class="n">sim</span> <span class="n">t1&#39;</span> <span class="n">t2&#39;</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">step_sim_star</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">t1</span> <span class="n">t1&#39;</span><span class="o">,</span>
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">t1</span> <span class="n">t1&#39;</span> <span class="bp">-&gt;</span>
  <span class="k">forall</span> <span class="n">t2</span><span class="o">,</span>
  <span class="n">sim</span> <span class="n">t1</span> <span class="n">t2</span> <span class="bp">-&gt;</span>
  <span class="n">exists</span> <span class="n">t2&#39;</span><span class="o">,</span> <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">t2</span> <span class="n">t2&#39;</span> <span class="bp">/\</span> <span class="n">sim</span> <span class="n">t1&#39;</span> <span class="n">t2&#39;</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">correct</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="n">n</span><span class="o">,</span> <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span>
                              <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">compile</span> <span class="n">e</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>
</pre></div>
</div><p>In the case that the simulation relation is the compiler, the first theorem is trivial. The second theorem, which shows that the relation is preserved over the step, is generally where most of the work happens. You have to do it over induction of the step relation, and do a lot of case analysis over what the simulation relation and the induction hypotheses tell you. The third theorem is usually a little bit of work, but mostly follows from the second. And the last one is usually pretty trivial: just applying the third and doing case analysis.</p><h5>5<tt>&nbsp;</tt><a name="(part._.A_complete_proof)"></a>A complete proof</h5><p>Here is a complete simulation proof, in this case of constant folding for <span class="default"><code class="highlight-inline"><span class="n">ArithExpr</span></code></span>s. While the technique is not required in that case, it is required for the compiler in homework, an the structure of the proof will be quite similar for homework, so it is a good model.</p><p><span style="font-weight: bold">NOTE: It turns out that constant folding needs a more complicated relation than the one for HW, so this proof does not have quite the same structure as the one for HW, though the overall approach is similar (essentially, in this proof, when you do case analysis on the simulation relation, you might get _multiple_ cases, whereas in HW, doing case analysis on the simulation will always just tell that the right side is the compiled version of the left).</span></p><div class="default"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">ArithExpr</span> <span class="o">:=</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e2</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span>


<span class="kd">inductive</span> <span class="n">ArithExpr.step</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">add1</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">,</span> 
         <span class="n">ArithExpr.step</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="bp">-&gt;</span> 
         <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span><span class="o">,</span> 
         <span class="n">ArithExpr.step</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="bp">-&gt;</span> 
         <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">add</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n1</span> <span class="n">n2</span><span class="o">,</span>
         <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n1</span><span class="o">)</span> 
                                       <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n2</span><span class="o">))</span>
                        <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>

<span class="kd">theorem</span> <span class="n">RTrans</span> <span class="o">{</span><span class="n">T</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">P</span> <span class="o">:</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="n">T</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">T</span><span class="o">}</span> <span class="o">:</span> 
        <span class="n">Rstar</span> <span class="n">P</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">-&gt;</span> <span class="n">Rstar</span> <span class="n">P</span> <span class="n">b</span> <span class="n">c</span> <span class="bp">-&gt;</span> <span class="n">Rstar</span> <span class="n">P</span> <span class="n">a</span> <span class="n">c</span> <span class="o">:=</span>
  <span class="kd">by</span> <span class="n">intros</span> <span class="n">H1</span>
     <span class="n">revert</span> <span class="n">c</span>
     <span class="n">induction</span> <span class="n">H1</span> <span class="bp">&lt;;&gt;</span> <span class="n">intros</span> <span class="n">c</span> <span class="n">H2</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="bp">&lt;;&gt;</span> <span class="n">try</span> <span class="n">assumption</span>
     <span class="n">rename_i</span> <span class="n">H</span>
     <span class="n">constructor</span>
     <span class="n">assumption</span>
     <span class="n">apply</span> <span class="n">H</span>
     <span class="n">assumption</span>

<span class="kd">def</span> <span class="n">ArithExpr.const_fold</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="n">ArithExpr</span>
  <span class="bp">|</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">num</span> <span class="n">n</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="o">(</span><span class="n">num</span> <span class="n">n1</span><span class="o">)</span> <span class="o">(</span><span class="n">num</span> <span class="n">n2</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">)</span>
  <span class="bp">|</span> <span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span> <span class="bp">=&gt;</span> <span class="n">add</span> <span class="n">e1.const_fold</span> <span class="n">e2.const_fold</span>


<span class="kd">theorem</span> <span class="n">rstar_add1</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">,</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="bp">-&gt;</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span> <span class="n">rst</span>
    <span class="n">induction</span> <span class="n">rst</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">Rstar.refl</span><span class="o">]</span>
    <span class="n">apply</span> <span class="n">Rstar.step</span>
    <span class="n">apply</span> <span class="n">ArithExpr.step.add1</span>
    <span class="n">assumption</span>
    <span class="n">assumption</span>

<span class="kd">theorem</span> <span class="n">rstar_add2</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span><span class="o">,</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="bp">-&gt;</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2&#39;</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="n">rst</span>
    <span class="n">induction</span> <span class="n">rst</span>
    <span class="n">simp</span> <span class="o">[</span><span class="bp">*</span><span class="o">,</span> <span class="n">Rstar.refl</span><span class="o">]</span>
    <span class="n">apply</span> <span class="n">Rstar.step</span>
    <span class="n">apply</span> <span class="n">ArithExpr.step.add2</span>
    <span class="n">assumption</span>
    <span class="n">assumption</span>

<span class="c">/-</span><span class="cm">NOTE: for constant folding, having the simulation relation</span>
<span class="cm">        be just the compiler is not flexible enough. it turns</span>
<span class="cm">        out we need a &quot;maybe&quot; compiler: i.e., it can sometimes</span>
<span class="cm">        constant fold (plus_comp) and sometimes not (plus_ind). </span>
<span class="cm">-/</span>
<span class="kd">inductive</span> <span class="n">sim</span> <span class="o">:</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="n">ArithExpr</span> <span class="bp">-&gt;</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">plus_comp</span> <span class="o">(</span><span class="n">n1</span> <span class="n">n2</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">sim</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n1</span><span class="o">)</span>
                                               <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n2</span><span class="o">))</span>
                                <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>
<span class="bp">|</span> <span class="n">plus_ind</span> <span class="o">(</span><span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">)</span> <span class="o">:</span>
          <span class="n">sim</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="bp">-&gt;</span> <span class="n">sim</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="bp">-&gt;</span>
          <span class="n">sim</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1&#39;</span> <span class="n">e2&#39;</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">n</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">sim</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n</span><span class="o">)</span>
           
<span class="c1">--| comp (e : ArithExpr) : sim e (e.const_fold)</span>

<span class="kd">theorem</span> <span class="n">step_add1</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span><span class="o">,</span> <span class="n">ArithExpr.step</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="bp">-&gt;</span> <span class="n">ArithExpr.const_fold</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">e1</span> <span class="n">e2</span><span class="o">)</span> <span class="bp">=</span> <span class="n">ArithExpr.add</span> <span class="o">(</span><span class="n">ArithExpr.const_fold</span> <span class="n">e1</span><span class="o">)</span> <span class="o">(</span><span class="n">ArithExpr.const_fold</span> <span class="n">e2</span><span class="o">)</span> <span class="o">:=</span> <span class="kd">by</span> <span class="gr">sorry</span>

<span class="kd">theorem</span> <span class="n">sim_step</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">t1</span> <span class="n">t1&#39;</span><span class="o">,</span>
    <span class="n">ArithExpr.step</span> <span class="n">t1</span> <span class="n">t1&#39;</span> <span class="bp">-&gt;</span>
    <span class="k">forall</span> <span class="n">t2</span><span class="o">,</span>
    <span class="n">sim</span> <span class="n">t1</span> <span class="n">t2</span> <span class="bp">-&gt;</span>
    <span class="n">exists</span> <span class="n">t2&#39;</span><span class="o">,</span> <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">t2</span> <span class="n">t2&#39;</span> <span class="bp">/\</span> <span class="n">sim</span> <span class="n">t1&#39;</span> <span class="n">t2&#39;</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">t1</span> <span class="n">t1&#39;</span> <span class="n">step</span>
    <span class="n">induction</span> <span class="n">step</span> <span class="bp">&lt;;&gt;</span> <span class="n">intros</span> <span class="n">t2</span> <span class="n">sim&#39;</span>
    <span class="n">case</span> <span class="n">add1</span> <span class="n">e1</span> <span class="n">e1&#39;</span> <span class="n">e2</span> <span class="n">step1</span> <span class="n">IH</span> <span class="bp">=&gt;</span>
      <span class="n">cases</span> <span class="n">sim&#39;</span>
      <span class="n">case</span> <span class="n">plus_comp</span> <span class="n">n1</span> <span class="n">n2</span> <span class="bp">=&gt;</span>
        <span class="n">exists</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>
      <span class="n">case</span> <span class="n">plus_ind</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">sim1</span> <span class="n">sim2</span> <span class="bp">=&gt;</span>
        <span class="n">cases</span> <span class="o">(</span><span class="n">IH</span> <span class="n">a1</span> <span class="n">sim1</span><span class="o">)</span>
        <span class="n">case</span> <span class="n">intro</span> <span class="n">t2&#39;</span> <span class="n">H</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">H</span>
          <span class="n">exists</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">t2&#39;</span> <span class="n">a2</span><span class="o">)</span>
          <span class="n">constructor</span>
          <span class="n">apply</span> <span class="n">rstar_add1</span>
          <span class="n">assumption</span>
          <span class="n">constructor</span>
          <span class="n">assumption</span>
          <span class="n">assumption</span>
    <span class="n">case</span> <span class="n">add2</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">e2&#39;</span> <span class="n">step2</span> <span class="n">IH</span> <span class="bp">=&gt;</span>
      <span class="n">cases</span> <span class="n">sim&#39;</span>
      <span class="n">case</span> <span class="n">plus_comp</span> <span class="n">n1</span> <span class="n">n2</span> <span class="bp">=&gt;</span>
        <span class="n">exists</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>
      <span class="n">case</span> <span class="n">plus_ind</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">sim1</span> <span class="n">sim2</span> <span class="bp">=&gt;</span>
        <span class="n">cases</span> <span class="o">(</span><span class="n">IH</span> <span class="n">a2</span> <span class="n">sim2</span><span class="o">)</span>
        <span class="n">case</span> <span class="n">intro</span> <span class="n">t2&#39;</span> <span class="n">H</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">H</span>
          <span class="n">exists</span> <span class="o">(</span><span class="n">ArithExpr.add</span> <span class="n">a1</span> <span class="n">t2&#39;</span><span class="o">)</span>
          <span class="n">constructor</span>
          <span class="n">apply</span> <span class="n">rstar_add2</span>
          <span class="n">assumption</span>
          <span class="n">constructor</span>
          <span class="n">assumption</span>
          <span class="n">assumption</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">n1</span> <span class="n">n2</span> <span class="bp">=&gt;</span>
      <span class="n">cases</span> <span class="n">sim&#39;</span>
      <span class="n">case</span> <span class="n">plus_comp</span> <span class="bp">=&gt;</span>
        <span class="n">exists</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>
        <span class="n">constructor</span>
        <span class="n">constructor</span>
        <span class="n">constructor</span>
      <span class="n">case</span> <span class="n">plus_ind</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">sim1</span> <span class="n">sim2</span> <span class="bp">=&gt;</span>
        <span class="n">cases</span> <span class="n">sim1</span>
        <span class="n">cases</span> <span class="n">sim2</span>
        <span class="n">exists</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="o">(</span><span class="n">n1</span> <span class="bp">+</span> <span class="n">n2</span><span class="o">))</span>
        <span class="n">constructor</span>
        <span class="n">apply</span> <span class="n">Rstar.step</span>
        <span class="n">apply</span> <span class="n">ArithExpr.step.add</span>
        <span class="n">constructor</span>
        <span class="n">constructor</span>

<span class="c">/-</span><span class="cm">NOTE: because the simulation relation, in this case, is not</span>
<span class="cm">        just the compiler, this proof is _not_ trivial (though it </span>
<span class="cm">        is not particularly difficult). In th compiler for HW,</span>
<span class="cm">        however, this is a one or two line theorem. -/</span>
<span class="kd">theorem</span> <span class="n">compile_sim</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="o">:</span> <span class="n">ArithExpr</span><span class="o">,</span>
    <span class="n">sim</span> <span class="n">e</span> <span class="n">e.const_fold</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">e</span>
    <span class="n">induction</span> <span class="n">e</span>
    <span class="n">case</span> <span class="n">num</span> <span class="n">n</span> <span class="bp">=&gt;</span>
      <span class="n">simp</span> <span class="o">[</span><span class="n">ArithExpr.const_fold</span><span class="o">]</span>
      <span class="n">constructor</span>
    <span class="n">case</span> <span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">sim1</span> <span class="n">sim2</span> <span class="bp">=&gt;</span>
      <span class="n">cases</span> <span class="n">e1</span> <span class="bp">&lt;;&gt;</span> <span class="n">cases</span> <span class="n">e2</span>
      <span class="n">case</span> <span class="n">num.num</span> <span class="bp">=&gt;</span>
        <span class="n">constructor</span>
      <span class="n">case</span> <span class="n">num.add</span> <span class="bp">=&gt;</span>
        <span class="n">constructor</span>
        <span class="n">constructor</span>
        <span class="n">assumption</span>
      <span class="n">case</span> <span class="n">add.num</span> <span class="bp">=&gt;</span>
        <span class="n">constructor</span>
        <span class="n">assumption</span>
        <span class="n">constructor</span>
      <span class="n">case</span> <span class="n">add.add</span> <span class="bp">=&gt;</span>
        <span class="n">constructor</span>
        <span class="n">assumption</span>
        <span class="n">assumption</span>

<span class="kd">theorem</span> <span class="n">step_sim_star</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">t1</span> <span class="n">t1&#39;</span><span class="o">,</span>
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">t1</span> <span class="n">t1&#39;</span> <span class="bp">-&gt;</span>
  <span class="k">forall</span> <span class="n">t2</span><span class="o">,</span>
  <span class="n">sim</span> <span class="n">t1</span> <span class="n">t2</span> <span class="bp">-&gt;</span>
  <span class="n">exists</span> <span class="n">t2&#39;</span><span class="o">,</span> <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">t2</span> <span class="n">t2&#39;</span> <span class="bp">/\</span> <span class="n">sim</span> <span class="n">t1&#39;</span> <span class="n">t2&#39;</span> <span class="o">:=</span> 
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">t1</span> <span class="n">t1&#39;</span> <span class="n">rst</span>
    <span class="n">induction</span> <span class="n">rst</span> <span class="bp">&lt;;&gt;</span> <span class="n">intros</span> <span class="n">t2</span> <span class="n">simt</span>
    <span class="n">case</span> <span class="n">refl</span> <span class="bp">=&gt;</span>
      <span class="n">exists</span> <span class="n">t2</span>
      <span class="n">constructor</span>
      <span class="n">constructor</span>
      <span class="n">assumption</span>
    <span class="n">case</span> <span class="n">step</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">stepab</span> <span class="n">rstbc</span> <span class="n">IH</span> <span class="bp">=&gt;</span>
      <span class="n">cases</span> <span class="o">(</span><span class="n">sim_step</span> <span class="n">_</span> <span class="n">_</span> <span class="n">stepab</span> <span class="n">_</span> <span class="n">simt</span><span class="o">)</span>
      <span class="n">case</span> <span class="n">intro</span> <span class="n">w</span> <span class="n">H</span> <span class="bp">=&gt;</span>
        <span class="n">cases</span> <span class="n">H</span> 
        <span class="n">case</span> <span class="n">intro</span> <span class="n">rst2</span> <span class="n">simb</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="o">(</span><span class="n">IH</span> <span class="n">_</span> <span class="n">simb</span><span class="o">)</span>
          <span class="n">case</span> <span class="n">intro</span> <span class="n">w&#39;</span> <span class="n">H</span> <span class="bp">=&gt;</span>
          <span class="n">cases</span> <span class="n">H</span>
          <span class="n">exists</span> <span class="n">w&#39;</span>
          <span class="n">constructor</span>
          <span class="n">apply</span> <span class="n">RTrans</span>
          <span class="n">assumption</span>
          <span class="n">assumption</span>
          <span class="n">assumption</span>

<span class="kd">theorem</span> <span class="n">correct</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">e</span> <span class="n">n</span><span class="o">,</span> 
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n</span><span class="o">)</span> <span class="bp">-&gt;</span>
  <span class="n">Rstar</span> <span class="n">ArithExpr.step</span> <span class="n">e.const_fold</span> <span class="o">(</span><span class="n">ArithExpr.num</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> 
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">e</span> <span class="n">n</span> <span class="n">rst1</span>
    <span class="n">cases</span> <span class="o">(</span><span class="n">step_sim_star</span> <span class="n">_</span> <span class="n">_</span> <span class="n">rst1</span> <span class="n">_</span> <span class="o">(</span><span class="n">compile_sim</span> <span class="n">e</span><span class="o">))</span>
    <span class="n">case</span> <span class="n">intro</span> <span class="n">w</span> <span class="n">H</span> <span class="bp">=&gt;</span>
      <span class="n">cases</span> <span class="n">H</span>
      <span class="n">case</span> <span class="n">intro</span> <span class="n">H1</span> <span class="n">H2</span> <span class="bp">=&gt;</span>
        <span class="n">cases</span> <span class="n">H2</span>
        <span class="n">assumption</span>
</pre></div>
</div><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l26.html" title="backward to &quot;Lecture 26: Proof Automation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l28.html" title="forward to &quot;Lecture 28: Induction&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>