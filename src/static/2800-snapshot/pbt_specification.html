<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3&nbsp;Property Based Testing</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="main.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr><tr><td align="right"></td><td><a href="notes.html" class="tocviewselflink" data-pltdoc="x">Notes</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="notes.html" class="tocviewlink" data-pltdoc="x">Notes</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="propositional.html" class="tocviewlink" data-pltdoc="x">Propositional Logic</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="recipe.html" class="tocviewlink" data-pltdoc="x">Design/<span class="mywbr"> &nbsp;</span>Specification Recipe</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Property Based Testing</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="smt.html" class="tocviewlink" data-pltdoc="x">Rosette 1:<span class="mywbr"> &nbsp;</span> SAT &amp; SMT</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="proof.html" class="tocviewlink" data-pltdoc="x">Beginning with Lean</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Property Based Testing</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#%28part._.Moving_beyond_truth_tables%29" class="tocviewlink" data-pltdoc="x">Moving beyond truth tables</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Moving_beyond_truth_tables%29" class="tocsubseclink" data-pltdoc="x">Moving beyond truth tables</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.6</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="recipe.html" title="backward to &quot;2 Design/Specification Recipe&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="notes.html" title="up to &quot;Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="smt.html" title="forward to &quot;4 Rosette 1: SAT &amp; SMT&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4>3<tt>&nbsp;</tt><a name="(part._pbt~3aspecification)"></a>Property Based Testing</h4><h5>3.1<tt>&nbsp;</tt><a name="(part._.Moving_beyond_truth_tables)"></a>Moving beyond truth tables</h5><p>In first order logic, you could write a statement like:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">for-all</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Boolean</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">boolean=?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This is a <span style="font-style: italic">specification</span> for the <span class="stt">not</span> function: it says that
applying it twice to any boolean results in the same boolean. As we&rsquo;ve seen, we
can <span style="font-style: italic">prove</span> this by using truth tables &#8212;<wbr></wbr> you would consider each
possible <span class="stt">x</span> (<span class="stt">T</span> or <span class="stt">F</span>) and see if the statement held:</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>x</p></td><td style="border-bottom: 1px solid black;"><p>(not (not x))</p></td></tr><tr><td><p>T</p></td><td><p>T</p></td></tr><tr><td><p>F</p></td><td><p>F</p></td></tr></table></p><p>How does this <span style="font-style: italic">verification</span> work?</p><p>Well, we write the following tests:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#t</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-expect</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">not</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>This is good, and a reminder of the power of these types of tests.</p><p>We also saw in <a href="recipe.html" data-pltdoc="x">Design/Specification Recipe</a> that</p><p>However,
there are limitations. In particular, we can easily write a statement that we
cannot prove via such table. For example, consider implementing an absolute
value function. We might have, as a partial specification, the following:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">for-all</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Integer</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">abs</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p>We could try to write a table of input and output examples, and use that to
construct tests:</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>x</p></td><td style="border-bottom: 1px solid black;"><p>(abs x)</p></td></tr><tr><td><p>0</p></td><td><p>0</p></td></tr><tr><td><p>-1</p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p>1</p></td></tr></table></p><p>But no matter how many examples we come up with, there are potentially more. The
limitation of the table approach to verification is that it requires the inputs
be finite. While, in a technical sense, computers are finite, in a practical
sense they are not (a laptop with 16GB ram could have 2^128000000000 possible
configurations &ndash; even if you could test a trillion per second, you would only
get through ~2^96 possibilities over the entire life of the universe, ~13.7
billion years).</p><p>If we can&rsquo;t take the property and construct a table of input/output pairs for
it, what else can we do? Well, one of the simplest, and yet incredibly
effective, is to leverage <span style="font-style: italic">randomization</span>. This strategy, called
property-based testing, allows us to take properties that make <span class="stt">for-all</span>
statements over inputs that are not (in practical terms) finite, and construct a
large set of random examples. A test, like we wrote by hand above, is then
generated for that input. For example, a partial run might include (partial as
usually the smallest set would include at least 100 tests):</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-property</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">abs</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-property</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">abs</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">-143</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-property</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">abs</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">344433332</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">check-property</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">abs</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Each case is a <span style="font-style: italic">part</span> of a proof of the statement. Since we will not
cover all the inputs, there is always some possibility that we missed an
important case, but despite that, this is still an incredibly effective way of
increasing our trust about code. Why?</p><p>Well, two primary reasons: first, we can always run it on more inputs. Indeed,
every time the test case runs, it chooses different inputs, so the space
continues to be explored. If the testing does find an example that fails, it
prints it out, so you can use it to debug the code, possibly adding that case as
a unit-test to ensure that such a bug never recurs ("regression tests").
This all happpens "for free".</p><p>Second, perhaps more
importantly, since the inputs are generated, rather than chosen by hand (as in
unit tests), they are much less likely to reproduce biases that the author would
have. If you didn&rsquo;t think of a particular test case, there is a decent chance
you would miss it both in your tests and in your implementation. The PBT test
generator, on the other hand, should not have that bias. Of course, this works both ways:
if there are particular points in the space that are known to be important for your code, the test
generator doesn&rsquo;t know that, so some about of unit testing is stil important!</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="recipe.html" title="backward to &quot;2 Design/Specification Recipe&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="notes.html" title="up to &quot;Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="smt.html" title="forward to &quot;4 Rosette 1: SAT &amp; SMT&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>