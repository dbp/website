<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 21:  Proof Practice</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="minted.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default"/><link rel="stylesheet" type="text/css" href="main.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr><tr><td align="right"></td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Lean Tactic Reference</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a></td></tr><tr><td align="right"></td><td><a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a></td></tr><tr><td align="right"></td><td><a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a></td></tr><tr><td align="right"></td><td><a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a></td></tr><tr><td align="right"></td><td><a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a></td></tr><tr><td align="right"></td><td><a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr></wbr>all, Intro to PBT</a></td></tr><tr><td align="right"></td><td><a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a></td></tr><tr><td align="right"></td><td><a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a></td></tr><tr><td align="right"></td><td><a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a></td></tr><tr><td align="right"></td><td><a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a></td></tr><tr><td align="right"></td><td><a href="l11.html" class="tocviewlink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a></td></tr><tr><td align="right"></td><td><a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a></td></tr><tr><td align="right"></td><td><a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a></td></tr><tr><td align="right"></td><td><a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a></td></tr><tr><td align="right"></td><td><a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a></td></tr><tr><td align="right"></td><td><a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a></td></tr><tr><td align="right"></td><td><a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a></td></tr><tr><td align="right"></td><td><a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a></td></tr><tr><td align="right"></td><td><a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a></td></tr><tr><td align="right"></td><td><a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span>  Proof Practice</a></td></tr><tr><td align="right"></td><td><a href="l22.html" class="tocviewlink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a></td></tr><tr><td align="right"></td><td><a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Generalize</a></td></tr><tr><td align="right"></td><td><a href="l24.html" class="tocviewlink" data-pltdoc="x">Lecture 24:<span class="mywbr"> &nbsp;</span> Standard Libraries</a></td></tr><tr><td align="right"></td><td><a href="l25.html" class="tocviewlink" data-pltdoc="x">Lecture 25:<span class="mywbr"> &nbsp;</span> Forward Reasoning</a></td></tr><tr><td align="right"></td><td><a href="l26.html" class="tocviewlink" data-pltdoc="x">Lecture 26:<span class="mywbr"> &nbsp;</span> Proof Automation</a></td></tr><tr><td align="right"></td><td><a href="l27.html" class="tocviewlink" data-pltdoc="x">Lecture 27:<span class="mywbr"> &nbsp;</span> Compiler Correctness</a></td></tr><tr><td align="right"></td><td><a href="l28.html" class="tocviewlink" data-pltdoc="x">Lecture 28:<span class="mywbr"> &nbsp;</span> Induction</a></td></tr><tr><td align="right"></td><td><a href="l29.html" class="tocviewlink" data-pltdoc="x">Lecture 29:<span class="mywbr"> &nbsp;</span> Functions vs. Relations</a></td></tr><tr><td align="right"></td><td><a href="l30.html" class="tocviewlink" data-pltdoc="x">Lecture 30:<span class="mywbr"> &nbsp;</span> Why logic?</a></td></tr><tr><td align="right"></td><td><a href="l31.html" class="tocviewlink" data-pltdoc="x">Lecture 31:<span class="mywbr"> &nbsp;</span> Linear Logic</a></td></tr><tr><td align="right"></td><td><a href="l32.html" class="tocviewlink" data-pltdoc="x">Lecture 32</a></td></tr><tr><td align="right"></td><td><a href="l33.html" class="tocviewlink" data-pltdoc="x">Lecture 33</a></td></tr><tr><td align="right"></td><td><a href="l34.html" class="tocviewlink" data-pltdoc="x">Lecture 34</a></td></tr><tr><td align="right"></td><td><a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a></td></tr><tr><td align="right"></td><td><a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a></td></tr><tr><td align="right"></td><td><a href="l37.html" class="tocviewlink" data-pltdoc="x">Lecture 37</a></td></tr><tr><td align="right"></td><td><a href="l38.html" class="tocviewlink" data-pltdoc="x">Lecture 38</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span>  Proof Practice</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l20.html" title="backward to &quot;Lecture 20: Lists&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l22.html" title="forward to &quot;Lecture 22: Generalizing hypotheses&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._l21)"></a>Lecture 21:  Proof Practice</h4><h5>1<tt>&nbsp;</tt><a name="(part._.Purpose)"></a>Purpose</h5><p>More practice proving.</p><h5>2<tt>&nbsp;</tt><a name="(part._.Outline)"></a>Outline</h5><p>Today, we are just gonig to practice with some small proofs.</p><p>First, we&rsquo;ll do a few proofs about numbers, using a different representation of even from how we do it in HW. This time, even is represented as an inductive type, rather than a boolean predicate.</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">double</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Nat</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
<span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">double</span> <span class="n">n</span><span class="o">))</span>

<span class="kd">theorem</span> <span class="n">double_succ</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="n">double</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">double</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intro</span> <span class="n">n</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">double</span><span class="o">]</span>

<span class="kd">inductive</span> <span class="n">ev</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">O</span> <span class="o">:</span> <span class="n">ev</span> <span class="mi">0</span>
  <span class="bp">|</span> <span class="n">SS</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">ev</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span> <span class="n">ev</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">))</span>

<span class="kd">theorem</span> <span class="n">ev_4</span> <span class="o">:</span> <span class="n">ev</span> <span class="mi">4</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">apply</span> <span class="n">ev.SS</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">ev.SS</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">ev.O</span>

<span class="kd">theorem</span> <span class="n">ev_plus4</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="n">ev</span> <span class="n">n</span> <span class="bp">→</span> <span class="n">ev</span> <span class="o">(</span><span class="n">Nat.add</span> <span class="n">n</span> <span class="mi">4</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intros</span> <span class="n">n</span> <span class="n">H</span>
    <span class="n">apply</span> <span class="n">ev.SS</span>
    <span class="n">apply</span> <span class="n">ev.SS</span>
    <span class="n">assumption</span>

<span class="kd">theorem</span> <span class="n">ev_double</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="n">ev</span> <span class="o">(</span><span class="n">double</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intro</span> <span class="n">n</span>
    <span class="n">induction</span> <span class="n">n</span> <span class="bp">&lt;;&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">double</span><span class="o">]</span>
    <span class="bp">.</span> <span class="n">constructor</span>
    <span class="bp">.</span> <span class="n">apply</span> <span class="n">ev.SS</span>
      <span class="n">assumption</span>
</pre></div>
</div><p>Here, we show a new syntax for proof organization: .. This focuses on the goal at hand, and hides the rest of the proof. This is useful when you have a long proof, and you want to focus on a particular part of it. It can make reading the proof scripts easier later, as you can more easily see where each goal is being proved.</p><p>Now, we&rsquo;ll try to show that our definition of even is equivalent to the one we used in HW.</p><div class="default"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">even</span> <span class="o">:</span> <span class="n">Nat</span> <span class="bp">-&gt;</span> <span class="n">Bool</span>
  <span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="n">true</span>
  <span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="n">false</span>
  <span class="bp">|</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="n">even</span> <span class="n">n</span>

<span class="kd">theorem</span> <span class="n">ev_eq</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="n">ev</span> <span class="n">n</span> <span class="bp">↔</span> <span class="n">even</span> <span class="n">n</span> <span class="o">:=</span>
 <span class="kd">by</span> <span class="n">intro</span> <span class="n">n</span>
    <span class="n">constructor</span>
    <span class="n">case</span> <span class="n">mp</span> <span class="bp">=&gt;</span>
      <span class="n">intro</span> <span class="n">H</span>
      <span class="n">induction</span> <span class="n">H</span>
      <span class="n">case</span> <span class="n">O</span> <span class="bp">=&gt;</span> <span class="n">rfl</span>
      <span class="n">case</span> <span class="n">SS</span> <span class="bp">=&gt;</span> <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">even</span><span class="o">]</span><span class="bp">;</span> <span class="n">assumption</span>
    <span class="n">case</span> <span class="n">mpr</span> <span class="bp">=&gt;</span>
      <span class="n">intro</span> <span class="n">H</span>
      <span class="gr">sorry</span>

<span class="kd">def</span> <span class="n">even_ev</span> <span class="o">:</span> <span class="k">forall</span> <span class="n">n</span><span class="o">,</span> <span class="n">even</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">true</span> <span class="bp">-&gt;</span> <span class="n">ev</span> <span class="n">n</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="bp">=&gt;</span> <span class="n">ev.O</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">H</span> <span class="bp">=&gt;</span> <span class="kd">by</span> <span class="n">contradiction</span>
<span class="bp">|</span> <span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=&gt;</span> <span class="k">fun</span> <span class="n">H</span> <span class="bp">=&gt;</span> <span class="n">ev.SS</span> <span class="n">n</span> <span class="o">(</span><span class="n">even_ev</span> <span class="n">n</span> <span class="n">H</span><span class="o">)</span>
</pre></div>
</div><p>Initially, this seems to go well: but we need to do induction on the structure of our relational definition of even, rather than the structure of the natural numbers. Going in the other direction, from the even predicate to the even relation, just doesn&rsquo;t work. The reason is that natural number induction goes up one number at a time. To prove that Nat.succ n is even, we can assume that n is even. But this is never going to be true! Either n isn&rsquo;t even, or Nat.succ n isn&rsquo;t even!</p><p>While we could try to define a different induction principle on natural numbers, that goes up two at a time, an easier way to do this is actually go back to our intuition from recursive definitions. Remember: proofs are just functional programs. In this case, what we do is match on 0, 1, and then <span class="default"><code class="highlight-inline"><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span></code></span>. In the 0 case, it&rsquo;s trivial. In the 1 case there is an easy contradiction, and in the <span class="default"><code class="highlight-inline"><span class="n">Nat.succ</span> <span class="o">(</span><span class="n">Nat.succ</span> <span class="n">n</span><span class="o">)</span></code></span> case, we can use call our function recursively two levels down, exactly as we&rsquo;d like.</p><p>This uses a new tactic: contradiction. This is used whenever we have an absurd statement: usually, a hypothesis that is a constructor for an inductive type that cannot be. In this case, even 1 evaluates to false, and so that hypothesis evaluates to false = true, which is contradictory. More generally, if a hypothesis is an inductive type that is impossible (e.g., if we had <span class="default"><code class="highlight-inline"><span class="n">H</span> <span class="o">:</span> <span class="n">ev</span> <span class="mi">1</span></code></span>, or <span class="default"><code class="highlight-inline"><span class="n">H</span> <span class="o">:</span> <span class="n">False</span></code></span>), as there are no constructor that have that type, then contradiction will prove the goal. Generally, <span class="default"><code class="highlight-inline"><span class="n">cases</span> <span class="n">H</span></code></span> will also do the same, as it will realize there are no possible cases and so the goal is proved.</p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">Tactic Use</span></p></td><td style="border-bottom: 1px solid black;"><p><span style="font-weight: bold">Tactic Description</span></p></td></tr><tr><td style="border-bottom: 1px solid black;"><p><span class="default"><code class="highlight-inline"><span class="n">contradiction</span></code></span></p></td><td style="border-bottom: 1px solid black;"><p>Looks for an impossible hypothesis (i.e., <span class="default"><code class="highlight-inline"><span class="n">true</span> <span class="bp">=</span> <span class="n">false</span> <span class="o">,</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">0</span></code></span>, etc. And use it to prove the goal. You can also often do this by doing case analysis on the impossible hypothesis, but this tactic is more convenient.</p></td></tr></table></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l20.html" title="backward to &quot;Lecture 20: Lists&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l22.html" title="forward to &quot;Lecture 22: Generalizing hypotheses&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>