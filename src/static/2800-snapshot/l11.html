<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 11: Rosette &amp; Finitization</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="minted-default-style.css" title="default"/><link rel="stylesheet" type="text/css" href="main.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Logic &amp; Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="homework.html" class="tocviewlink" data-pltdoc="x">Homework</a></td></tr><tr><td align="right"></td><td><a href="ref.html" class="tocviewlink" data-pltdoc="x">Lean Tactic Reference</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="l1.html" class="tocviewlink" data-pltdoc="x">Lecture 1:<span class="mywbr"> &nbsp;</span> Intro</a></td></tr><tr><td align="right"></td><td><a href="l2.html" class="tocviewlink" data-pltdoc="x">Lecture 2:<span class="mywbr"> &nbsp;</span> Logistics, Specifications in ISL</a></td></tr><tr><td align="right"></td><td><a href="l3.html" class="tocviewlink" data-pltdoc="x">Lecture 3:<span class="mywbr"> &nbsp;</span> Propositional Logic in Code</a></td></tr><tr><td align="right"></td><td><a href="l4.html" class="tocviewlink" data-pltdoc="x">Lecture 4:<span class="mywbr"> &nbsp;</span> Design /<span class="mywbr"> &nbsp;</span> Specification Recipe</a></td></tr><tr><td align="right"></td><td><a href="l5.html" class="tocviewlink" data-pltdoc="x">Lecture 5:<span class="mywbr"> &nbsp;</span> Relational Specifications</a></td></tr><tr><td align="right"></td><td><a href="l6.html" class="tocviewlink" data-pltdoc="x">Lecture 6:<span class="mywbr"> &nbsp;</span> For-<wbr></wbr>all, Intro to PBT</a></td></tr><tr><td align="right"></td><td><a href="l7.html" class="tocviewlink" data-pltdoc="x">Lecture 7:<span class="mywbr"> &nbsp;</span> ==&gt;, PBT filtering</a></td></tr><tr><td align="right"></td><td><a href="l8.html" class="tocviewlink" data-pltdoc="x">Lecture 8:<span class="mywbr"> &nbsp;</span> PBT generators</a></td></tr><tr><td align="right"></td><td><a href="l9.html" class="tocviewlink" data-pltdoc="x">Lecture 9:<span class="mywbr"> &nbsp;</span> SAT</a></td></tr><tr><td align="right"></td><td><a href="l10.html" class="tocviewlink" data-pltdoc="x">Lecture 10:<span class="mywbr"> &nbsp;</span> SMT &amp; Rosette</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a></td></tr><tr><td align="right"></td><td><a href="l12.html" class="tocviewlink" data-pltdoc="x">Lecture 12:<span class="mywbr"> &nbsp;</span> Higher order logic</a></td></tr><tr><td align="right"></td><td><a href="l13.html" class="tocviewlink" data-pltdoc="x">Lecture 13:<span class="mywbr"> &nbsp;</span> Functions</a></td></tr><tr><td align="right"></td><td><a href="l14.html" class="tocviewlink" data-pltdoc="x">Lecture 14:<span class="mywbr"> &nbsp;</span> Propositional logic</a></td></tr><tr><td align="right"></td><td><a href="l15.html" class="tocviewlink" data-pltdoc="x">Lecture 15:<span class="mywbr"> &nbsp;</span> Propositional logic &amp; programming</a></td></tr><tr><td align="right"></td><td><a href="l16.html" class="tocviewlink" data-pltdoc="x">Lecture 16:<span class="mywbr"> &nbsp;</span> Exam 1, Part A</a></td></tr><tr><td align="right"></td><td><a href="l17.html" class="tocviewlink" data-pltdoc="x">Lecture 17:<span class="mywbr"> &nbsp;</span> Exam 1, Part B</a></td></tr><tr><td align="right"></td><td><a href="l18.html" class="tocviewlink" data-pltdoc="x">Lecture 18:<span class="mywbr"> &nbsp;</span> Proving with tactics</a></td></tr><tr><td align="right"></td><td><a href="l19.html" class="tocviewlink" data-pltdoc="x">Lecture 19:<span class="mywbr"> &nbsp;</span> Inductive types &amp; proofs</a></td></tr><tr><td align="right"></td><td><a href="l20.html" class="tocviewlink" data-pltdoc="x">Lecture 20:<span class="mywbr"> &nbsp;</span> Lists</a></td></tr><tr><td align="right"></td><td><a href="l21.html" class="tocviewlink" data-pltdoc="x">Lecture 21:<span class="mywbr"> &nbsp;</span>  Proof Practice</a></td></tr><tr><td align="right"></td><td><a href="l22.html" class="tocviewlink" data-pltdoc="x">Lecture 22:<span class="mywbr"> &nbsp;</span> Generalizing hypotheses</a></td></tr><tr><td align="right"></td><td><a href="l23.html" class="tocviewlink" data-pltdoc="x">Lecture 23:<span class="mywbr"> &nbsp;</span> Generalize</a></td></tr><tr><td align="right"></td><td><a href="l24.html" class="tocviewlink" data-pltdoc="x">Lecture 24:<span class="mywbr"> &nbsp;</span> Standard Libraries</a></td></tr><tr><td align="right"></td><td><a href="l25.html" class="tocviewlink" data-pltdoc="x">Lecture 25:<span class="mywbr"> &nbsp;</span> Forward Reasoning</a></td></tr><tr><td align="right"></td><td><a href="l26.html" class="tocviewlink" data-pltdoc="x">Lecture 26:<span class="mywbr"> &nbsp;</span> Proof Automation</a></td></tr><tr><td align="right"></td><td><a href="l27.html" class="tocviewlink" data-pltdoc="x">Lecture 27:<span class="mywbr"> &nbsp;</span> Compiler Correctness</a></td></tr><tr><td align="right"></td><td><a href="l28.html" class="tocviewlink" data-pltdoc="x">Lecture 28:<span class="mywbr"> &nbsp;</span> Induction</a></td></tr><tr><td align="right"></td><td><a href="l29.html" class="tocviewlink" data-pltdoc="x">Lecture 29:<span class="mywbr"> &nbsp;</span> Functions vs. Relations</a></td></tr><tr><td align="right"></td><td><a href="l30.html" class="tocviewlink" data-pltdoc="x">Lecture 30:<span class="mywbr"> &nbsp;</span> Why logic?</a></td></tr><tr><td align="right"></td><td><a href="l31.html" class="tocviewlink" data-pltdoc="x">Lecture 31:<span class="mywbr"> &nbsp;</span> Linear Logic</a></td></tr><tr><td align="right"></td><td><a href="l32.html" class="tocviewlink" data-pltdoc="x">Lecture 32</a></td></tr><tr><td align="right"></td><td><a href="l33.html" class="tocviewlink" data-pltdoc="x">Lecture 33</a></td></tr><tr><td align="right"></td><td><a href="l34.html" class="tocviewlink" data-pltdoc="x">Lecture 34</a></td></tr><tr><td align="right"></td><td><a href="l35.html" class="tocviewlink" data-pltdoc="x">Lecture 35:<span class="mywbr"> &nbsp;</span> Exam 2, Part A</a></td></tr><tr><td align="right"></td><td><a href="l36.html" class="tocviewlink" data-pltdoc="x">Lecture 36:<span class="mywbr"> &nbsp;</span> Exam 2, Part B</a></td></tr><tr><td align="right"></td><td><a href="l37.html" class="tocviewlink" data-pltdoc="x">Lecture 37</a></td></tr><tr><td align="right"></td><td><a href="l38.html" class="tocviewlink" data-pltdoc="x">Lecture 38</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture 11:<span class="mywbr"> &nbsp;</span> Rosette &amp; Finitization</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Purpose%29" class="tocviewlink" data-pltdoc="x">Purpose</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Outline%29" class="tocviewlink" data-pltdoc="x">Outline</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Purpose%29" class="tocsubseclink" data-pltdoc="x">Purpose</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Outline%29" class="tocsubseclink" data-pltdoc="x">Outline</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l10.html" title="backward to &quot;Lecture 10: SMT &amp; Rosette&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l12.html" title="forward to &quot;Lecture 12: Higher order logic&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._l11)"></a>Lecture 11: Rosette &amp; Finitization</h4><h5>1<tt>&nbsp;</tt><a name="(part._.Purpose)"></a>Purpose</h5><p>Finitization of problems to make them fit into Rosette.</p><h5>2<tt>&nbsp;</tt><a name="(part._.Outline)"></a>Outline</h5><p><span class="Larger">A bigger example, for a long-standing bug</span></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>This example comes from the Rosette documentation, which has many other great ones!</p></blockquote></blockquote></blockquote><p>The <span class="RktSym">bad-mult-prop</span><span class="RktMeta"></span> example is nice, but it&rsquo;s a bit contrived. Let&rsquo;s look at a real bug.</p><p>First, we&rsquo;ll define a way of dealing with 32bit numbers, representing them as vectors of 32 bits.</p><div class="default"><div class="highlight"><pre><span></span><span class="c1">; int32? is a shorthand for the type (bitvector 32).</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">int32?</span><span class="w"> </span><span class="p">(</span><span class="n">bitvector</span><span class="w"> </span><span class="mi">32</span><span class="p">))</span><span class="w"></span>

<span class="c1">; int32 takes as input an integer literal and returns</span><span class="w"></span>
<span class="c1">; the corresponding 32-bit bitvector value.</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">bv</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">int32?</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div><p>Next, we&rsquo;ll define a "midpoint" function that takes two numbers and returns the middle, using
bitvector addition and division:</p><div class="default"><div class="highlight"><pre><span></span><span class="c1">; Returns the midpoint of the interval [lo, hi].</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">bvmid</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">)</span><span class="w">  </span><span class="c1">; (lo + hi) / 2</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">bvsdiv</span><span class="w"> </span><span class="p">(</span><span class="n">bvadd</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div><p>Remember: SMT solvers have the ability to natively reason about bitvectors, so stating things this
way will allow us to best leverage the solver.</p><p>To talk about correctness, we need to think about how this function is supposed to work: both the
assumptions it makes about the inputs (that both numbers are positive, that the first is less than the
second). We can encode those as <span class="RktSym">assumptions</span><span class="RktMeta"></span>, and then compute <span class="RktSym">assertions</span><span class="RktMeta"></span> about the
result of the function. In this case, we&rsquo;ll assert that the middle is between the lo and the hi, and
that the difference from middle to lo and middle to hi are nearly the same.</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">check-mid</span><span class="w"> </span><span class="n">impl</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">)</span><span class="w">     </span><span class="c1">; Assuming that</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assume</span><span class="w"> </span><span class="p">(</span><span class="n">bvsle</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">lo</span><span class="p">))</span><span class="w">    </span><span class="c1">; 0 ≤ lo and</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assume</span><span class="w"> </span><span class="p">(</span><span class="n">bvsle</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">))</span><span class="w">           </span><span class="c1">; lo ≤ hi,</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">mi</span><span class="w"> </span><span class="p">(</span><span class="n">impl</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">hi</span><span class="p">))</span><span class="w">         </span><span class="c1">; and letting mi = impl(lo, hi) and</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">diff</span><span class="w">                     </span><span class="c1">; diff = (hi - mi) - (mi - lo),</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">bvsub</span><span class="w"> </span><span class="p">(</span><span class="n">bvsub</span><span class="w"> </span><span class="n">hi</span><span class="w"> </span><span class="n">mi</span><span class="p">)</span><span class="w"></span>
<span class="w">           </span><span class="p">(</span><span class="n">bvsub</span><span class="w"> </span><span class="n">mi</span><span class="w"> </span><span class="n">lo</span><span class="p">)))</span><span class="w">         </span><span class="c1">; we require that</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">bvsle</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">mi</span><span class="p">))</span><span class="w">           </span><span class="c1">; lo ≤ mi,</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">bvsle</span><span class="w"> </span><span class="n">mi</span><span class="w"> </span><span class="n">hi</span><span class="p">))</span><span class="w">           </span><span class="c1">; mi ≤ hi,</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">bvsle</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">diff</span><span class="p">))</span><span class="w">  </span><span class="c1">; 0 ≤ diff, and</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">bvsle</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="mi">1</span><span class="p">))))</span><span class="w"> </span><span class="c1">; diff ≤ 1.</span><span class="w"></span>
</pre></div>
</div><p>We can test this on various inputs (and we could use quickcheck, though won&rsquo;t in this case),
and perhaps unsurprisingly (given this was a common and longstanding bug: <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm#Implementation_issues">https://en.wikipedia.org/wiki/Binary_search_algorithm#Implementation_issues</a>), we don&rsquo;t detect any problems:</p><div class="default"><div class="highlight"><pre><span></span><span class="c1">; (check-mid bvmid (int32 0) (int32 0))</span><span class="w"></span>
<span class="c1">; (check-mid bvmid (int32 0) (int32 1))</span><span class="w"></span>
<span class="c1">; (check-mid bvmid (int32 0) (int32 2))</span><span class="w"></span>
<span class="c1">; (check-mid bvmid (int32 10) (int32 10000))</span><span class="w"></span>
</pre></div>
</div><p>But we can do better with Rossette, and unsurprisingly, it finds a counterexample:</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">define-symbolic</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">int32?</span><span class="p">)</span><span class="w"></span>


<span class="p">(</span><span class="n">verify</span><span class="w"> </span><span class="p">(</span><span class="n">check-mid</span><span class="w"> </span><span class="n">bvmid</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">h</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div><p><span class="Larger">Finitization</span></p><p>This example is more interesting, but still just involves adding and dividing numbers. While we won&rsquo;t look at the actual encodings, this happens by translating the problem
into a query in the language that the SMT language can accomodate: different SMT solvers have different
capabilities, but typically, not only Booleans (as SAT solvers can deal with), but also finite sized
integers (bit-arrays), and possibly strings, uninterpreted functions, etc.</p><p>What if we want to handle more complicated queries? What about recursive functions, or unbounded
data types like lists?</p><p>In this case, what we have to do is <span style="font-style: italic">finitize</span>. For recursive functions, that typically means
a certain number of recursive calls; for lists, it would be lists of up to a certain length, etc. This is
because the SMT queries cannot be self-referential, so we cannot directly express a recursive computation, or
a recursive data structure.</p><p>How do we finitize? There are two issues. First, there is a question of recursion. If we have functions on symbolic values that are recursive, naively trying to reason about them with Rosette runs into problems. In particular, on each recursive call, Rosette will create a new symbolic value, and will never realize that it gets to a stop condition. Consider: here we allow it to go to 5 levels of recursion; that isn&rsquo;t enough to find the bug, so Rosette reports "unsat". If we up the fuel to high enough, it finds it just fine.</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">bad-fact</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assume</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;out of fuel&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="mi">0</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="mi">1</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">bad-fact</span><span class="w"> </span><span class="p">(</span><span class="nb">sub1</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sub1</span><span class="w"> </span><span class="n">n</span><span class="p">))))))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fact</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="n">assume</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;out of fuel&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">zero?</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="mi">1</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="n">fact</span><span class="w"> </span><span class="p">(</span><span class="nb">sub1</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">sub1</span><span class="w"> </span><span class="n">n</span><span class="p">)))))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">fact-prop</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="n">fact</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">bad-fact</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">n</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="n">define-symbolic</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="nb">integer?</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">verify</span><span class="w"> </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">fact-prop</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">p</span><span class="p">))))</span><span class="w"></span>
<span class="p">(</span><span class="n">clear-vc!</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div><p>Recursive data is handled slightly differently. There is no direct way to create a symbolic piece of recursive data, so likely, we&rsquo;ll end up creating a <span style="font-style: italic">concrete</span> list that contains <span style="font-style: italic">symbolic</span> values. As a result, we&rsquo;ll end up with a finite list, and, at least <span style="font-style: italic">structurally</span> recursive functions
will then be fine, since Rosette will be able to figure out when the program stops. If the program was generative, we&rsquo;d likely have to do the above finitization trick.</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">require</span><span class="w"> </span><span class="n">quickcheck</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="k">require</span><span class="w"> </span><span class="n">rackunit</span><span class="p">)</span><span class="w"></span>

<span class="p">(</span><span class="n">define-symbolic</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="nb">integer?</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div><p>This allows us to test on lists of up to 6, since we have a symbolic value that we use to determine how
many of the elements of the list we actually care about. Another way of thinking about how this will
be used is that we are going to enumerate all the lists of one element, two elements, three elements,
etc. up to 6 elements, and then check each of those. So while "list" is not something we can reason
about symbolically (to really handle them, we&rsquo;ll have to wait for Lean), we can still handle at
least small cases, which are often enough to reveal bugs.</p><p>Let&rsquo;s see how to do this for a recursive function. In the presentation of SAT, we manually unrolled
and finitized our recursion. With Rosette, we don&rsquo;t have to do that, though we do still have to
think about how large of a space are we asking for it to be searching through, as otherwise the queries
may take a long time to run!</p><p>Let&rsquo;s return to the example of sorting. We can start with a decent property &ndash; not perfect, but not
terrible &ndash; to capture what a sorting function (calling it <span class="RktSym">sort1</span><span class="RktMeta"></span> here) should do:</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">[(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="no">#t</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="p">[(</span><span class="nb">cons?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">andmap</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w"></span>
<span class="w">                        </span><span class="p">(</span><span class="n">ordered</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">)))]))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sort1-prop</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="n">sort1</span><span class="w"> </span><span class="n">l</span><span class="p">)))</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="n">ordered</span><span class="w"> </span><span class="p">(</span><span class="n">sort1</span><span class="w"> </span><span class="n">l</span><span class="p">))))</span><span class="w"></span>
</pre></div>
</div><p>This says that <span class="RktSym">sort1</span><span class="RktMeta"></span> should take a list, and return a list of the same length, where the elements
in the resulting list are in sorted order.</p><p>Now, we could just jump right into using Rosette, but one <span style="font-style: italic">weakness</span> of it is that if our programs
report errors, then Rosette considers whatever input triggered that a counterexample. If there is a
bug in our code, it will thus report that any input could be treated as a counterexample, but it
won&rsquo;t show the error &ndash; it will hide them. One easy way to avoid that (and, general good practice)
is to first do some basic testing. We&rsquo;ll show how to do it here with some unit tests, though we
certainly could use PBT, and probably it would be better. Because of how Rosette works, we can use the same functions for both purposes: only
the inputs we passed (concrete for the testts, or symbolic, for rosette) will change.</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sort1</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">[(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">l</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="p">[(</span><span class="nb">cons?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="n">insert1</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">                  </span><span class="p">(</span><span class="n">sort1</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">)))]))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">insert1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">[(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w"></span>
<span class="w">        </span><span class="p">[(</span><span class="nb">cons?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w"></span>
<span class="w">             </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w"></span>
<span class="w">             </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">insert1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">))))]))</span><span class="w"></span>

<span class="p">(</span><span class="n">check-pred</span><span class="w"> </span><span class="n">sort1-prop</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="n">check-pred</span><span class="w"> </span><span class="n">sort1-prop</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="n">check-pred</span><span class="w"> </span><span class="n">sort1-prop</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div><p>Now we can also use Rosette to find counterexamples to this property. We can do this with:</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">verify</span><span class="w"> </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">sort1-prop</span><span class="w"> </span><span class="n">xs</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div><p>This will find a counterexample, and print it out, as it turns out there is a bug in our code. At this
point, we can either use the counterexample that Rosette gave us, or we can turn to another tool to look
for more, or smaller ones. Here, we&rsquo;ll see what Quickcheck gives us (if anything):</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">quickcheck</span><span class="w"> </span><span class="p">(</span><span class="n">property</span><span class="w"> </span><span class="p">([</span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">arbitrary-list</span><span class="w"> </span><span class="n">arbitrary-integer</span><span class="p">)])</span><span class="w"></span>
<span class="w">                      </span><span class="p">(</span><span class="n">sort1-prop</span><span class="w"> </span><span class="n">l</span><span class="p">)))</span><span class="w"></span>
</pre></div>
</div><p>This is a smaller input, which is nice, and it allows us to realize what is going wrong: our insert
is dropping the element after the one it inserts, assuming it doesn&rsquo;t insert at the end of the list.
Since our concrete unit tests all inserted at the end of the list, we missed this.</p><p>We can fix this by changing our insert function, running all of the tests again, and this time, both
Quickcheck and Rosette will report no issues.</p><div class="default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sort2</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">[(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">l</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="p">[(</span><span class="nb">cons?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="n">insert2</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">                 </span><span class="p">(</span><span class="n">sort2</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">)))]))</span><span class="w"></span>

<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">insert2</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">[(</span><span class="nb">empty?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">n</span><span class="p">)]</span><span class="w"></span>
<span class="w">        </span><span class="p">[(</span><span class="nb">cons?</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w"></span>
<span class="w">             </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">             </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">insert2</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">l</span><span class="p">))))]))</span><span class="w"></span>



<span class="p">(</span><span class="k">define</span><span class="w"> </span><span class="p">(</span><span class="n">sort2-prop</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">equal?</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="n">sort2</span><span class="w"> </span><span class="n">l</span><span class="p">)))</span><span class="w"></span>
<span class="w">       </span><span class="p">(</span><span class="n">ordered</span><span class="w"> </span><span class="p">(</span><span class="n">sort2</span><span class="w"> </span><span class="n">l</span><span class="p">))))</span><span class="w"></span>

<span class="p">(</span><span class="n">check-pred</span><span class="w"> </span><span class="n">sort2-prop</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="n">check-pred</span><span class="w"> </span><span class="n">sort2-prop</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="p">(</span><span class="n">check-pred</span><span class="w"> </span><span class="n">sort2-prop</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>

<span class="p">(</span><span class="n">quickcheck</span><span class="w"> </span><span class="p">(</span><span class="n">property</span><span class="w"> </span><span class="p">([</span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">arbitrary-list</span><span class="w"> </span><span class="n">arbitrary-integer</span><span class="p">)])</span><span class="w"></span>
<span class="w">                      </span><span class="p">(</span><span class="n">sort2-prop</span><span class="w"> </span><span class="n">l</span><span class="p">)))</span><span class="w"></span>

<span class="p">(</span><span class="n">verify</span><span class="w"> </span><span class="p">(</span><span class="n">assert</span><span class="w"> </span><span class="p">(</span><span class="n">sort2-prop</span><span class="w"> </span><span class="n">xs</span><span class="p">)))</span><span class="w"></span>
<span class="p">(</span><span class="n">clear-vc!</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="l10.html" title="backward to &quot;Lecture 10: SMT &amp; Rosette&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="l12.html" title="forward to &quot;Lecture 12: Higher order logic&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>