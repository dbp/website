<!doctype HTML>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="codemirror.js"></script>
<script src="python.js"></script>
<script src="runmode.js"></script>
<script src="setup-page.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 27: Introduction to Big-O Analysis</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra-styles.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Fundamentals II
<br/>
Introduction to Class-<wbr></wbr>based Program Design</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="General.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="Lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="Lab_Materials.html" class="tocviewlink" data-pltdoc="x">Lab Materials</a></td></tr><tr><td align="right"></td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right"></td><td><a href="Pair_Programming_Overview.html" class="tocviewlink" data-pltdoc="x">Pair Programming Overview</a></td></tr><tr><td align="right"></td><td><a href="code-style.html" class="tocviewlink" data-pltdoc="x">Code style</a></td></tr><tr><td align="right"></td><td><a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Data Definitions in Java</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 2:</span> Data Definitions:<span class="mywbr"> &nbsp;</span> Unions</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 3:</span> Methods for simple classes</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Methods for unions</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 5:</span> Methods for self-<wbr></wbr>referential lists</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Accumulator methods</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Accumulator methods, continued</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Practice Design</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 9:</span> Abstract classes and inheritance</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 10:</span> Customizing constructors for correctness and convenience</a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 11:</span> Defining sameness for complex data, part 1</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Defining sameness for complex data, part 2</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 13:</span> Abstracting over behavior</a></td></tr><tr><td align="right"></td><td><a href="lecture14.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Abstractions over more than one argument</a></td></tr><tr><td align="right"></td><td><a href="lecture15.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 15:</span> Abstracting over types</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Visitors</a></td></tr><tr><td align="right"></td><td><a href="lecture17.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 17:</span> Mutation</a></td></tr><tr><td align="right"></td><td><a href="lecture18.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 18:</span> Mutation inside structures</a></td></tr><tr><td align="right"></td><td><a href="lecture19.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 19:</span> Mutation, aliasing and testing</a></td></tr><tr><td align="right"></td><td><a href="lecture20.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 20:</span> Mutable data structures</a></td></tr><tr><td align="right"></td><td><a href="lecture21.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 21:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a></td></tr><tr><td align="right"></td><td><a href="lecture22.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 22:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a></td></tr><tr><td align="right"></td><td><a href="lecture23.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 23:</span> For-<wbr></wbr>each loops and Counted-<wbr></wbr>for loops</a></td></tr><tr><td align="right"></td><td><a href="lecture24.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 24:</span> While loops</a></td></tr><tr><td align="right"></td><td><a href="lecture25.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 25:</span> Iterator and Iterable</a></td></tr><tr><td align="right"></td><td><a href="lecture26.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 26:</span> Hashing and Equality</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis</a></td></tr><tr><td align="right"></td><td><a href="lecture28.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 28:</span> Quicksort and Mergesort</a></td></tr><tr><td align="right"></td><td><a href="lecture29.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 29:</span> Priority Queues and Heapsort</a></td></tr><tr><td align="right"></td><td><a href="lecture30.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 30:</span> Breadth-<wbr></wbr>first search and Depth-<wbr></wbr>first search on graphs</a></td></tr><tr><td align="right"></td><td><a href="lecture31.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 31:</span> Dijkstra&rsquo;s Algorithm for single-<wbr></wbr>source shortest paths</a></td></tr><tr><td align="right"></td><td><a href="lecture32.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees</a></td></tr><tr><td align="right"></td><td><a href="lecture33.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 33:</span> Implementing Objects</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">27.1&nbsp;</td><td><a href="#%28part._.Motivation%29" class="tocviewlink" data-pltdoc="x">Motivation</a></td></tr><tr><td align="right">27.2&nbsp;</td><td><a href="#%28part._.What_to_measure__and_how_%29" class="tocviewlink" data-pltdoc="x">What to measure, and how?</a></td></tr><tr><td align="right">27.3&nbsp;</td><td><a href="#%28part._.Introducing_big-.O_and_big-__notation%29" class="tocviewlink" data-pltdoc="x">Introducing big-<span style="font-style: italic">O</span> and big-<span style="font-style: italic">&#937;</span> notation</a></td></tr><tr><td align="right">27.4&nbsp;</td><td><a href="#%28part._.Analyzing_insertion-sort%29" class="tocviewlink" data-pltdoc="x">Analyzing insertion-<wbr></wbr>sort</a></td></tr><tr><td align="right">27.5&nbsp;</td><td><a href="#%28part._.Analyzing_selection-sort%29" class="tocviewlink" data-pltdoc="x">Analyzing selection-<wbr></wbr>sort</a></td></tr><tr><td align="right">27.6&nbsp;</td><td><a href="#%28part._.Discussion%29" class="tocviewlink" data-pltdoc="x">Discussion</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">27.1<tt>&nbsp;</tt></span><a href="#%28part._.Motivation%29" class="tocsubseclink" data-pltdoc="x">Motivation</a></td></tr><tr><td><span class="tocsublinknumber">27.2<tt>&nbsp;</tt></span><a href="#%28part._.What_to_measure__and_how_%29" class="tocsubseclink" data-pltdoc="x">What to measure, and how?</a></td></tr><tr><td><span class="tocsublinknumber">27.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Adventures_in_time___%29" class="tocsubseclink" data-pltdoc="x">Adventures in time...</a></td></tr><tr><td><span class="tocsublinknumber">27.2.2<tt>&nbsp;</tt></span><a href="#%28part.____and_space%29" class="tocsubseclink" data-pltdoc="x">...and space</a></td></tr><tr><td><span class="tocsublinknumber">27.2.3<tt>&nbsp;</tt></span><a href="#%28part._.It_was_the_best_of_times__it_was_the_worst_of_times___%29" class="tocsubseclink" data-pltdoc="x">It was the best of times, it was the worst of times...</a></td></tr><tr><td><span class="tocsublinknumber">27.2.4<tt>&nbsp;</tt></span><a href="#%28part._.You_get_what_you_pay_for%29" class="tocsubseclink" data-pltdoc="x">You get what you pay for</a></td></tr><tr><td><span class="tocsublinknumber">27.3<tt>&nbsp;</tt></span><a href="#%28part._.Introducing_big-.O_and_big-__notation%29" class="tocsubseclink" data-pltdoc="x">Introducing big-<span style="font-style: italic">O</span> and big-<span style="font-style: italic">&#937;</span> notation</a></td></tr><tr><td><span class="tocsublinknumber">27.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Performance_is_a_function_of_input_sizes%29" class="tocsubseclink" data-pltdoc="x">Performance is a function of input sizes</a></td></tr><tr><td><span class="tocsublinknumber">27.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Performance_of_recursive_algorithms%29" class="tocsubseclink" data-pltdoc="x">Performance of recursive algorithms</a></td></tr><tr><td><span class="tocsublinknumber">27.3.3<tt>&nbsp;</tt></span><a href="#%28part._.How_can_we_compare_functions_%29" class="tocsubseclink" data-pltdoc="x">How can we compare functions?</a></td></tr><tr><td><span class="tocsublinknumber">27.3.4<tt>&nbsp;</tt></span><a href="#%28part._.Convenient_properties_of_big-.O_notation%29" class="tocsubseclink" data-pltdoc="x">Convenient properties of big-<span style="font-style: italic">O</span> notation</a></td></tr><tr><td><span class="tocsublinknumber">27.4<tt>&nbsp;</tt></span><a href="#%28part._.Analyzing_insertion-sort%29" class="tocsubseclink" data-pltdoc="x">Analyzing insertion-<wbr></wbr>sort</a></td></tr><tr><td><span class="tocsublinknumber">27.5<tt>&nbsp;</tt></span><a href="#%28part._.Analyzing_selection-sort%29" class="tocsubseclink" data-pltdoc="x">Analyzing selection-<wbr></wbr>sort</a></td></tr><tr><td><span class="tocsublinknumber">27.6<tt>&nbsp;</tt></span><a href="#%28part._.Discussion%29" class="tocsubseclink" data-pltdoc="x">Discussion</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.14</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="lecture26.html" title="backward to &quot;Lecture 26: Hashing and Equality&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture28.html" title="forward to &quot;Lecture 28: Quicksort and Mergesort&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h4 class="heading"><a name="(part._)"></a><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis<span class="button-group"><a href="#(part._)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h4><p class="boxed">When is one algorithm &ldquo;better&rdquo; than another?</p><h5 class="heading">27.1<tt>&nbsp;</tt><a name="(part._.Motivation)"></a>Motivation<span class="button-group"><a href="#(part._.Motivation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>We&rsquo;ve now seen several data structures that can be used to store collections of items:
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">IList</span><span class="RktMeta"></span></span></span>s, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>s, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">BinaryTree</span><span class="RktMeta"></span></span></span>s and binary search trees, and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span>s.  Primarily we
have introduced each of these types to study some new pattern of object-oriented
construction: interfaces and linked lists, indexed data structures, branching structures,
and wrappers and sentinels.  We&rsquo;ve implemented many of the same algorithms for each data structure:
inserting items, sorting items, finding items, mapping over items, etc.  We might well start to wonder,
is there anything in particular that could help us choose which of these structures to use, and when?</p><p>To guide this discussion, we&rsquo;re going to focus for the next few lectures on various sorting algorithms,
and <span class="emph">analyze</span> them to determine their characteristic performance.  We choose sorting algorithms
for several reasons: they are ubiquitous (almost every problem at some stage requires sorting data), they are
intuitive (the goal is simply to put the data in order; <span class="emph">how</span> that happens is the interesting part!),
they have widely varying performance, and they are fairly straightforward to analyze.  The lessons learned here
apply more broadly than merely to sorting; they can be used to help describe how any algorithm behaves,
and even better, to help <span class="emph">compare</span> one algorithm to another in a meaningful way.</p><h5 class="heading">27.2<tt>&nbsp;</tt><a name="(part._.What_to_measure__and_how_)"></a>What to measure, and how?<span class="button-group"><a href="#(part._.What_to_measure__and_how_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">What kinds of things should we look for, when looking for a &ldquo;good&rdquo; algorithm?  (What does &ldquo;good&rdquo; even
mean in this context?)  Brainstorm several possibilities.</div></p></blockquote><h5 class="heading">27.2.1<tt>&nbsp;</tt><a name="(part._.Adventures_in_time___)"></a>Adventures in time...<span class="button-group"><a href="#(part._.Adventures_in_time___)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>Suppose we have two sorting algorithms available to use for a particular problem.  Both algorithms will
correctly sort a collection of numbers &#8212;<wbr></wbr> we&rsquo;ve tested both algorithms thoroughly, so we have confidence there.
How do we choose between them?  Presumably we&rsquo;d like our code to run quickly, so we choose the &ldquo;faster&rdquo; one.
So we try both algorithms on a particular input, and one of them takes 2 seconds to run, while the other
takes 1.</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict.png" alt="image" width="406" height="406"/></p><p>That hardly seems like enough information to decide which of the two algorithms performs better.
We need to see how the two algorithms fare on <span class="emph">inputs of different sizes</span>, to see how
their performance changes as a function of input size.  It turns out the particular input
above was of size 2.  When we run these two algorithms again on inputs of size 4,
and again on inputs of size 6, we see</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_2.png" alt="image" width="406" height="406"/></p><p>If we connect the dots, we see the following:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_3.png" alt="image" width="406" height="406"/></p><p>Still not much to go on, but it looks like Algorithm A is substantially slower than Algorithm B.
Or is it?  Let&rsquo;s try substantially larger inputs:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_4.png" alt="image" width="406" height="406"/></p><p>It turns out that while Algorithm B started off faster than Algorithm A, it wasn&rsquo;t by much,
and it didn&rsquo;t last very long: even for reasonably small inputs (only 60 items or so),
Algorithm A winds up being substantially faster.</p><p>We have to be quite careful when talking about performance: a program&rsquo;s behavior on
small inputs typically is not indicative of how it will behave on larger inputs.
Instead, we want to categorize the behavior as a function of the input size.
As soon as we start talking about &ldquo;categories&rdquo;, though, we have to decide
just how fine-grained we want them to be.</p><p>For example, the graphs above supposedly measured the running time of these two algorithms
in seconds.  But they don&rsquo;t specify which machine ran the algorithms: if we used
a machine that was twice as fast, the precise numbers in the graphs would change:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_5.png" alt="image" width="406" height="406"/></p><p>But the shapes of the graphs are identical!</p><p>Surely our comparison of algorithms cannot
depend on precisely which machine we use, or else we&rsquo;d have to redo our comparisons every time
new hardware came out.  Instead, we ought to consider something more abstract than elapsed time,
something that is intrinsic to the functioning of the algorithm.  We should count how many
&ldquo;operations&rdquo; it performs: that way, regardless of how quickly a given machine can execute an
&ldquo;operation&rdquo;, we have a stable baseline for comparisons.</p><h5 class="heading">27.2.2<tt>&nbsp;</tt><a name="(part.____and_space)"></a>...and space<span class="button-group"><a href="#(part.____and_space)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>The argument above shows that measuring time is subtle, and we should measure operations instead.
An equivalent argument shows that measuring <span class="emph">memory usage</span> is equally tricky: objects
on a 16-bit controller (like old handheld gaming devices) take up half as much memory
as objects on a 32-bit processor, which take up half as much memory again as on 64-bit machines...
Instead of measuring exact memory usage, we should count <span class="emph">how many objects</span> are created.</p><h5 class="heading">27.2.3<tt>&nbsp;</tt><a name="(part._.It_was_the_best_of_times__it_was_the_worst_of_times___)"></a>It was the best of times, it was the worst of times...<span class="button-group"><a href="#(part._.It_was_the_best_of_times__it_was_the_worst_of_times___)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>In fact, even measuring operations (or allocations) is tricky.  Suppose we were asked,
in real life, to sort a deck of cards numbered 1 through 100.  How long would that take?
If the deck was already sorted, it wouldn&rsquo;t take much time at all, since we&rsquo;d just have to
confirm that it was in the correct order.  On the other hand, if it was fully scrambled,
it might take a while longer.</p><p>Likewise, when we analyze algorithms for their running times, we have to be careful
to consider their behaviors on the best-possible inputs for them, and on the worst-possible
inputs, and (if we can) also on &ldquo;average&rdquo; inputs.  Often, determining what an &ldquo;average&rdquo;
input looks like is quite hard, so we often settle for just determining best and worst-case
behaviors.</p><h5 class="heading">27.2.4<tt>&nbsp;</tt><a name="(part._.You_get_what_you_pay_for)"></a>You get what you pay for<span class="button-group"><a href="#(part._.You_get_what_you_pay_for)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>The graphs and informal descriptions above give a flavor of how we might want to measure runtime behavior
of our programs.  We have to measure at least four things: their best and worst times (as functions of the input size)
and their best and worst memory usages (as functions of the input size).  But you should be skeptical:
is it remotely plausible to talk in vague generalities about &ldquo;operations&rdquo;?
For example, it probably makes very little sense to claim that &ldquo;capitalizing a string of 100 characters&rdquo;
takes the same amount of effort as &ldquo;adding two integers&rdquo; &#8212;<wbr></wbr> but depending on the algorithm we are analyzing,
we might not care about the details of how long capitalizing a string takes.</p><p><div class="SIntrapara">In other words, we have to define a <span class="emph">cost model</span>, that specifies how much each kind of operation of interest
&ldquo;costs&rdquo;.  We can define cost models of varying complexities, but for our purposes, we can make do with a very
simple cost model:
</div><div class="SIntrapara"><ul><li><p>Constants (like <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">1</span><span class="RktMeta"></span></span></span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjLiteral">true</span><span class="RktMeta"></span></span></span>, or <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjString">"hello"</span><span class="RktMeta"></span></span></span>) are free of cost.</p></li><li><p>Every arithmetic operation costs \(1\) unit, plus the costs associated with evaluating its subexpressions.</p></li><li><p>Every method invocation costs \(1\) unit, plus the costs associated with evaluating the arguments, plus
the cost of evaluating the method body.</p></li><li><p>Every statement costs \(1\) unit, plus the costs associated with evaluating its subexpressions.</p></li></ul></div><div class="SIntrapara">Sometimes we will simplify even further, and treat entire methods as costing a single unit.  For example, below, we will analyze
sorting algorithms and simplify the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">swap</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> operation to cost just \(1\) unit.  The goal here is to focus on
just the details that are of greatest interest, and to carefully ignore any other distractions.</div></p><h5 class="heading">27.3<tt>&nbsp;</tt><a name="(part._.Introducing_big-.O_and_big-__notation)"></a>Introducing big-<span style="font-style: italic">O</span> and big-<span style="font-style: italic">&#937;</span> notation<span class="button-group"><a href="#(part._.Introducing_big-.O_and_big-__notation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">We make a few observations, and elaborate them into our full definition:
</div><div class="SIntrapara"><ol><li><p>Performance of an algorithm is best expressed as a function of the size of the input.</p></li><li><p>Since algorithms are often recursive, the performance of an algorithm <span class="emph">at one size</span> often depends the performance of that algorithm <span class="emph">at another size</span>.</p></li><li><p>We need the ability to compare one function to another holistically, to express when one function &ldquo;is no bigger than&rdquo; or &ldquo;no smaller than&rdquo; another function.</p></li><li><p>Comparing two functions ought to behave like less-than-or-equal comparisons should: it should be reflexive, transitive and antisymmetric.</p></li></ol></div></p><h5 class="heading">27.3.1<tt>&nbsp;</tt><a name="(part._.Performance_is_a_function_of_input_sizes)"></a>Performance is a function of input sizes<span class="button-group"><a href="#(part._.Performance_is_a_function_of_input_sizes)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">As a simple example, let&rsquo;s take a look at our familiar implementation for list length:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">interface</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">IList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">MtList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">implements</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">IList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ConsList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">implements</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">IList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">first</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">IList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">public</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">Suppose we ask the question, how much does it cost to evaluate <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">someList</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>?  We can&rsquo;t give a constant answer (say, \(42\)),
because clearly the amount of work we need to perform depends on how many items are in the list.  So let&rsquo;s revise the question:
supposing there are \(n\) items in the list (i.e. \(n\) <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ConsList</span><span class="RktMeta"></span></span></span> objects and one <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">MtList</span><span class="RktMeta"></span></span></span> at the end), how much does it
cost to evaluate <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">someList</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>?
</div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Figure out this cost.  Justify your answer.</div></p></blockquote></div><div class="SIntrapara">To figure out the total cost, we can reason as follows:
</div><div class="SIntrapara"><ol><li><p>For each <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ConsList</span><span class="RktMeta"></span></span></span> item, it costs \(1\) unit to have invoked <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, and within that method
we have to perform one addition (which costs \(1\) unit) on a constant (\(0\) units)
and the result of invoking <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>.  We also need to account for the cost of running that method itself.</p></li><li><p>It costs \(1\) unit to have invoked <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">length</span><span class="RktMeta"></span></span></span>, and \(1\) more unit to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="RktMeta"></span></span></span> in the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">MtList</span><span class="RktMeta"></span></span></span> case.</p></li></ol></div><div class="SIntrapara">If everything in this breakdown were known, we&rsquo;d just add up the results and have our answer.  But there is a serious problem here: in the second step,
the cost of the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ConsList</span><span class="RktMeta"></span></span></span>&rsquo;s <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">length</span><span class="RktMeta"></span></span></span> method depends on ... the cost of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, which is the cost we&rsquo;re trying to determine!</div></p><p>Or is it?  Our original question was to determine the cost of evaluating <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">someList</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, not <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">someList</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> &#8212;<wbr></wbr> that <span class="emph">subproblem</span>
will contribute to the cost of the original problem, certainly.  So for now, let&rsquo;s simply <span class="emph">ignore</span> that recursive call.  (We&rsquo;ll justify below why that&rsquo;s
acceptable.)  If we do that, we can now determine the total cost of the original problem: we multiply the cost of each step by the number of times that step
executes, and add them all up.  In total: \(n * (1 + 1 + 0) + (1 + 1) = 2n+2\).</p><h5 class="heading">27.3.2<tt>&nbsp;</tt><a name="(part._.Performance_of_recursive_algorithms)"></a>Performance of recursive algorithms<span class="button-group"><a href="#(part._.Performance_of_recursive_algorithms)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Another way to express the reasoning above is as follows.  Let&rsquo;s imagine a function \(T(n)\), whose values we wish to represent the <span class="emph">time</span> cost
of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> for inputs of size \(n\).  How might we define this function?
</div><div class="SIntrapara"><ul><li><p>When \(n = 0\), the list is empty, and we determined above that the cost is \(1\) to have invoked the method, and \(1\) more for the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="RktMeta"></span></span></span> statement.</p></li><li><p>When \(n &gt; 0\), the list is non-empty.  We determined above that the cost is \(1\) to have invoked the method, \(1\) for the addition, \(0\) for the constant,
plus <span class="emph">whatever the cost of running <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">length</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> is</span>.  Above, we ignored this
entirely.  But now we have a better answer: the rest of this list has size <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">-</span><span class="ProfjLiteral">1</span><span class="RktMeta"></span></span></span>, and we have a function for describing the
cost of running the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">length</span><span class="RktMeta"></span></span></span> method &#8212;<wbr></wbr> it&rsquo;s \(T\) itself!</p></li></ul></div><div class="SIntrapara">In other words, our definition for \(T\) is:
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}T(n) = \begin{cases}
         2 &amp;\text{when $n = 0$} \\
         2 + T(n-1) &amp;\text{when $n &gt; 0$}
       \end{cases}\end{equation*}</p></div><div class="SIntrapara">Our defintion of the cost of our method is recursive, just like our method itself is!  These sorts of definitions are known as <span class="emph">recurrence relations</span>,
and they are perfectly valid ways to define functions.  (Of course, we have to be careful about base cases and ensuring that the definitions terminate,
just as we did with recursive functions in our code...)</div></p><p><div class="SIntrapara">The drawback to recurrence relations is that they are somewhat tricky to work with: after all, our reasoning above gave us a nice simple formula \(2n+2\),
whereas this recurrence gives us some recursive procedure by which to compute the answer we want.  The former solution is <span class="emph">closed-form</span>, meaning
it doesn&rsquo;t refer recursively to itself, unlike the explicitly-recursive recurrence.
</div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Prove that \(T(n) = 2n + 2\) is a closed-form solution to the recurrence above.</div></p></blockquote></div><div class="SIntrapara">One way we can convince ourselves that \(T(n) = 2n+2\) is in fact the closed-form solution to our recurrence is to unfold the recurrence a few times:
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
T(n) &amp;= 2 + T(n-1) &amp;\text{when $n &gt; 0$} \\
     &amp;= 2 + (2 + T(n-2)) &amp;\text{when $n-1 &gt; 0$} \\
     &amp;= 2 + (2 + (2 + T(n-3))) &amp;\text{when $n-2 &gt; 0$} \\
     &amp;= \ldots \\
     &amp;= 2 + \underbrace{(2 + (2 + \ldots + 2))}_{n\text{ times}} &amp;\text{when we reach the base case} \\
     &amp;= 2 + n * 2 = 2n+2
\end{aligned}\end{equation*}</p></div><div class="SIntrapara">(A formal proof would proceed by induction on \(n\), and would perform much the same steps of reasoning.)  Notice that the last step
amounts to the justification for why we skipped the recursive call in the section above: because we now know that every recursive
call (besides the base case) performs the same computational steps, we can count only those operations that occur in &ldquo;this&rdquo; step, and
account for the recursive call by simply multiplying by the number of subproblems remaining.</div></p><h5 class="heading">27.3.3<tt>&nbsp;</tt><a name="(part._.How_can_we_compare_functions_)"></a>How can we compare functions?<span class="button-group"><a href="#(part._.How_can_we_compare_functions_)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>It&rsquo;s comforting to think that all we need to do is count the steps in our code, and somehow we&rsquo;ll simply obtain the correct answer.  But
this counting is weirdly too-precise: because our cost model over-simplifies (such that arithmetic and function calls are equally costly),
we shouldn&rsquo;t have much confidence that the particular coefficients in our formula above are actually correct.  Perhaps function calls are five times
as expensive as arithmetic, or perhaps return statements are ten times more costly than we thought.  If so, our formula changes from \(T(n) = 2n+2\) to
\(T(n) = 6n+11\).  Should we care about these detailed changes, or is the formula &ldquo;more or less the same&rdquo;?</p><p>Let&rsquo;s try to make this notion of &ldquo;roughly the same&rdquo; a bit more precise.  The key idea here is to define an <span class="emph">upper bound</span> for functions, as follows.
Look at the function \(T(n)=2n+2\) again: as \(n\) gets larger and larger, that \(+2\) becomes proportionately less and less relevant to the overall value of the function.
In fact, we could even add a bounded but arbitrarily wiggling function, rather than a constant, and the overall shape of the function still stays the same:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_6.png" alt="image" width="351" height="406"/>
<img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_7.png" alt="image" width="351" height="406"/></p><p>But clearly there will always be numbers for which \(2n\) is less than the other two.  So it cannot be an upper bound for the other two functions.  What if we try \(2.1n\)?</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_8.png" alt="image" width="351" height="406"/>
<img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_9.png" alt="image" width="351" height="406"/>
At first, for small values of \(n\), things haven&rsquo;t changed much: the wiggling function still is both greater and less than \(2.1n\).  But notice that even for fairly small
values of \(n\), we have that \(2.1n &gt; 2n+2\).  And if we go to larger values of \(n\), then \(2.1n\) is clearly greater than the other two functions.
Since the functions&rsquo; values for small \(n\) are not that big, we&rsquo;re concerned primarily with large \(n\), and in those cases, it looks like \(2.1n\)
is indeed an upper bound for the other two functions.  We say that we&rsquo;re concerned with the <span class="emph">asymptotic</span> behavior, as \(n\) gets bigger and bigger.</p><p><div class="SIntrapara">Of course, picking \(2.1\) as a coefficient was arbitrary: just about any positive number would suffice.  So how could we choose between all the possible candidates?
We don&rsquo;t!  Instead, we consider them all to equivalent, in the following sense:
</div><div class="SIntrapara"><blockquote class="SubFlow"><p><div class="SIntrapara">A function \(g(x)\) is said to be an upper bound for a function \(f(x)\) if there exists some constant \(c\) such that for all &ldquo;sufficiently large&rdquo; values of \(x\),
\(f(x)\) is less than \(c\) times \(g(x)\):
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\exists c . \exists N . \forall x &gt; N . |f(x)| \leq c|g(x)|\end{equation*}</p></div></p></blockquote></div><div class="SIntrapara">(We formalize &ldquo;sufficiently large&rdquo; by picking some constant \(N\), and taking all values of \(x\) greater than \(N\).)  Notice that for any given function \(g(x)\), there
are many functions for which it is an upper bound.  We define the notation \(O(g)\) (pronounced &ldquo;big-oh of g&rdquo;) to mean this entire set.  Accordingly, we
write that \(f \in O(g)\) whenever \(g\) is an upper bound for \(f\), as above.</div></p><p><div class="SIntrapara">Relatedly, we can also define <span class="emph">lower bounds</span> for functions:
</div><div class="SIntrapara"><blockquote class="SubFlow"><p><div class="SIntrapara">A function \(f(x)\) is said to be a lower bound for a function \(g(x)\) if there exists some constant \(c\) such that for all &ldquo;sufficiently large&rdquo; values of \(x\),
\(f(x)\) is less than \(c\) times \(g(x)\):
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\exists c . \exists N . \forall x &gt; N . f(x) &lt; c g(x)\end{equation*}</p></div></p></blockquote></div><div class="SIntrapara">We use the notation \(g \in \Omega(f)\) (pronounced &ldquo;big-omega of f&rdquo;) for this case.</div></p><p>Intuitively, we will use \(O(\cdot)\) to indicate worst-case behavior (i.e., &ldquo;this algorithm gets no worse than this upper bound&rdquo;), and \(\Omega(\cdot)\) to indicate
best-case behavior (i.e. &ldquo;this algorithm can never do better than this lower bound&rdquo;).</p><h5 class="heading">27.3.4<tt>&nbsp;</tt><a name="(part._.Convenient_properties_of_big-.O_notation)"></a>Convenient properties of big-<span style="font-style: italic">O</span> notation<span class="button-group"><a href="#(part._.Convenient_properties_of_big-.O_notation)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Having defined two fairly technical mathematical notions, what benefits do we gain?  Formally, we should show that big-\(O\) notation
defines an equivalence relation:
</div><div class="SIntrapara"><ul><li><p>Reflexivity: For every function \(f\), it&rsquo;s always the case that \(f\) is its own upper bound, i.e. \(f \in O(f)\).</p></li><li><p>Transitivity: For all functions \(f\), \(g\) and \(h\), if \(f \in O(g)\) and \(g \in O(h)\), then \(f \in O(h)\).</p></li><li><p>Symmetry: For all functions \(f\) and \(g\), if \(f \in O(g)\) and \(g \in O(f)\), then \(f\) and \(g\) are essentially &ldquo;equal&rdquo; up to constant factors.</p></li></ul></div><div class="SIntrapara"><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Prove these properties.</div></p></blockquote></div><div class="SIntrapara">Informally, these notions let us ignore the &ldquo;fiddly&rdquo; details of our formulas above, and simplify them to their essence:
</div><div class="SIntrapara"><ul><li><p>Suppose we have a constant function \(f(x) = c\).  Then we can immediately tell that \(f \in O(1)\) &#8212;<wbr></wbr> \(c\) is clearly the upper bound for this function, since it doesn&rsquo;t grow at all!</p></li><li><p>Suppose we have two functions such that \(f \in O(g)\).  What can we say about the asymptotic behavior of \(h(x) = k * f(x)\) for some constant \(k\)?
We know that \(f \in O(g)\) means that for large enough \(x\), \(|f(x)| \leq c |g(x)|\) for some constant \(c\).  With a little algebra, we can
easily show that \(|h(x)| \leq (c/k)|g(x)|\) &#8212;<wbr></wbr> which means that \(h \in O(g)\) also.  In other words,
<span class="emph">multiplying functions by constants doesn&rsquo;t affect their asymptotic behavior</span>.</p></li><li><p>Suppose again we have two functions such that \(f \in O(g)\).  What can we say about \(h(x) = f(x) + k\)?  It&rsquo;s straightforward to show
\(h \in O(f)\), and so by transitivity \(h \in O(g)\).  In other words, <span class="emph">adding constants to functions doesn&rsquo;t affect their asymptotic behavior</span>.</p></li></ul></div><div class="SIntrapara">With a little more effort, we can see that these rules let us simplify any polynomial formula we get to just its leading term: we can say that
a function \(f\) grows <span class="emph">linearly</span> in \(n\), or <span class="emph">quadratically</span>, <span class="emph">cubically</span> etc.,
and what we mean is that \(f \in O(n)\), \(f \in O(n^2)\), \(f \in O(n^3)\) etc., without worrying about any lower-order terms.</div></p><p>Even better, we can use these big-\(O\) properties to analyze algorithms quickly and easily, especially when they involve loops.</p><h5 class="heading">27.4<tt>&nbsp;</tt><a name="(part._.Analyzing_insertion-sort)"></a>Analyzing insertion-sort<span class="button-group"><a href="#(part._.Analyzing_insertion-sort)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Recall the definition of insertion sort on lists of integers:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">interface</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">sort</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">insert</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">MtLoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">sort</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">insert</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ConsLoInt</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ConsLoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">first</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ConsLoInt</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">first</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">rest</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">first</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">first</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">sort</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">sort</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">insert</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">first</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ILoInt</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">insert</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">first</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ConsLoInt</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">first</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">rest</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">insert</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ConsLoInt</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">this</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">How shall we analyze this code?  We have four analyses to conduct: how many operations are performed, and how many objects are allocated,
in the best and worst cases?</div></p><p><div class="SIntrapara">First let&rsquo;s figure out how expensive <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span> is, for a list of length \(n\).  We need to determine functions \(T_{insert}(n)\) for the runtime of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span>, and
\(M_{insert}(n)\) for its memory usage.
</div><div class="SIntrapara"><ul><li><p>When \(n = 0\), we&rsquo;re inserting an item into an empty list, and this performs one allocation, and one statement.  So \(T_{insert}(0) = 1\), and \(M_{insert}(0) = 1\).</p></li><li><p><div class="SIntrapara">In the best case, the number to be inserted is less than everything else in the list.
      In that case, we perform one comparison, and construct one <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ConsLoInt</span><span class="RktMeta"></span></span></span>.
      In other words, we have
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
T_{insert}^{best}(n) &amp;= 1 \\
M_{insert}^{best}(n) &amp;= 1
\end{aligned}\end{equation*}</p></div></p></li><li><p><div class="SIntrapara">In the worst case, the number to be inserted is greater than everything else in the list, and so must be inserted at the back.
                In that case, we have
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
T_{insert}^{worst}(n) &amp;= 3 + T_{insert}^{worst}(n-1) \\
                      &amp;= \underbrace{3 + 3 + \cdots + 3}_{n\text{ times}} + 1 \\
                      &amp;= 3n + 1 \\
M_{insert}^{worst}(n) &amp;= 1 + M_{insert}^{worst}(n-1) \\
                      &amp;= \underbrace{1 + 1 + \cdots + 1}_{n\text{ times}} + 1 \\
                      &amp;= n + 1 \\
\end{aligned}\end{equation*}</p></div><div class="SIntrapara">for the number of operations, because we must examine every single item in the list.  From the best and worst case results we can conclude that
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{alignedat}{2}
      1 &amp;\leq T_{insert}(n) &amp;&amp;\leq 3n+1 \\
      1 &amp;\leq M_{insert}(n) &amp;&amp;\leq n+1
\end{alignedat}\end{equation*}</p></div><div class="SIntrapara">We can summarize our results as follows:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Runtime for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Best-case</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Worst-case</span></p></td></tr><tr><td><p>\(T_{insert}\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(\Omega(1)\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(O(n)\)</p></td></tr><tr><td><p>\(M_{insert}\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(\Omega(1)\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(O(n)\)</p></td></tr></table></div></p></li></ul></div><div class="SIntrapara">Now to examine <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span>, again for a list of length \(n\).  Again we need to define functions \(T_{sort}(n)\) for the runtime, and \(M_{sort}(n)\) for the memory usage.
</div><div class="SIntrapara"><ul><li><p><div class="SIntrapara">When \(n = 0\), <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span> clearly takes constant time, because it does a constant number of operations, and allocates zero objects.  So
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
T_{sort}(n) &amp;= 1 \\
M_{sort}(n) &amp;= 0
\end{aligned}\end{equation*}</p></div></p></li><li><p><div class="SIntrapara">In the recursive case, we perform two operations: we <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span> the rest of the list, and we <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span> an item into it.  This
      translates neatly to the recurrence relations
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
  T_{sort}(n) &amp;= T_{sort}(n-1) + T_{insert}(n-1) \\
  M_{sort}(n) &amp;= M_{sort}(n-1) + M_{insert}(n-1)
\end{aligned}\end{equation*}</p></div></p><p><div class="SIntrapara">In the best case, we substitute our best-case formulas for \(T_{insert}^{best}\) and \(M_{insert}^{best}\) to obtain:
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
  T_{sort}^{best}(n) &amp;= T_{sort}^{best}(n-1) + T_{insert}^{best}(n-1) \\
                     &amp;= T_{sort}^{best}(n-1) + 1 \\
                     &amp;= \underbrace{1 + 1 + \cdots + 1}_{n\text{ times}} + 1 \\
                     &amp;= n + 1 \\
  M_{sort}^{best}(n) &amp;= M_{sort}^{best}(n-1) + M_{insert}^{best}(n-1) \\
                     &amp;= M_{sort}^{best}(n-1) + 1 \\
                     &amp;= \underbrace{1 + 1 + \cdots + 1}_{n\text{ times}} + 1 \\
                     &amp;= n + 1
\end{aligned}\end{equation*}</p></div><div class="SIntrapara">In other words, in the best case, insertion sort is <span class="emph">linear</span> in the size of the list.</div></p><p><div class="SIntrapara">In the worst case, we substitute our worst-case formulas for \(T_{insert}^{worst}\) and \(M_{insert}^{worst}\) to obtain:
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
  T_{sort}^{worst}(n) &amp;= T_{sort}^{worst}(n-1) + T_{insert}^{worst}(n-1) \\
                      &amp;= T_{sort}^{worst}(n-1) + (3(n-1) + 1) \\
  M_{sort}^{worst}(n) &amp;= M_{sort}^{worst}(n-1) + M_{insert}^{worst}(n-1) \\
                      &amp;= M_{sort}^{wrost}(n-1) + ((n-1) + 1) \\
\end{aligned}\end{equation*}</p></div><div class="SIntrapara">Solving these recurrences is a bit trickier, because \(T_{insert}^{worst}\) and \(M_{insert}^{worst}\) are not constant functions.
      If we unroll the recurrence a few times, we start to see a pattern (here illustrated only for \(T_{sort}^{worst}\), but \(M_{sort}^{worst}\) behaves the same way):
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
  T_{sort}^{worst}(n) &amp;= T_{sort}^{worst}(n-1) + T_{insert}^{worst}(n-1) \\[2ex]
                      &amp;\qquad\text{substitute for $T_{insert}^{worst}(n-1)$} \\[2ex]
                      &amp;= T_{sort}^{worst}(n-1) + (3(n-1) + 1) \\[2ex]
                      &amp;\qquad\text{substitute for $T_{sort}^{worst}(n-1)$} \\[2ex]
                      &amp;= (T_{sort}^{worst}(n-2) + (3(n-2) + 1)) + (3(n-1) + 1) \\[2ex]
                      &amp;\qquad\text{substitute for $T_{sort}^{worst}(n-2)$} \\[2ex]
                      &amp;= ((T_{sort}^{worst}(n-3) + (3(n-3) + 1)) + (3(n-2) + 1)) + (3(n-1) + 1) \\[2ex]
                      &amp;\qquad\text{keep unrolling until we reach the base case} \\[2ex]
                      &amp;= T_{sort}^{worst}(0) + (3(1) + 1) + (3(2) + 1) + \cdots + (3(n-2) + 1) + (3(n-1) + 1) \\[2ex]
                      &amp;\qquad\text{rearrange the formula a bit} \\[2ex]
                      &amp;= 1 + \sum_{i=1}^{n-1}(3i + 1) \\
                      &amp;= 1 + 3\sum_{i=1}^{n-1}i + \sum_{i=1}^{n-1}1 \\
                      &amp;= 1 + 3(n(n-1)/2) + (n-1) \\
                      &amp;= 3(n(n-1)/2) + n \\
                      &amp;\in O(n^2)
\end{aligned}\end{equation*}</p></div><div class="SIntrapara">In other words, in the worst case, insertion sort is <span class="emph">quadratic</span> in the size of the list.</div></p></li></ul></div><div class="SIntrapara">From the best and worst case results we can conclude that
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{alignedat}{2}
      1 &amp;\leq T_{sort}(n) &amp;&amp;\leq 3(n(n-1)/2) + n \\
      1 &amp;\leq M_{sort}(n) &amp;&amp;\leq n(n+1)/2
\end{alignedat}\end{equation*}</p></div><div class="SIntrapara">We can summarize our results as follows:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Runtime for insertion-sort</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Best-case</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Worst-case</span></p></td></tr><tr><td><p>\(T_{sort}\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(\Omega(n)\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(O(n^2)\)</p></td></tr><tr><td><p>\(M_{sort}\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(\Omega(n)\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(O(n^2)\)</p></td></tr></table></div></p><p><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara"><span class="emph">When</span> do the best cases and worst cases happen for insertion-sort?  Describe the inputs that lead to these cases.</div></p></blockquote></div><div class="SIntrapara">The best case for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span> depends on repeatedly triggering the best-case behavior for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span>.  Conversely, the worst case
for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span> depends on repeatedly hitting the worst-case behavior for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span>.  So when are the best and worst cases for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span>?</div></p><p>The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span> routine finishes quickest when the item to be inserted is smaller than the first item of the list.  Given that <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span>
works its way to the end of the list, and then repeatedly <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span>s items from back-to-front to grow the newly sorted list, the best case
behavior happens when the next-to-last item is smaller than the last item, the next-to-next-to-last item is smaller than that, ..., and the first
item is smaller than the second: in other words, when the list is already sorted!</p><p>Conversely, the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">insert</span><span class="RktMeta"></span></span></span> routine finishes slowest when the item to be inserted is greater than everything in the list.  By this reasoning,
the worst case behavior of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">sort</span><span class="RktMeta"></span></span></span> happens when the smallest item of the input is last, and the largest item is first: in other words,
when the list is sorted exactly backwards.</p><p>Since most orders of numbers lie somewhere between these two extremes, the behavior of insertion sort &ldquo;on average&rdquo; is somewhere between
linear and quadratic in the size of the input.</p><h5 class="heading">27.5<tt>&nbsp;</tt><a name="(part._.Analyzing_selection-sort)"></a>Analyzing selection-sort<span class="button-group"><a href="#(part._.Analyzing_selection-sort)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara"><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Repeat this analysis for selection-sort.</div></p></blockquote></div><div class="SIntrapara">Recall the definition of selection-sort: we define it in an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayUtils</span><span class="RktMeta"></span></span></span> helper class, to work over <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayLists</span><span class="RktMeta"></span></span></span> as follows:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">class</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayUtils</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">swap</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">index1</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">index2</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">oldValueAtIndex2</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">index2</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjError">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">set</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">index2</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">index1</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">set</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">index1</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">oldValueAtIndex2</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">findMinIndex</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">startFrom</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">IComparator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">comp</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">minSoFar</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">startFrom</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestSoFar</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">startFrom</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">startFrom</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">comp</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">compare</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">i</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">minSoFar</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">        </span><span class="ProfjIdentifier">minSoFar</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">i</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">        </span><span class="ProfjIdentifier">bestSoFar</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestSoFar</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">selectionSort</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">IComparator</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">comp</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">minIdx</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">findMinIndex</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">comp</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">swap</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">minIdx</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div></p><p><div class="SIntrapara">Again, we analyze each method in turn, assuming our <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span> is of size \(n\).  Notice that this algorithm never allocates anything, so \(M_{selectionSort}(n) = 0\).
</div><div class="SIntrapara"><ul><li><p><div class="SIntrapara">The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">swap</span><span class="RktMeta"></span></span></span> method performs four operations, in every situation.
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
T_{swap}(n) &amp;= 4
\end{aligned}\end{equation*}</p></div></p></li><li><p><div class="SIntrapara">Analyzing <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">findMinIndex</span><span class="RktMeta"></span></span></span> is a bit trickier.  Let&rsquo;s <span class="emph">assume</span> that we can execute <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">comp</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">compare</span><span class="RktMeta"></span></span></span> in constant (i.e. \(O(1)\)) time &#8212;<wbr></wbr> for concreteness,
let&rsquo;s call that time \(t_{comp}\).
</div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">What are the best and worst cases for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">findMinIndex</span><span class="RktMeta"></span></span></span>?</div></p></blockquote></div><div class="SIntrapara">The body of the loop invokes <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">comp</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">compare</span><span class="RktMeta"></span></span></span> once, performs one numeric comparison, and then performs up to two more assignment statements.
Based on our assumption, the loop body therefore executes in \(O(1)\) time.  But how many times does it execute?  Let&rsquo;s define \(T_{findMinIndex}(n)\)
to be the runtime of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">findMinIndex</span><span class="RktMeta"></span></span></span> when the difference <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">arr</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">startFrom</span><span class="RktMeta"></span></span></span> is \(n\): in other words, \(n\) here is the number
of times the loop iterates.  The performance of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">findMinIndex</span><span class="RktMeta"></span></span></span> is the same in best or worst cases (because the loop always runs the same number of times,
and runs the same loop body every time), and is </div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}T_{findMinIndex}(n) = n * (t_{comp} + 4) + 3\end{equation*}</p></div></p></li><li><p>Analyzing <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">selectionSort</span><span class="RktMeta"></span></span></span> is simpler.  The body of the loop costs \(T_{findMinIndex}(n) + T_{swap}\).  The loop itself executes \(n\) times.
      Since the performance of \(T_{findMinIndex}\) is the same in the best and worst cases, the runtime of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">selectionSort</span><span class="RktMeta"></span></span></span> is
      \(T_{selectionSort} \in n * O(n) = O(n^2)\).</p><p><div class="SIntrapara">But wait!  That analysis is a bit too simplistic: each time we call <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">findMinIndex</span><span class="RktMeta"></span></span></span> inside the loop,
      the length of the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span> stays the same, but the starting index increases, so later calls to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">findMinIndex</span><span class="RktMeta"></span></span></span> must be cheaper
      than earlier ones.  A more careful analysis leads us to
</div><div class="SIntrapara"><p type="math/tex" style="white-space: pre;" class="stt">\begin{equation*}\begin{aligned}
      T_{selectionSort}(n) &amp;= T_{findMinIndex}(n) + T_{findMinIndex}(n-1) + \cdots + T_{findMinIndex}(n - n) \\
                           &amp;= ((4+t_{comp})(n)+2) + ((4+t_{comp})(n-1) + 2) + \cdots + ((4+t_{comp})(1) + 2) \\
                           &amp;= \sum_{i=0}^{n} ((4+t_{comp})i+2) \\
                           &amp;= (4+t_{comp})\sum_{i=0}^{n} i + \sum_{i=0}^{n} 2 \\
                           &amp;= (4+t_{comp})(n(n+1)/2) + 2n + 2\\
                           &amp;\in O(n^2)
\end{aligned}\end{equation*}</p></div><div class="SIntrapara">In this case, the quick analysis leads to the same answer as the more detailed analysis, but for more complicated algorithms, the more detailed analysis may lead to a better
      upper bound.</div></p></li></ul></div></p><p><div class="SIntrapara">We can summarize our results as follows:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Runtime for selection-sort</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Best-case</span></p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p><span style="font-weight: bold">Worst-case</span></p></td></tr><tr><td><p>\(T_{selectionSort}\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(\Omega(n^2)\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(O(n^2)\)</p></td></tr><tr><td><p>\(M_{selectionSort}\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(\Omega(1)\)</p></td><td><p><span class="hspace">&nbsp;&nbsp;</span></p></td><td><p>\(O(1)\)</p></td></tr></table></div></p><p><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara"><span class="emph">When</span> do the best cases and worst cases happen for selection-sort?  Describe the inputs that lead to these cases.</div></p></blockquote></div><div class="SIntrapara">The best-case and worst-case behaviors of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">selectionSort</span><span class="RktMeta"></span></span></span> are the same: \(O(n^2)\).  So <span class="emph">any</span> input leads to this behavior.</div></p><h5 class="heading">27.6<tt>&nbsp;</tt><a name="(part._.Discussion)"></a>Discussion<span class="button-group"><a href="#(part._.Discussion)" class="heading-anchor" title="Link to here">🔗</a><span style="visibility: hidden"> </span></span></h5><p>At first glance, a quadratic runtime doesn&rsquo;t seem egregiously worse than linear runtime &#8212;<wbr></wbr> it&rsquo;s just one degree higher, right?  But if we examine large values of \(n\),
the difference becomes obvious:</p><p><img style="vertical-align: 0px; margin: -3px -3px -3px -3px;" src="pict_10.png" alt="image" width="406" height="406"/></p><p>Our insertion-sort algorithm could have runtime performance anywhere in this range, depending on whether we get a best-case input,
a worst-case input, or something in between.  This variance in performance is often not acceptable, and worst-case behavior this bad
is often not acceptable at all.  (And this is still for small values of \(n\)!  Consider what would happen when trying to select
the best search results on the entire internet, where \(n\) is
roughly a few trillion: the worst-case behavior would be <span class="emph">trillions</span> of times worse than the best-case behavior!)
In the next lecture, we&rsquo;ll examine two more sorting algorithms, which both have better worst-case behaviors than these.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="lecture26.html" title="backward to &quot;Lecture 26: Hashing and Equality&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture28.html" title="forward to &quot;Lecture 28: Quicksort and Mergesort&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>