<!doctype HTML>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="codemirror.js"></script>
<script src="python.js"></script>
<script src="runmode.js"></script>
<script src="setup-page.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 31: Dijkstra's Algorithm for single-source shortest paths</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra-styles.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Fundamentals II
<br/>
Introduction to Class-<wbr></wbr>based Program Design</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="General.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="Texts.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="Lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="Lab_Materials.html" class="tocviewlink" data-pltdoc="x">Lab Materials</a></td></tr><tr><td align="right"></td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right"></td><td><a href="Pair_Programming_Overview.html" class="tocviewlink" data-pltdoc="x">Pair Programming Overview</a></td></tr><tr><td align="right"></td><td><a href="code-style.html" class="tocviewlink" data-pltdoc="x">Code style</a></td></tr><tr><td align="right"></td><td><a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Data Definitions in Java</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 2:</span> Data Definitions:<span class="mywbr"> &nbsp;</span> Unions</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 3:</span> Methods for simple classes</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Methods for unions</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 5:</span> Methods for self-<wbr></wbr>referential lists</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Accumulator methods</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Accumulator methods, continued</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Practice Design</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 9:</span> Abstract classes and inheritance</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 10:</span> Customizing constructors for correctness and convenience</a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 11:</span> Defining sameness for complex data, part 1</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Defining sameness for complex data, part 2</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 13:</span> Abstracting over behavior</a></td></tr><tr><td align="right"></td><td><a href="lecture14.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Abstractions over more than one argument</a></td></tr><tr><td align="right"></td><td><a href="lecture15.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 15:</span> Abstracting over types</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Visitors</a></td></tr><tr><td align="right"></td><td><a href="lecture17.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 17:</span> Mutation</a></td></tr><tr><td align="right"></td><td><a href="lecture18.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 18:</span> Mutation inside structures</a></td></tr><tr><td align="right"></td><td><a href="lecture19.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 19:</span> Mutation, aliasing and testing</a></td></tr><tr><td align="right"></td><td><a href="lecture20.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 20:</span> Mutable data structures</a></td></tr><tr><td align="right"></td><td><a href="lecture21.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 21:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a></td></tr><tr><td align="right"></td><td><a href="lecture22.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 22:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a></td></tr><tr><td align="right"></td><td><a href="lecture23.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 23:</span> For-<wbr></wbr>each loops and Counted-<wbr></wbr>for loops</a></td></tr><tr><td align="right"></td><td><a href="lecture24.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 24:</span> While loops</a></td></tr><tr><td align="right"></td><td><a href="lecture25.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 25:</span> Iterator and Iterable</a></td></tr><tr><td align="right"></td><td><a href="lecture26.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 26:</span> Hashing and Equality</a></td></tr><tr><td align="right"></td><td><a href="lecture27.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis</a></td></tr><tr><td align="right"></td><td><a href="lecture28.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 28:</span> Quicksort and Mergesort</a></td></tr><tr><td align="right"></td><td><a href="lecture29.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 29:</span> Priority Queues and Heapsort</a></td></tr><tr><td align="right"></td><td><a href="lecture30.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 30:</span> Breadth-<wbr></wbr>first search and Depth-<wbr></wbr>first search on graphs</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 31:</span> Dijkstra&rsquo;s Algorithm for single-<wbr></wbr>source shortest paths</a></td></tr><tr><td align="right"></td><td><a href="lecture32.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees</a></td></tr><tr><td align="right"></td><td><a href="lecture33.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 33:</span> Implementing Objects</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 31:</span> Dijkstra&rsquo;s Algorithm for single-<wbr></wbr>source shortest paths</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">31.1&nbsp;</td><td><a href="#%28part._.Staying_frugal__.Finding_a_cheapest_path_between_two_vertices%29" class="tocviewlink" data-pltdoc="x">Staying frugal:<span class="mywbr"> &nbsp;</span> Finding a <span class="emph">cheapest</span> path between two vertices</a></td></tr><tr><td align="right">31.2&nbsp;</td><td><a href="#%28part._.Dijkstra_s_algorithm%29" class="tocviewlink" data-pltdoc="x">Dijkstra&rsquo;s algorithm</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">31.1<tt>&nbsp;</tt></span><a href="#%28part._.Staying_frugal__.Finding_a_cheapest_path_between_two_vertices%29" class="tocsubseclink" data-pltdoc="x">Staying frugal:<span class="mywbr"> &nbsp;</span> Finding a <span class="emph">cheapest</span> path between two vertices</a></td></tr><tr><td><span class="tocsublinknumber">31.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Efficiency_of_cheapest-first_search%29" class="tocsubseclink" data-pltdoc="x">Efficiency of cheapest-<wbr></wbr>first search</a></td></tr><tr><td><span class="tocsublinknumber">31.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Rewriting_.B.F.S_and_.D.F.S_again%29" class="tocsubseclink" data-pltdoc="x">Rewriting BFS and DFS again</a></td></tr><tr><td><span class="tocsublinknumber">31.2<tt>&nbsp;</tt></span><a href="#%28part._.Dijkstra_s_algorithm%29" class="tocsubseclink" data-pltdoc="x">Dijkstra&rsquo;s algorithm</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.14</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="lecture30.html" title="backward to &quot;Lecture 30: Breadth-first search and Depth-first search on graphs&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture32.html" title="forward to &quot;Lecture 32: Minimum Spanning Trees&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h4 class="heading"><a name="(part._)"></a><span class="LectureNum">Lecture 31:</span> Dijkstra&rsquo;s Algorithm for single-source shortest paths<span class="button-group"><a href="#(part._)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p class="boxed">Computing the shortest path between two nodes; comparison with breadth- and depth-first searches</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The explanation of the algorithm here is slightly different than
the classic presentation.  It has been adapted to more closely fit the style of
the last lecture.  See the last section for details of the differences.</p></blockquote></blockquote></blockquote><p>In the <a href="lecture30.html" data-pltdoc="x">last lecture</a>, we considered two approaches for finding
<span class="emph">some</span> path between a source and target node in a graph.  With <span class="emph">depth
first search</span>, we started from the source, and chose any edge leading out of
it.  We continued down that edge, choosing any subsequent edge, and kept diving
deeper and deeper into the graph, provided always that we didn&rsquo;t double-back
and reach a vertex we&rsquo;d already seen.  If there were no further edges available
to us, we backtracked to the previous node, and considered some other edge
leading away from it.  This algorithm ensures that we completely exhaust all
possibilities of paths through a given node before we abandon it and move on:
once we backtrack out of a node, we know there is no possible way for that node
to reach our target.</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Why?</div></p></blockquote><p>With <span class="emph">breadth-first search</span>, we started from the source, then considered
all nodes reachable from there.  Then we considered all nodes reachable from
any of those (i.e. reachable within two edges from the source.)  Then we
considered any nodes reachable from those (i.e., reachable within three edges
from the source).  We continued in this manner until we eventually found the
source.  This algorithm ensures that we completely exhaust all short paths
before trying longer ones, and ensures that we find the shortest path to the
target.</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">&ldquo;The&rdquo; shortest path or merely &ldquo;a&rdquo; shortest path?  Why?</div></p></blockquote><p>However, not all paths are always created equal.</p><h5 class="heading">31.1<tt>&nbsp;</tt><a name="(part._.Staying_frugal__.Finding_a_cheapest_path_between_two_vertices)"></a>Staying frugal: Finding a <span class="emph">cheapest</span> path between two vertices<span class="button-group"><a href="#(part._.Staying_frugal__.Finding_a_cheapest_path_between_two_vertices)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Suppose we&rsquo;re trying to book a cross-country flight.  A simplistic approach
would simply build a graph whose nodes are airports and whose edges are flights
between them, and search for any path connecting our source to our destination.</p><p>But not all flights are equally appealing.  We might choose to
prioritize ticket prices over everything else, and be willing to accept a
lengthier travel duration to accomplish it.  Or we might prioritize travel time
over all else, and be willing to buy a more expensive flight to get to our
destination faster.  Or we might be fuel-conscious, and focus on a shortest
total flight distance at the expense of time or money.  Or we might prioritize
convenient departure times, or arrival times, or ...  Evidently, the
apparent <span class="emph">cost</span> of a given flight between two locations might depend on
many factors, and treating all edges in the graph equally doesn&rsquo;t capture
that.  Instead we need a <span class="emph">weighted graph</span>, where the edge weights capture
our intended priorities about the attractiveness of individual flights.  And
our goal is not to achieve the fewest flights, but the <span class="emph">cheapest</span> flight
according to our weights.</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Depth-first search was a general search technique that used a
stack as its worklist.  Breadth-first search was a general search technique that
used a queue as its worklist.  What data structure do you expect we ought to
use for searching by best weight?</div></p></blockquote><p>In <a href="lecture29.html" data-pltdoc="x">Lecture 29</a> we encountered <span class="emph">priority queues</span>, which were a data
structure that supported efficiently adding prioritized items, and removing the
highest-priority item.  In that setting, our notion of &ldquo;highest priority&rdquo; was
&ldquo;the largest number&rdquo;.  In this setting, our notion of highest priority is
going to be &ldquo;cheapest-weighted flight.&rdquo;</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Reimplement the priority queue data structure from <a href="lecture29.html" data-pltdoc="x">Lecture 29</a>, so
that the <span class="emph">minimum</span> number is always at the top of the heap, rather than
the maximum.  This should be fairly straightforward...  Abstract your
definitions of max-heaps and min-heaps to be a single implementation: how can
you abstract over the heap-ordering to be used?</div></p></blockquote><p>Suppose we simply copy the implementation from breadth-first search, but change
the use of a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">Deque</span><span class="RktMeta"></span></span></span> to the use of a <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">PriorityQueue</span><span class="RktMeta"></span></span></span>.  What weights
should we use as the priorities?</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">searchHelp</span><span class="ProfjKeyword">(</span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">from</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Deque</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">PriorityQueue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">PriorityQueue</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Vertex</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjError">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Initialize the worklist with the from vertex
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">from</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// As long as the worklist isn't empty...
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">while</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">!</span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">Vertex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">equals</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">to</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">true</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// Success!
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">contains</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// do nothing: we've already seen this one
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// add all the neighbors of next to the worklist for further processing
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjType">Edge</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">e</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">:</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">outEdges</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">        </span><span class="ProfjComment">// What should the priorities be?
</span><span class="ProfjWhiteSpace">        </span><span class="ProfjIdentifier">worklist</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">e</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">to</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">?</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// add next to alreadySeen, since we're done with it
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">alreadySeen</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">addAtHead</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">next</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// We haven't found the to vertex, and there are no more to try
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">false</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>Supppose we simply use each edge&rsquo;s weight.  Let&rsquo;s see if that works with the
following graph, where we want to get from <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">A</span><span class="RktMeta"></span></span></span> to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">F</span><span class="RktMeta"></span></span></span>:</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_35.png" alt="image" width="326.0" height="90.1328125"/></p><p><div class="SIntrapara">Let&rsquo;s trace the behavior of this algorithm, trying to find a path between A and
F.  Our worklist will be a priority queue, which we&rsquo;ll write as a node name
followed by its priority in parentheses.
</div><div class="SIntrapara"><ol><li><p>The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span> starts off as <span class="stt">[]</span>, and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> is also <span class="stt">[]</span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span></p></li><li><p>We add A to the worklist.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[A(0)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span></p></li><li><p>We start the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: A</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not contain it, we get to the else case, and add each of A&rsquo;s neighbors (namely B and F)
to the worklist, with priorities 1 and 3 respectively.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[B(1), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: B</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of B&rsquo;s neighbors (namely C)
to the worklist, with priority 1.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[C(1), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: C</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of C&rsquo;s neighbors (namely D)
to the worklist, with priority 1.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[D(1), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: D</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of D&rsquo;s neighbors (namely E)
to the worklist, with priority 1.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[E(1), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C, D]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C, D]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: E</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of E&rsquo;s neighbors (namely F)
to the worklist, with priority 1.</p><p><div class="SIntrapara"><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(1), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C, D, E]</span>
      </div><div class="SIntrapara"><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Why is F present in the queue twice?</div></p></blockquote></div></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t
empty, we remove the first item and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C, D, E]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: F</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> is our destination, we stop.</p></li></ol></div><div class="SIntrapara">But notice the path that we took to get there!  A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F has a total
cost of 5, despite there being a cheaper overall path A-&gt;F of total cost 3.
Evidently, prioritizing the cheapest <span class="emph">individual</span> edge of the graph
doesn&rsquo;t result in the cheapest <span class="emph">overall</span> path.</div></p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">What should our priorities be instead?</div></p></blockquote><p>Suppose we took a more holistic view: instead of only using the weight of an
individual edge, let&rsquo;s use the edge weight <span class="emph">plus</span> the total cost to get to
the node so far.  That way, our priorities will account for the cost of the
total path, and if an initially-promising path turns out to be more expensive
than we thought, another cheaper path will eventually beat it out to the front
of the priority queue, and we&rsquo;ll switch paths entirely.</p><p><div class="SIntrapara">Let&rsquo;s trace through that.
</div><div class="SIntrapara"><ol><li><p>The <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span> starts off as <span class="stt">[]</span>, and <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> is also <span class="stt">[]</span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span></p></li><li><p>We add A to the worklist.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[A(0)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span></p></li><li><p>We start the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: A,
weight so far: 0</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not contain it, we get to the else case, and add each of A&rsquo;s neighbors (namely B and F)
to the worklist, with priorities 1 and 3 respectively, <span class="emph">plus the
weight so far of 0.</span></p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[B(1), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: B, weight so far: 1</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of B&rsquo;s neighbors (namely C)
to the worklist, with priority 1, <span class="emph">plus the weight so far of 1.</span></p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[C(2), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B]</span>,
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: C, weight so far: 2</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of C&rsquo;s neighbors (namely D)
to the worklist, with priority 1 <span class="emph">plus the weight so far of 2.</span></p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[D(3), F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t empty, we remove the first item from it and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C]</span>,
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: D, weight so far: 3</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> isn&rsquo;t node F, and since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span> does not
contain it, we get to the else case, and add each of D&rsquo;s neighbors (namely E)
to the worklist, with priority 1 <span class="emph">plus the weight so far of 3.</span></p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[F(3), E(4)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C, D]</span></p></li><li><p>We return to the start of the while loop.  Since the worklist isn&rsquo;t
empty, we remove the first item and assign it to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>.</p><p><span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">worklist</span><span class="RktMeta"></span></span></span>: <span class="stt">[E(4)]</span>, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">alreadySeen</span><span class="RktMeta"></span></span></span>: <span class="stt">[A, B, C, D, E]</span>,
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span>: F, weight so far: 3</p></li><li><p>Since <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">next</span><span class="RktMeta"></span></span></span> is our destination, we stop.</p></li></ol></div><div class="SIntrapara">This time, we found our destination with a total weight of 3, because
eventually the longer path became more expensive (and therefore of lower
priority) than the direct flight.</div></p><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Extend the code above so that instead of merely returning true, it
returns a list of the vertices along the path from the source to the
destination.</div></p></blockquote><h5 class="heading">31.1.1<tt>&nbsp;</tt><a name="(part._.Efficiency_of_cheapest-first_search)"></a>Efficiency of cheapest-first search<span class="button-group"><a href="#(part._.Efficiency_of_cheapest-first_search)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>We process every edge in the graph at most once, and add it to the priority
queue at most once.  Our worklist could, partway through the algorithm, contain
nearly all of the edges in the graph.  The maintenance of the priority queue
will therefore be the overarching cost of the algorithm, and is at worst
\(O(E\log_2 E)\).</p><h5 class="heading">31.1.2<tt>&nbsp;</tt><a name="(part._.Rewriting_.B.F.S_and_.D.F.S_again)"></a>Rewriting BFS and DFS again<span class="button-group"><a href="#(part._.Rewriting_.B.F.S_and_.D.F.S_again)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">We can unify all three of our searching algorithms to use the same code for all
three, provided that we generalize the <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ICollection</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span> interface
slightly:
</div><div class="SIntrapara"><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjComment">// Represents a mutable collection of items
</span><span class="ProfjKeyword">interface</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ICollection</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">T</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Is this collection empty?
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjPrimType">boolean</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">isEmpty</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// EFFECT: adds the item to the collection with the given priority
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">void</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">item</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">priority</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Returns the first item of the collection
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// EFFECT: removes that first item
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">T</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remove</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div></div><div class="SIntrapara">Our stack and queue implementations are free to ignore this <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">priority</span><span class="RktMeta"></span></span></span>
argument, as they clearly don&rsquo;t need it.  But now we can bring a
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">PriorityQueue</span><span class="RktMeta"></span></span></span> implementation into the same framework as our prior two
algorithms, which emphasizes that at heart, they are all one and the same
algorithm: their only distinguishing feature is the strategy by which they
choose the next node to process.</div></p><h5 class="heading">31.2<tt>&nbsp;</tt><a name="(part._.Dijkstra_s_algorithm)"></a>Dijkstra&rsquo;s algorithm<span class="button-group"><a href="#(part._.Dijkstra_s_algorithm)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>The algorithm presented above is, in essence, a famous algorithm discovered by
Edsger Dijkstra in 1956.  His original version of the algorithm is written
slightly differently: it avoids adding a node to the worklist more than once.
The tradeoff is that he still needs to be able to <span class="emph">raise the priority</span>
(i.e. lower the weight) of a node already existing in the priority queue, to
accommodate finding a cheaper route through the graph as the algorithm proceeds
(as we did with node F above).  Raising the priority of an item in a heap is
easy &#8212;<wbr></wbr> we just run the upheap procedure on it.  The tricky part is
<span class="emph">finding</span> the item to be given a higher priority!  Our existing binary
heap implementation is not very good at that, since the tree has no structure
we can use for <span class="emph">searching</span>.  However, we could simply store a reference
inside each graph vertex that refers to its node in the heap.  Once we&rsquo;ve got
that, we can fairly easily trigger the upheap process as needed.</p><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Revise your implementations of the code above to handle this
optimization.</div></p></blockquote><p>Dijkstra specified his algorithm using different implementations of priority
queues than the binary heap that we implemented in <a href="lecture29.html" data-pltdoc="x">Lecture 29</a>.  Using other,
more sophisticated (and complex) heap implementations can bring down the cost
of this algorithm to something cheaper, \(O(E + V \log_2 V)\).  Obtaining
this better efficiency is beyond the scope of Fundies 2 &#8212;<wbr></wbr> look forward to it
in algorithms!</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="lecture30.html" title="backward to &quot;Lecture 30: Breadth-first search and Depth-first search on graphs&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="lecture32.html" title="forward to &quot;Lecture 32: Minimum Spanning Trees&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>