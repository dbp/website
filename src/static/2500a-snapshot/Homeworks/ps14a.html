<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Homework 14a</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../pretty.css" title="default"/><link rel="stylesheet" type="text/css" href="../pygments.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="../index.html" class="tocviewlink" data-pltdoc="x">Accelerated Fundamentals of Computer Science 1</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="../general/index.html" class="tocviewlink" data-pltdoc="x">General Information</a></td></tr><tr><td align="right"></td><td><a href="../advice/index.html" class="tocviewlink" data-pltdoc="x">Advice</a></td></tr><tr><td align="right"></td><td><a href="../syllabus/index.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="../ofc_hrs/index.html" class="tocviewlink" data-pltdoc="x">Office Hours/<span class="mywbr"> &nbsp;</span>Contact</a></td></tr><tr><td align="right"></td><td><a href="../comm/index.html" class="tocviewlink" data-pltdoc="x">Email, Discord</a></td></tr><tr><td align="right"></td><td><a href="index.html" class="tocviewselflink" data-pltdoc="x">Homeworks</a></td></tr><tr><td align="right"></td><td><a href="../labs/index.html" class="tocviewlink" data-pltdoc="x">Labs</a></td></tr><tr><td align="right"></td><td><a href="../style/index.html" class="tocviewlink" data-pltdoc="x">The Style</a></td></tr><tr><td align="right"></td><td><a href="../texts/index.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="../contract/index.html" class="tocviewlink" data-pltdoc="x">Course Contract</a></td></tr><tr><td align="right"></td><td><a href="../design_recipe/index.html" class="tocviewlink" data-pltdoc="x">The Design Recipe</a></td></tr><tr><td align="right"></td><td><a href="../placement/index.html" class="tocviewlink" data-pltdoc="x">Placement Test</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Homeworks</a></td></tr></table><div class="tocviewsublistbottom" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="ps1b.html" class="tocviewlink" data-pltdoc="x">Homework 1b</a></td></tr><tr><td align="right"></td><td><a href="ps2a.html" class="tocviewlink" data-pltdoc="x">Homework 2a</a></td></tr><tr><td align="right"></td><td><a href="ps2b.html" class="tocviewlink" data-pltdoc="x">Homework 2b</a></td></tr><tr><td align="right"></td><td><a href="ps3a.html" class="tocviewlink" data-pltdoc="x">Homework 3a</a></td></tr><tr><td align="right"></td><td><a href="ps3b.html" class="tocviewlink" data-pltdoc="x">Homework 3b</a></td></tr><tr><td align="right"></td><td><a href="ps4a.html" class="tocviewlink" data-pltdoc="x">Homework 4a</a></td></tr><tr><td align="right"></td><td><a href="ps4b.html" class="tocviewlink" data-pltdoc="x">Homework 4b</a></td></tr><tr><td align="right"></td><td><a href="ps5b.html" class="tocviewlink" data-pltdoc="x">Homework 5b</a></td></tr><tr><td align="right"></td><td><a href="ps6b.html" class="tocviewlink" data-pltdoc="x">Homework 6b</a></td></tr><tr><td align="right"></td><td><a href="ps7a.html" class="tocviewlink" data-pltdoc="x">Homework 7a</a></td></tr><tr><td align="right"></td><td><a href="ps7b.html" class="tocviewlink" data-pltdoc="x">Homework 7b</a></td></tr><tr><td align="right"></td><td><a href="ps8a.html" class="tocviewlink" data-pltdoc="x">Homework 8a</a></td></tr><tr><td align="right"></td><td><a href="ps8b.html" class="tocviewlink" data-pltdoc="x">Homework 8b</a></td></tr><tr><td align="right"></td><td><a href="ps9a.html" class="tocviewlink" data-pltdoc="x">Homework 9a</a></td></tr><tr><td align="right"></td><td><a href="ps9b.html" class="tocviewlink" data-pltdoc="x">Homework 9b</a></td></tr><tr><td align="right"></td><td><a href="ps10b.html" class="tocviewlink" data-pltdoc="x">Homework 10b</a></td></tr><tr><td align="right"></td><td><a href="ps11a.html" class="tocviewlink" data-pltdoc="x">Homework 11a</a></td></tr><tr><td align="right"></td><td><a href="ps11b.html" class="tocviewlink" data-pltdoc="x">Homework 11b</a></td></tr><tr><td align="right"></td><td><a href="ps12a.html" class="tocviewlink" data-pltdoc="x">Homework 12a</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 14a</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.10</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="ps12a.html" title="backward to &quot;Homework 12a&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Homeworks&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="../labs/index.html" title="forward to &quot;Labs&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._ps14a)"></a>Homework 14a</h3><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><img src="assignments.png" alt="home work!" width="121" height="132"/></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Programming Language</span>  <span style="color: red">#lang htdp/isl+</span></div></p><p><span style="color: red">MUST BE DONE WITH YOUR PARTNER</span></p><p><span style="color: red">MUST USE CHECKED-SIGNATURES!</span></p><p><span style="font-weight: bold">Due Date</span> Tues at 9:00pm (<a href="../syllabus/index.html#%28part._14%29" data-pltdoc="x">Week 14</a>)</p><p><span style="font-weight: bold">Purpose</span> Add set! and set-box! to StateLang.</p><p><span style="font-weight: bold">Exercises</span></p><p>In this assignment, you will extend your language from 11A to include memory
operations, set! and set-box!.</p><p>While this is essentially an extension, in order to make sure you are starting
from the right place, we want you to start by fixing your existing solution and
making sure it passes a suite of automated tests. This does mean you have to
adapt to our data definitions, as follows, which may vary slightly from your
own. Note that throughout the assignment we are using suffixes, as you will be
extending them later (twice). You should submit all three versions of the code!
But start by submitting once you finish Exercise 1 and ensure you pass all the
automated tests before moving on.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">:</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">op?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Any</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">-&gt;</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Boolean</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">determines whether argument is the symbol of an arithmetic operator</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">op?</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">member</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">+</span><span class="hspace">&nbsp;</span><span class="RktVal"><span class="nobreak">-</span></span><span class="hspace">&nbsp;</span><span class="RktVal">*</span><span class="hspace">&nbsp;</span><span class="RktVal">/</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Op</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">predicate</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">op?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-num</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-var</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">sym</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-op</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">op</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">left</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">right</span></span></span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-lam</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">param</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-app</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">fun</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mixed</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ENumOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Number</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">EVarOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">EOpOf</span><span class="hspace">&nbsp;</span><span class="RktSym">Op</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ELamOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">EAppOf</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">ValV1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mixed</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ENumOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Number</span></span></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ELamOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><blockquote><p><span style="font-weight: bold">Exercise 1 </span> Rename your parse, subst, eval, and wf to parse-v1, subst-v1,
eval-v1, and wf-v1. Ensure they pass all their tests. The signatures/headers
that we expect are:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">:</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">parse-v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">S-Exp</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">-&gt;</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">e</span></span></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">:</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">subst-v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym">Var</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">-&gt;</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst-v1</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">e</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">to</span><span class="hspace">&nbsp;</span><span class="RktSym">from</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">:</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">eval-v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">-&gt;</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Val</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eval-v1</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">e</span></span></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">:</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">wf-v1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">-&gt;</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">wf-v1</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">e</span></span></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span></td></tr></table></blockquote><p>Note that we are providing
automated tests for this problem (only), which you can use to make sure you have
the correct starting point for the rest of the assignment.</p></blockquote><p>Now, we want to start adding state. In order to do this, we are
providing you with a library file which gives you access to a few features that
aren&rsquo;t in ISL+: hashtables and gensym. Please download the file
<a href="../lib.rkt">lib.rkt</a>, put it in the same directory as your code and
add <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"lib.rkt"</span><span class="RktPn">)</span><span class="RktMeta"></span> at the top of your file.</p><p>Hashtables we showed in class when we were using ASL: they are a key-value store
that is much more efficient than using a list of pairs (but express the same
thing). You can look at this <a href="https://docs.racket-lang.org/reference/hashtables.html">documentation page</a>
 for descriptions of the various
functions we have provided.</p><p>We also provide a <span class="RktSym">HashMapOf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">K</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">V</span><span class="RktMeta"></span> signature that, given signatures for Keys &amp; Values will construct a signature for hashtables.</p><p>The other function, <span class="RktSym">gensym</span><span class="RktMeta"></span>, is a function that will return unique
symbols. You pass it a symbol prefix, and it returns a unique symbol starting
with that prefix (it adds a unique number after). We showed how to implement
this in class using mutable state. This will be useful for your implementation.</p><blockquote><p><span style="font-weight: bold">Exercise 2 </span> Your first task is to implement <span class="RktSym">set!</span><span class="RktMeta"></span>. First, add a struct and
a new version of the Expr signatures (you can call these <span class="RktSym">ExprV2</span><span class="RktMeta"></span>
and <span class="RktSym">ValV2</span><span class="RktMeta"></span>). Like ASL, we will only allow variables as the first argument to <span class="RktSym">set!</span><span class="RktMeta"></span>.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-set!</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">id</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">EVarOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ESet!Of</span><span class="hspace">&nbsp;</span><span class="RktSym">Var</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>If you don&rsquo;t remember, please revisit how <span class="RktSym">set!</span><span class="RktMeta"></span> works in ASL.</p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 3 </span>Now, make an updated version of your parser (<span class="RktSym">parse-v2</span><span class="RktMeta"></span>). This
should then allow you to write test cases for <span class="RktSym">eval-v2</span><span class="RktMeta"></span> (which you haven&rsquo;t
implemented yet). You should update subst (<span class="RktSym">subst-v2</span><span class="RktMeta"></span>), for now just
substituting in the second argument of the set! (we&rsquo;ll come back to making this
actually work, later). The last helper to update is wf (<span class="RktSym">wf-v2</span><span class="RktMeta"></span>): this
should be a very simple change.</p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 4 </span> Now the interesting part: updating eval. If you try to make a simple
change (i.e., just add another branch of the cond), it won&rsquo;t work. What goes
wrong? Part of the problem is that state is not <span style="font-style: italic">local</span>, so if in one
subexpression you mutate a variable, you need to communicate that change to
subsequent uses of the variable. i.e., <span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">lambda</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">+</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span>
should return 1, not 2.</p><p>There are a couple approaches to this, the one we will use for this HW is based
on a simplified model of memory that we&rsquo;ll call a "Store". This will "store"
values and unique identifiers ("locations") that map to them. Concretely, the
store should be a hashtable that has symbols as keys (locations in the store)
and <span class="RktSym">Val</span><span class="RktMeta"></span>&rsquo;s as values.</p><p>We&rsquo;ll do this in several steps.</p><p>First, you should add an argument to <span class="RktSym">eval-v2</span><span class="RktMeta"></span> for your store. In addition to passing the store to calls to eval,
it should be threaded back out of any intermediate calls: i.e., the output of
one call has to be passed in to the next. This means you should define a Result
struct &amp; type as follows, and <span class="RktSym">eval-v2</span><span class="RktMeta"></span> should return a <span class="RktSym">Result</span><span class="RktMeta"></span>.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">res</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">store</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Result</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ResOf</span><span class="hspace">&nbsp;</span><span class="RktSym">Store</span><span class="hspace">&nbsp;</span><span class="RktSym">Val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Next, implement the argument threading: don&rsquo;t change the store, just thread it
through all recursive calls.</p><p>Now, we want to start using the store. First, add a new term in the expression grammar: a location that exists in the store.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">e-loc</span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktSym">sym</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">Loc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ELocOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym">ExprV2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ELocOf</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Now, we&rsquo;ve added this to our expressions, but we don&rsquo;t actually want
<span style="font-style: italic">programmers</span> to use these, so update <span class="RktSym">wf-v2</span><span class="RktMeta"></span> to raise an error on
these terms. Since <span class="RktSym">wf-v2</span><span class="RktMeta"></span> is only called once, at the beginning, it is
okay if these terms appear during evaluation.</p><p>You should next add case to <span class="RktSym">eval-v2</span><span class="RktMeta"></span> that handles this new expression: it
should look up the value of the location in the store. How are we going to use
this? On function application, rather than just substituting the value for the
occurrences of the variable, you first allocate a new entry in the store (use
<span class="RktSym">gensym</span><span class="RktMeta"></span> to make a unique identifier for a key) and then substitute that
for all occurrences of the variable.</p><p>That does mean that the signature of <span class="RktSym">subst-v2</span><span class="RktMeta"></span> should change, since we are
no longer substituting values, but <span class="RktSym">ELocOf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktMeta"></span>s.</p><p>i.e., in the example above, <span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">lambda</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">+</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span>, once you
evaluate the application, assuming you generated the location <span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktMeta"></span> and
put that, mapped to 2, in the store, you would substitute <span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktMeta"></span> for
occurrences of <span class="RktSym">x</span><span class="RktMeta"></span>, yielding something like: <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">+</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">loc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">loc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span>.</p><p>Since you want to be able to write tests for <span class="RktSym">subst-v2</span><span class="RktMeta"></span> and <span class="RktSym">eval-v2</span><span class="RktMeta"></span>,
you should add support in <span class="RktSym">parse-v2</span><span class="RktMeta"></span> for a syntax like the above. Note
that, even though we are supporting it in our parser, we do not want programmers
to write these location literals in their programs: we rule that out with
<span class="RktSym">wf-v2</span><span class="RktMeta"></span>. They should only appear while the program is <span style="font-style: italic">running</span>).
But since we want to <span style="font-style: italic">test</span> such intermediate points, it&rsquo;s helpful to be
able to parse them.</p><p>Now, you are finally ready to implement the case in <span class="RktSym">eval-v2</span><span class="RktMeta"></span> for
<span class="RktSym">set!</span><span class="RktMeta"></span>. One thing you may have noticed is that if you substituted for the
first argument of set!, you violated the signature, as the signature said
<span class="RktSym">ESet!Of</span><span class="RktMeta"></span> only had a Var as the first argument. Fix that by adding a
signature for Loc and make the actual first argument to ESet!Of be a
<span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mixed</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Var</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Loc</span><span class="RktPn">)</span><span class="RktMeta"></span>. Initially (enforced by <span class="RktSym">wf-v2</span><span class="RktMeta"></span>) this will be a
<span class="RktSym">Var</span><span class="RktMeta"></span>, but after <span class="RktSym">subst-v2</span><span class="RktMeta"></span>, it will be a <span class="RktSym">Loc</span><span class="RktMeta"></span>.</p><p>Since you can assume that <span class="RktSym">wf-v2</span><span class="RktMeta"></span> has been run, this means there should not
be any variables that are not substituted on application. Once you have
evaluated the second argument, you should update what what the store contains
for the given location with that value.</p><p>Make sure your tests pass!</p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 5 </span>With <span class="RktSym">set!</span><span class="RktMeta"></span> implemented, its time to move on to <span class="RktSym">set-box!</span><span class="RktMeta"></span>.
For this exercise, we want you to copy your implementations into
<span class="RktSym">parse-v3</span><span class="RktMeta"></span>, <span class="RktSym">subst-v3</span><span class="RktMeta"></span>, <span class="RktSym">wf-v3</span><span class="RktMeta"></span>, <span class="RktSym">eval-v3</span><span class="RktMeta"></span>, etc. First, you
need to extend your Expr and Val definitions to account for the new terms:
<span class="RktSym">box</span><span class="RktMeta"></span>, <span class="RktSym">unbox</span><span class="RktMeta"></span>, and <span class="RktSym">set-box!</span><span class="RktMeta"></span>. You also need a <span style="font-style: italic">value</span>
form for a boxed location: create the struct and extend the Val definition to
account for this. Update <span class="RktSym">parse-v3</span><span class="RktMeta"></span>, <span class="RktSym">subst-v3</span><span class="RktMeta"></span>, and <span class="RktSym">wf-v3</span><span class="RktMeta"></span>. Use
<span class="RktSym">parse-v3</span><span class="RktMeta"></span> to write a bunch of tests for <span class="RktSym">eval-v3</span><span class="RktMeta"></span> using these new
definitions!</p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 6 </span>Now, start by implementing <span class="RktSym">box</span><span class="RktMeta"></span>. This should evaluate the
expression inside, allocate a new location, and put the value in the store at
that location. It should evaluate <span style="font-style: italic">to</span> the boxed location (the new value
form).</p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 7 </span>Next, implement <span class="RktSym">unbox</span><span class="RktMeta"></span>. This should evaluate its argument, and
assuming it is a boxed location, it should look the location up in the store and
return the value that is stored there.</p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 8 </span>Finally, implement <span class="RktSym">set-box!</span><span class="RktMeta"></span>. This should evaluate both
arguments, and the first should be a boxed location. It should update the value
in the store at the given location with the new value (what the second argument
evaluated to).</p></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="ps12a.html" title="backward to &quot;Homework 12a&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Homeworks&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="../labs/index.html" title="forward to &quot;Labs&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>