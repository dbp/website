<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Homework 13b</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../pretty.css" title="default"/><link rel="stylesheet" type="text/css" href="../pygments.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="../index.html" class="tocviewlink" data-pltdoc="x">Accelerated Fundamentals of Computer Science 1</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="../general/index.html" class="tocviewlink" data-pltdoc="x">General Information</a></td></tr><tr><td align="right"></td><td><a href="../advice/index.html" class="tocviewlink" data-pltdoc="x">Advice</a></td></tr><tr><td align="right"></td><td><a href="../syllabus/index.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="../ofc_hrs/index.html" class="tocviewlink" data-pltdoc="x">Office Hours/<span class="mywbr"> &nbsp;</span>Contact</a></td></tr><tr><td align="right"></td><td><a href="../comm/index.html" class="tocviewlink" data-pltdoc="x">Email, Discord</a></td></tr><tr><td align="right"></td><td><a href="index.html" class="tocviewselflink" data-pltdoc="x">Homeworks</a></td></tr><tr><td align="right"></td><td><a href="../labs/index.html" class="tocviewlink" data-pltdoc="x">Labs</a></td></tr><tr><td align="right"></td><td><a href="../style/index.html" class="tocviewlink" data-pltdoc="x">The Style</a></td></tr><tr><td align="right"></td><td><a href="../texts/index.html" class="tocviewlink" data-pltdoc="x">Texts</a></td></tr><tr><td align="right"></td><td><a href="../contract/index.html" class="tocviewlink" data-pltdoc="x">Course Contract</a></td></tr><tr><td align="right"></td><td><a href="../design_recipe/index.html" class="tocviewlink" data-pltdoc="x">The Design Recipe</a></td></tr><tr><td align="right"></td><td><a href="../placement/index.html" class="tocviewlink" data-pltdoc="x">Placement Test</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Homeworks</a></td></tr></table><div class="tocviewsublistbottom" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="ps1b.html" class="tocviewlink" data-pltdoc="x">Homework 1b</a></td></tr><tr><td align="right"></td><td><a href="ps2a.html" class="tocviewlink" data-pltdoc="x">Homework 2a</a></td></tr><tr><td align="right"></td><td><a href="ps2b.html" class="tocviewlink" data-pltdoc="x">Homework 2b</a></td></tr><tr><td align="right"></td><td><a href="ps3a.html" class="tocviewlink" data-pltdoc="x">Homework 3a</a></td></tr><tr><td align="right"></td><td><a href="ps3b.html" class="tocviewlink" data-pltdoc="x">Homework 3b</a></td></tr><tr><td align="right"></td><td><a href="ps4a.html" class="tocviewlink" data-pltdoc="x">Homework 4a</a></td></tr><tr><td align="right"></td><td><a href="ps4b.html" class="tocviewlink" data-pltdoc="x">Homework 4b</a></td></tr><tr><td align="right"></td><td><a href="ps5b.html" class="tocviewlink" data-pltdoc="x">Homework 5b</a></td></tr><tr><td align="right"></td><td><a href="ps6b.html" class="tocviewlink" data-pltdoc="x">Homework 6b</a></td></tr><tr><td align="right"></td><td><a href="ps7a.html" class="tocviewlink" data-pltdoc="x">Homework 7a</a></td></tr><tr><td align="right"></td><td><a href="ps7b.html" class="tocviewlink" data-pltdoc="x">Homework 7b</a></td></tr><tr><td align="right"></td><td><a href="ps8a.html" class="tocviewlink" data-pltdoc="x">Homework 8a</a></td></tr><tr><td align="right"></td><td><a href="ps8b.html" class="tocviewlink" data-pltdoc="x">Homework 8b</a></td></tr><tr><td align="right"></td><td><a href="ps9a.html" class="tocviewlink" data-pltdoc="x">Homework 9a</a></td></tr><tr><td align="right"></td><td><a href="ps9b.html" class="tocviewlink" data-pltdoc="x">Homework 9b</a></td></tr><tr><td align="right"></td><td><a href="ps10b.html" class="tocviewlink" data-pltdoc="x">Homework 10b</a></td></tr><tr><td align="right"></td><td><a href="ps11a.html" class="tocviewlink" data-pltdoc="x">Homework 11a</a></td></tr><tr><td align="right"></td><td><a href="ps11b.html" class="tocviewlink" data-pltdoc="x">Homework 11b</a></td></tr><tr><td align="right"></td><td><a href="ps12a.html" class="tocviewlink" data-pltdoc="x">Homework 12a</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 13b</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.10</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="ps12a.html" title="backward to &quot;Homework 12a&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Homeworks&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="../labs/index.html" title="forward to &quot;Labs&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._ps13b)"></a>Homework 13b</h3><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><img src="assignments.png" alt="home work!" width="121" height="132"/></p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Programming Language</span>  <span style="color: red">#lang htdp/isl+</span></div></p><p><span style="font-weight: bold">Due Date</span> Thu at 9:00pm (<a href="../syllabus/index.html#%28part._13%29" data-pltdoc="x">Week 13</a>)</p><p><span style="font-weight: bold">Purpose</span> Add set! and set-box! to StateLang.</p><p><span style="font-weight: bold">Exercises</span></p><p>In this assignment, you will extend your language from 11A to include memory
operations, set! and set-box!.</p><p>While this is essentially an extension, in order to support automated tests, we
want you to refactor your code to use the following data definition, which may
vary slightly from your own. Note that we have given the signatures prefixes, as
you will be extending them later, but we want you to submit both the original
and extended versions.</p><p><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">:</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">op?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">Any</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">-&gt;</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">Boolean</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">;;</span><span class="hspace">&nbsp;</span><span class="RktCmt">determines</span><span class="hspace">&nbsp;</span><span class="RktCmt">whether</span><span class="hspace">&nbsp;</span><span class="RktCmt">argument</span><span class="hspace">&nbsp;</span><span class="RktCmt">is</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">arithmetic</span><span class="hspace">&nbsp;</span><span class="RktCmt">operator</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define</span><span class="hspace">&nbsp;</span><span class="RktCmt">(op?</span><span class="hspace">&nbsp;</span><span class="RktCmt">s)</span><span class="hspace">&nbsp;</span><span class="RktCmt">(member</span><span class="hspace">&nbsp;</span><span class="RktCmt">s</span><span class="hspace">&nbsp;</span><span class="RktCmt">'(+</span><span class="hspace">&nbsp;</span><span class="RktCmt">-</span><span class="hspace">&nbsp;</span><span class="RktCmt">*</span><span class="hspace">&nbsp;</span><span class="RktCmt">/)))</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define</span><span class="hspace">&nbsp;</span><span class="RktCmt">Op</span><span class="hspace">&nbsp;</span><span class="RktCmt">(signature</span><span class="hspace">&nbsp;</span><span class="RktCmt">(predicate</span><span class="hspace">&nbsp;</span><span class="RktCmt">op?)))</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define-struct</span><span class="hspace">&nbsp;</span><span class="RktCmt">e-num</span><span class="hspace">&nbsp;</span><span class="RktCmt">[num])</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define-struct</span><span class="hspace">&nbsp;</span><span class="RktCmt">e-var</span><span class="hspace">&nbsp;</span><span class="RktCmt">[sym])</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define-struct</span><span class="hspace">&nbsp;</span><span class="RktCmt">e-op</span><span class="hspace">&nbsp;</span><span class="RktCmt">[op</span><span class="hspace">&nbsp;</span><span class="RktCmt">left</span><span class="hspace">&nbsp;</span><span class="RktCmt">right])</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define-struct</span><span class="hspace">&nbsp;</span><span class="RktCmt">e-lam</span><span class="hspace">&nbsp;</span><span class="RktCmt">[param</span><span class="hspace">&nbsp;</span><span class="RktCmt">body])</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define-struct</span><span class="hspace">&nbsp;</span><span class="RktCmt">e-app</span><span class="hspace">&nbsp;</span><span class="RktCmt">[fun</span><span class="hspace">&nbsp;</span><span class="RktCmt">arg])</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1</span><span class="hspace">&nbsp;</span><span class="RktCmt">(signature</span><span class="hspace">&nbsp;</span><span class="RktCmt">(mixed</span><span class="hspace">&nbsp;</span><span class="RktCmt">(ENumOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">Number)</span><span class="hspace">&nbsp;</span><span class="RktCmt">(EVarOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">Symbol)</span><span class="hspace">&nbsp;</span><span class="RktCmt">(EOpOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">Op</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1)</span><span class="hspace">&nbsp;</span><span class="RktCmt">(ELamOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">Symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1)</span><span class="hspace">&nbsp;</span><span class="RktCmt">(EAppOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1))))</span><span class="hspace">&nbsp;</span><span class="RktCmt">(define</span><span class="hspace">&nbsp;</span><span class="RktCmt">ValV1</span><span class="hspace">&nbsp;</span><span class="RktCmt">(signature</span><span class="hspace">&nbsp;</span><span class="RktCmt">(mixed</span><span class="hspace">&nbsp;</span><span class="RktCmt">(ENumOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">Number)</span><span class="hspace">&nbsp;</span><span class="RktCmt">(ELamOf</span><span class="hspace">&nbsp;</span><span class="RktCmt">Symbol</span><span class="hspace">&nbsp;</span><span class="RktCmt">ExprV1)))</span><span class="RktMeta"></span></p><blockquote><p><span style="font-weight: bold">Exercise 1 </span> Rename your parse, subst, eval, and wf to parse-v1, subst-v1,
eval-v1, and wf-v1. Ensure they pass all their tests.</p></blockquote><p>Now, we want to start adding state. In order to do this, we are
providing you with a library file which gives you access to a few features that
aren&rsquo;t in ISL+: hashtables and gensym. Please download the file
<a href="../lib.rkt">lib.rkt</a>, put it in the same directory as your code and
add <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"lib.rkt"</span><span class="RktPn">)</span><span class="RktMeta"></span> at the top of your file.</p><p>Hashtables we showed in class when we were using ASL: they are a key-value store
that is much more efficient than using a list of pairs (but express the same
thing). You can look at this documentation page for descriptions of the various
functions we have provided:</p><p><a href="https://docs.racket-lang.org/reference/hashtables.html">Hashtables</a></p><p>The other function, <span class="RktSym">gensym</span><span class="RktMeta"></span>, is a function that will return unique
symbols. You pass it a symbol prefix, and it returns a unique symbol starting
with that prefix (it adds a unique number after). We showed how to implement
this in class using mutable state. This will be useful for your implementation.</p><blockquote><p><span style="font-weight: bold">Exercise 2 </span> Your first task is to implement <span class="RktSym">set!</span><span class="RktMeta"></span>. First, add a struct and
a new version of the Expr signatures (you can call these <span class="RktSym">ExprV2</span><span class="RktMeta"></span>
and <span class="RktSym">ValV2</span><span class="RktMeta"></span>). Like ASL, we will only allow variables as the first argument to <span class="RktSym">set!</span><span class="RktMeta"></span>.</p><p><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e-set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">id</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">arg</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Var</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">EVarOf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprV2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">ESet!Of</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Loc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Expr</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></p><p>If you aren&rsquo;t sure, revisit how <span class="RktSym">set!</span><span class="RktMeta"></span> works in ASL. Make an updated
version of your parser (<span class="RktSym">parse-v2</span><span class="RktMeta"></span>), subst (<span class="RktSym">subst-v2</span><span class="RktMeta"></span>), and wf
(<span class="RktSym">wf-v2</span><span class="RktMeta"></span>) that supports <span class="RktSym">set!</span><span class="RktMeta"></span>. These should be relatively easy
changes. </p></blockquote><blockquote><p><span style="font-weight: bold">Exercise 3 </span> Now the interesting part: updating eval. First, start by writing some
test cases that show how an updated <span class="RktSym">eval-v2</span><span class="RktMeta"></span> should work with <span class="RktSym">set!</span><span class="RktMeta"></span>.
If you try to make a simple change (i.e., just add another branch of the cond)
what goes wrong? Part of the problem is that state is not <span style="font-style: italic">local</span>, so if
in one subexpression you mutate a variable, you need to communicate that to
subsequent uses of the variable. i.e., <span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">lambda</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">+</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span>
should return 1, not 2.</p><p>There are a couple approaches to this, the one we
suggest for this HW is based on a simplified model of memory that we&rsquo;ll call a
"Store". This will "store" values and unique identifiers that map to them.
Concretely, the store should be a hashtable that has symbols as keys ("locations" in the store) and
<span class="RktSym">Val</span><span class="RktMeta"></span>&rsquo;s as values.</p><p>First, you should add an argument to <span class="RktSym">eval-v2</span><span class="RktMeta"></span> for your store.
Additionally, the store has to be <span style="font-style: italic">threaded</span> through the computation:
i.e., the output of one call has to be passed in to the next. This means you
should define a Result struct &amp; type as follows, and <span class="RktSym">eval-v2</span><span class="RktMeta"></span> should
return a <span class="RktSym">Result</span><span class="RktMeta"></span>.</p><p><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">res</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">store</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">val</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Result</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">ResOf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Store</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></p><p>First, implement the argument threading: don&rsquo;t change the store, just thread it
through all recursive calls.</p><p>Next, we want to start using the store. First, add a new term in the expression grammar: a location that exists in the store.</p><p><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define-struct</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e-loc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">sym</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">define</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">ExprV2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">signature</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">ELocOf</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">Symbol</span></span></span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">...</span></span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></p><p>You should add case to <span class="RktSym">eval-v2</span><span class="RktMeta"></span> that handles this new expression: it
should look up the value of the location in the store. How are we going to use this? On function application, rather than just substituting the value for the occurrences of the variable, you first allocate a new entry in the store (use <span class="RktSym">gensym</span><span class="RktMeta"></span> to make a unique identifier for a key) and then substitute that for all occurrences of the variable. i.e., in the example above, <span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">lambda</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">+</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span>, once you evaluate the application, assuming you generated the location <span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktMeta"></span> and put that, mapped to 2, in the store, you would substitute <span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktMeta"></span> for occurrences of <span class="RktSym">x</span><span class="RktMeta"></span>, yielding something like: <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">+</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">loc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">loc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym"><span class="badlink"><span class="RktValLink">'</span></span></span><span class="RktSym">loc123</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span> (I&rsquo;ve invented syntax for locations, which you probably want to do, and support in your <span class="RktSym">parse-v2</span><span class="RktMeta"></span>, else testing will be hard, but it should not be possible for programmers to write these location literals in their programs: rule them out in you <span class="RktSym">wf-v2</span><span class="RktMeta"></span>. They should only appear while the program is <span style="font-style: italic">running</span>).</p><p>Now, you are finally ready to implement <span class="RktSym">set!</span><span class="RktMeta"></span>. One thing you may have noticed is that if you substituted for the first argument of set!, you violated the signature, as the signature said <span class="RktSym">ESet!Of</span><span class="RktMeta"></span> only had a Var as the first argument. Fix that by adding a signature for Loc and make the actual first argument to ESet!Of be a <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">mixed</span></span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Var</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">Loc</span><span class="RktPn">)</span><span class="RktMeta"></span>.</p><p>Now, add the case to <span class="RktSym">eval-v2</span><span class="RktMeta"></span> for this. You can assume that <span class="RktSym">wf-v2</span><span class="RktMeta"></span>
has been run, which means there should not be any variables that are not
substituted on application. Once you have evaluated the second argument, you should update what what the store contains for the given location with that value.</p><p>Make sure your tests pass!</p></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="ps12a.html" title="backward to &quot;Homework 12a&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Homeworks&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="../labs/index.html" title="forward to &quot;Labs&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>